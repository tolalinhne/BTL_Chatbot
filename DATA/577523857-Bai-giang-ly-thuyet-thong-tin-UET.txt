1/1/2015   BÀI GIẢNG
           LÝ THUYẾT THÔNG TIN




           Nguyễn Phương Thái, Lê Anh Cường
           TRƯỜNG ĐẠI HỌC CÔNG NGHỆ
MỤC LỤC
Chương 1 ............................................................................................................................... 5
GIỚI THIỆU........................................................................................................................... 5
   1.1. VAI TRÒ ..................................................................................................................... 5

      1.1.1. Kỹ thuật điện tử .................................................................................................... 6

      1.1.2. Khoa học máy tính ................................................................................................ 7

      1.1.3. Vật lý .................................................................................................................... 7
      1.1.4. Toán học ............................................................................................................... 7

      1.1.5. Kinh tế học ............................................................................................................ 8

   1.2. CẤU TRÚC CỦA GIÁO TRÌNH.................................................................................. 8
Chương 2 ............................................................................................................................. 10
NHẮC LẠI KIẾN THỨC CƠ BẢN VỀ XÁC SUẤT THỐNG KÊ .............................................. 10
   2.1. CÁC KHÁI NIỆM CƠ BẢN CỦA LÝ THUYẾT XÁC SUẤT ...................................... 10
      2.1.1. Các khái niệm cơ bản .......................................................................................... 11
      2.1.2. Xác suất .............................................................................................................. 13

   2.2. XÁC SUẤT CÓ ĐIỀU KIỆN ...................................................................................... 14

      2.2.1. Xác suất có điều kiện ........................................................................................... 14

      2.2.2. Công thức Bayes ................................................................................................. 16

      2.2.3. Sự độc lập của hai biến cố ................................................................................... 18

   2.3. BIẾN NGẪU NHIÊN ................................................................................................ 18

      2.3.1. Khái niệm biến ngẫu nhiên ................................................................................. 18

      2.3.2. Kỳ vọng và phương sai của biến ngẫu nhiên ....................................................... 19

      2.3.3. Phân phối có điều kiện và phân phối phụ thuộc ................................................. 19
   2.4. MỘT SỐ PHÂN PHỐI CHUẨN ................................................................................ 20

      2.4.1. Phân phối nhị thức .............................................................................................. 20

      2.4.2. Phân phối đa thức ............................................................................................... 21

      2.4.3. Phân phối Poisson ............................................................................................... 22

      2.4.4. Phân phối thực nghiệm ....................................................................................... 23

      2.4.5. Phân phối chuẩn ................................................................................................. 23

      2.4.6. Phân phối beta .................................................................................................... 24

      2.4.7. Phân phối Dirichlet ............................................................................................. 25
Chương 3 ............................................................................................................................. 30


                                                                                                                                        1
ENTROPY, ENTROPY TƯƠNG ĐỐI VÀ THÔNG TIN TƯƠNG HỖ ....................................... 30
   3.1. ENTROPY ................................................................................................................. 30

   3.2. ENTROPY HỢP VÀ ENTROPY ĐIỀU KIỆN ............................................................. 32

   3.3. ENTROPY TƯƠNG ĐỐI VÀ THÔNG TIN TƯƠNG HỖ .......................................... 34
   3.4. CÁC LUẬT XÍCH CHO ENTROPY, ENTROPY TƯƠNG ĐỐI VÀ THÔNG TIN
   TƯƠNG HỖ .................................................................................................................... 35

   3.5. BẤT ĐẲNG THỨC JENSEN ..................................................................................... 37

      3.5.1. Hàm lồi và hàm lõm............................................................................................ 37

      3.5.2. Bất đẳng thức Jensen ........................................................................................... 38

   3.6. BẤT ĐẲNG THỨC THÔNG TIN .............................................................................. 39

   3.7. ĐỊNH LÝ VỀ GIÁ TRỊ CỰC ĐẠI CỦA ENTROPY .................................................... 40
   3.8. CÓ ĐIỀU KIỆN LÀM GIẢM ENTROPY ................................................................... 40

   3.9. CẬN ĐỘC LẬP CỦA ENTROPY .............................................................................. 41

   3.10. BẤT ĐẲNG THỨC TỔNG LOG VÀ ỨNG DỤNG .................................................. 41
      3.10.1. Tính chất lồi của entropy tương đối .................................................................. 42

      3.10.2. Tính chất lõm của entropy ................................................................................. 42

      3.10.3. Tính chất lồi/lõm của thông tin tương hỗ .......................................................... 42

   3.11. BẤT ĐẲNG THỨC XỬ LÝ DỮ LIỆU ...................................................................... 42

   3.12. THỐNG KÊ ĐỦ....................................................................................................... 43

   3.13. BẤT ĐẲNG THỨC FANO ...................................................................................... 44
Chương 4 ............................................................................................................................. 52
TÍNH CHẤT TIỆM CẬN PHÂN PHỐI ĐỀU (AEP) ................................................................. 52
   4.1. TÍNH CHẤT TIỆM CẬN PHÂN HOẠCH ĐỀU ........................................................ 53

   4.2. HỆ QUẢ CỦA AEP: NÉN DỮ LIỆU ......................................................................... 55

   4.3. CÁC TẬP XÁC SUẤT CAO VÀ TẬP ĐIỂN HÌNH ................................................... 57
Chương 5 ............................................................................................................................. 61
TỈ LỆ ENTROPY CỦA QUÁ TRÌNH NGẪU NHIÊN .............................................................. 61
   5.1. CHUỖI MARKOV .................................................................................................... 61

   5.2. TỈ LỆ ENTROPY ....................................................................................................... 63
   5.3. TỈ LỆ ENTROPY CỦA ĐƯỜNG ĐI NGẪU NHIÊN TRONG ĐỒ THỊ CÓ TRỌNG SỐ
   ........................................................................................................................................ 66
   5.4. ĐỊNH LUẬT 2 NHIỆT ĐỘNG LỰC HỌC ................................................................. 69

   5.5. HÀM CỦA CHUỖI MARKOV.................................................................................. 71

                                                                                                                                            2
Chương 6 ............................................................................................................................. 79
NÉN DỮ LIỆU ..................................................................................................................... 79
   6.1. ĐỊNH NGHĨA VÀ VÍ DỤ VỀ MÃ ............................................................................. 79
   6.2. BẤT ĐẲNG THỨC KRAFT ....................................................................................... 81

   6.3. MÃ TỐI ƯU .............................................................................................................. 82

   6.4. CÁC CẬN CỦA ĐỘ DÀI MÃ TỐI ƯU ...................................................................... 83
   6.5. MÃ HUFFMAN ........................................................................................................ 84

   6.6. SỰ TỐI ƯU CỦA MÃ HUFFMAN ............................................................................ 85
Chương 7 ........................................................................................................................... 102
DUNG LƯỢNG KÊNH ....................................................................................................... 102
   7.1. ĐỊNH NGHĨA KÊNH RỜI RẠC VÀ VÍ DỤ ............................................................ 103

      7.1.1. Định nghĩa ........................................................................................................ 103

      7.1.2. Dung lượng kênh .............................................................................................. 103

      7.1.3. Các ví dụ ........................................................................................................... 104

   7.2. KÊNH ĐỐI XỨNG .................................................................................................. 108

   7.3. CÁC TÍNH CHẤT CỦA DUNG LƯỢNG KÊNH .................................................... 108

   7.4. CÁC ĐỊNH NGHĨA CẦN CHO ĐỊNH LÝ MÃ HÓA KÊNH .................................. 109

      7.4.1. Kênh rời rạc ...................................................................................................... 109

      7.4.2. Mở rộng bậc n của kênh rời rạc không nhớ (DMC) ........................................... 109
      7.4.3. Mã (M, n) .......................................................................................................... 109

      7.4.4. Xác suất lỗi có điều kiện .................................................................................... 110
      7.4.5. Xác suất lỗi cực đại............................................................................................ 110

      7.4.6. Tốc độ R ............................................................................................................ 110

      7.4.7. Tốc độ có thể đạt được ...................................................................................... 111

      7.4.8. Dung lượng kênh .............................................................................................. 111

   7.5. CÁC CHUỖI ĐIỂN HÌNH ĐỒNG THỜI ................................................................ 111

   7.6. ĐỊNH LÝ MÃ HÓA KÊNH ..................................................................................... 112

   7.7. MÃ SỬA LỖI .......................................................................................................... 117
   7.8. DUNG LƯỢNG PHẢN HỒI (FEEDBACK CAPACITY) ......................................... 122

   7.9. ĐỊNH LÝ PHÂN TÁCH KÊNH-NGUỒN ............................................................... 124
Chương 8 ........................................................................................................................... 134
TRÒ CHƠI CÁ CƯỢC ........................................................................................................ 134


                                                                                                                                       3
   8.1. TRÒ CHƠI CÁ CƯỢC ĐUA NGỰA ....................................................................... 134

   8.2. CÁ CƯỢC VÀ THÔNG TIN BÊN LỀ ...................................................................... 139

   8.3. CÁC CUỘC ĐUA KHÔNG ĐỘC LẬP VÀ TỈ LỆ ENTROPY ................................... 140

   8.4. ENTROPY CỦA TIẾNG ANH................................................................................. 142
Chương 9 .......................................................................................................................... 150
MÃ DÒNG ......................................................................................................................... 150
   9.1. TRÒ CHƠI DỰ ĐOÁN............................................................................................ 150

   9.2. MÃ HÓA SỐ HỌC .................................................................................................. 151

   9.3. CÁC ỨNG DỤNG MỞ RỘNG CỦA MÃ SỐ HỌC.................................................. 158

   9.4. MÃ HÓA LEMPEL-ZIV .......................................................................................... 159

   9.5. SỰ TỐI ƯU CỦA MÃ LEMPEL-ZIV ....................................................................... 162

      9.5.1 Phương pháp cửa sổ trượt ................................................................................. 162
      9.5.2 Phương pháp cấu trúc cây ................................................................................. 164

   9.5. MINH HỌA THỰC TẾ ........................................................................................... 169
Chương 10 ....................................................................................................................... 174
SUY LUẬN BAYES ........................................................................................................... 174
   11.1. GIỚI THIỆU .......................................................................................................... 174

   11.2. Học khái niệm theo tiếp cận Bayes ........................................................................ 175
Chương 11 ....................................................................................................................... 198
ENTROPY CỰC ĐẠI ........................................................................................................ 198
   11.1. HỌ PHÂN PHỐI MŨ ............................................................................................ 198
   11.2. HÀM PHÂN LỚP ENTROPY CỰC ĐẠI ................................................................ 202
Tài liệu tham khảo ............................................................................................................ 210

PHỤ LỤC 1. Thuật ngữ Anh-Việt ..................................................................................... 211

PHỤ LỤC 2. Lời giải một số bài tập chọn lọc .................................................................... 214




                                                                                                                                     4
Chương 1
GIỚI THIỆU


1.1. VAI TRÒ CỦA LÝ THUYẾT THÔNG TIN

     Lý thuyết thông tin (LTTT) trả lời hai câu hỏi cơ bản trong truyền thông: Giới
hạn của nén dữ liệu là gì (trả lời: entropy H) và giới hạn của truyền dữ liệu là gì (trả
lời: dung lượng kênh C). Vì lý do này mà có quan điểm coi lý thuyết thông tin là một
phần của lý thuyết truyền thông. Tuy nhiên, quá trình phát triển hơn 60 năm qua1
cho thấy lĩnh vực nghiên cứu này rộng hơn thế nhiều. Cụ thể hơn, lý thuyết thông
tin có những đóng góp cơ bản cho vật lý học thống kê, khoa học máy tính, xác suất
thống kê, v.v. Hình 1.2 mô tả mối quan hệ giữa lý thuyết thông tin với các lĩnh vực
khác. Trong phần dưới đây chúng ta sẽ tìm hiểu mối quan hệ này một cách chi tiết
hơn.




                       Hình 1.1 Shannon, 1916-2001, cha đẻ của lý thuyết thông tin

     Giáo trình này xoay quanh các vấn đề cơ bản liên quan đến thông tin như biểu
diễn (mã hóa) thông tin, truyền thông tin, suy diễn. Khái niệm lượng thông tin
(entropy) chính là chìa khóa trong việc tìm ra lời giải của các bài toán đó. Trong từng
bài toán cụ thể, lượng thông tin sẽ mang một ý nghĩa khác nhau. Trong bài toán thứ
nhất, lượng thông tin cho biết giới hạn dưới của nén dữ liệu. Với bài toán thứ hai,
lượng thông tin chung cho biết giới hạn trên của truyền dữ liệu. Hay trong trò chơi
cá cược đua ngựa, một ví dụ của bài toán thứ ba, lượng thông tin chung cho biết giá
trị của thông tin bên lề cuộc đua.




1   Tính từ thời điểm bài báo đột phá của Shannon năm 1948.

                                                                                      5
            Hình 1.2. Quan hệ của lý thuyết thông tin với các lĩnh vực nghiên cứu khác


1.1.1. Kỹ thuật điện tử
    Vào đầu thập niên 40 của thế kỷ trước người ta cho rằng không thể truyền tin
qua kênh nhiễu mà không có lỗi. Shannon đã làm giới nghiên cứu lý thuyết truyền
thông phải kinh ngạc khi chứng minh rằng xác suất lỗi có thể nhỏ tùy ý khi tốc độ
truyền không vượt quá dung lượng kênh. Dung lượng này có thể được tính chỉ đơn
giản dựa vào đặc điểm nhiễu của kênh truyền. Shannon sau đó biện luận xa hơn
rằng các quá trình ngẫu nhiên như âm nhạc hay tiếng nói có một độ phức tạp mà tín
hiệu của chúng không thể được nén nhỏ hơn. Ông đặt tên cho đại lượng này là
entropy, một thuật ngữ đã được sử dụng trong nhiệt động lực học.
    Lý thuyết thông tin cũng gợi ý cách đạt được các giới hạn truyền thông. Tuy
nhiên, những lược đồ truyền thông tối ưu về mặt lý thuyết này tuy rất đẹp, lại
không khả thi về mặt tính toán. Trong thực tế người ta hay dùng các mô hình điều
chế và giải điều chế đơn giản vì chúng khả thi về tính toán thay vì mã hóa ngẫu
nhiên và luật giải mã láng giềng gần nhất mà Shannon đưa ra để chứng minh định
lý dung lượng kênh. Các tiến bộ trong mạch tích hợp và thiết kế mã đã cho phép
chúng ta tiến gần hơn tới các giới hạn trong lý thuyết của Shannon. Sự khả thi về
tính toán cuối cùng đã đạt được nhờ phát minh ra mã turbo. Một ví dụ tốt về ứng
dụng các ý tưởng của lý thuyết thông tin là mã sửa lỗi trong đĩa CD, DVD.




                                                                                         6
1.1.2. Khoa học máy tính
     Trong những thập niên đầu tiên, lý thuyết thông tin liên quan chủ yếu tới biểu
diễn dữ liệu tiết kiệm không gian lưu trữ (mã hóa nguồn), cũng như truyền và lưu
trữ nó theo cách mà dễ hồi phục lỗi (mã hóa kênh). Có vẻ như lý thuyết thông tin có
khoảng cách khá xa với các lĩnh vực nghiên cứu khác của khoa học máy tính. Tuy
nhiên thực tế có những mối liên hệ mật thiết. Chẳng hạn trong lĩnh vực xử lý ngôn
ngữ và tiếng nói, nhờ áp dụng các mô hình của lý thuyết thông tin, tiêu biểu là mô
hình kênh nhiễu (Hình 1.3) mà kết quả nhận dạng tiếng nói đã thu được những bước
tiến đột phá. Năm 2009, tại hội nghị ACL tại Singapore, GS. Frederick Jelinek đã
được trao giải thành tựu trọn đời của Hội Ngôn ngữ học Máy tính Thế giới. GS.
Jelinek được vinh danh vì là người tiên phong trong việc ứng dụng lý thuyết thông
tin vào xử lý tiếng nói, khi ông còn đang làm việc tại IBM2, và sau đó là ngôn ngữ.
Bài báo đột phá về dịch máy thống kê dựa trên mô hình kênh nhiễu đã bị một người
phản biện từ chối nhận đăng khi lần đầu gửi công bố ở COLING năm 1988, cũng là
một hội thảo hàng đầu về xử lý ngôn ngữ. Ông là người góp công lớn vào việc
chuyển dịch từ tiếp cận dựa vào luật và logic sang tiếp cận thống kê trong xử lý
ngôn ngữ tự nhiên.




                     Figure 1.3. Nhận dạng tiếng nói dựa vào mô hình kênh nhiễu


1.1.3. Vật lý
    Cơ học thống kê là lĩnh vực đề xuất thuật ngữ entropy đầu tiên. Định luật thứ
hai của nhiệt động lực học nói rằng entropy luôn tăng. Định luật thứ hai giúp con
người loại bỏ kỳ vọng về động cơ vĩnh cửu. Trong giáo trình này ta sẽ xem xét một
số cách biểu diễn khác nhau của định luật này.

1.1.4. Toán học
    Các đại lượng cơ bản của LTTT như entropy, entropy tương đối, và thông tin
tương hỗ được định nghĩa như các hàm toán học, cụ thể là các hàm của phân phối
xác suất. Nó cũng giúp mô tả đặc điểm của các chuỗi biến ngẫu nhiên và cho phép
chúng ta ước lượng xác suất của các biến cố hiếm (lý thuyết độ lệch lớn) và tìm các
số mũ lỗi trong kiểm định giả thuyết thống kê.
2Khi còn làm việc tại IBM, ông nổi tiếng với câu nói “Mỗi khi sa thải một nhà ngôn ngữ, chất lượng hệ
nhận dạng tiếng nói lại tăng lên.”

                                                                                                    7
1.1.5. Kinh tế học
     Việc đầu tư lặp lại trong một thị trường chứng khoán dừng sẽ mang lại sự tăng
trưởng tài sản theo hàm mũ. Tốc độ tăng trưởng tài sản là một đối ngẫu của entropy
của thị trường chứng khoán. Lý thuyết đầu tư được phát triển để khám phá sự đối
ngẫu này. Trong giáo trình này ta sẽ xem xét một trường hợp đặc biệt của đầu tư vào
thị trường chứng khoán, đó là trò chơi cá cược đua ngựa.


1.2. CẤU TRÚC CỦA GIÁO TRÌNH

    Chương 2: nhắc lại các kiến thức cơ bản về lý thuyết xác suất như không gian
xác suất, sự độc lập xác suất, công thức Bayes, biến ngẫu nhiên, hàm phân phối, v.v.
     Chương 3: trình bày các khái niệm cơ bản của lý thuyết thông tin như entropy,
entropy tương đối, thông tin tương hỗ. Các tính chất của các đại lượng này cũng
được nêu ra và chứng minh. Bên cạnh đó một số bất đẳng thức quan trọng cũng
được trình bày. Các khái niệm và công cụ này sẽ được sử dụng thường xuyên trong
các chương sau.
   Chương 4: nội dung chính của chương này là tính chất tiệm cận phân hoạch đều
(AEP) và liên hệ của nó với nén dữ liệu.
    Chương 5: trình bày về entropy của quá trình ngẫu nhiên, trong đó trọng tâm là
quá trình Markov dừng.
    Chương 6: trình bày các khái niệm và tính chất cơ bản của mã hoá nguồn (nén
dữ liệu) trong đó điểm nhấn là định lý cho biết cận dưới của nén dữ liệu là entropy.
Mã Huffman và tính chất tối ưu của nó là một phần quan trọng của chương. Bên
cạnh đó mã Shannon-Fano-Elias cũng được giới thiệu làm tiền đề cho phương pháp
mã hóa số học được trình bày trong chương 9.
    Chương 7: trình bày mô hình truyền thông của Shannon, các khái niệm và tính
chất cơ bản của kênh truyền thông, trong đó các kết quả quan trọng là định lý mã
hoá kênh và định lý phân tách kênh-nguồn.
    Chương 8: phân tích trò chơi cá cược đua ngựa theo các quan điểm và công cụ
của lý thuyết thông tin. Các yếu tố ảnh hưởng đến trò chơi như thông tin bên lề, sự
độc lập hay phụ thuộc giữa các cuộc đua đều được phân tích để làm rõ mối liên hệ
của chúng đến chiến lược chơi.
    Chương 9: cũng là về nén dữ liệu nhưng khác chương 6 một cách cơ bản ở chỗ
các phương pháp trong chương này không cần biết trước phân phối xác suất của
nguồn. Hai thuật toán mã hoá hay được sử dụng trong thực tế là mã hoá số học và
mã hoá Lempel-Ziv được trình bày. Tính chất tối ưu tiệm cận của chúng cũng được
phân tích.
    Chương 10: chương này trình bày về một tiếp cận để giải quyết bài toán suy
diễn thống kê đó là phương pháp Bayes. Một ví dụ đơn giản gọi là trò chơi số học sẽ

                                                                                  8
được phân tích để làm rõ các khái niệm như tiên nghiệm, likelihood, hậu nghiệm.
Bên cạnh đó một số mô hình cụ thể như mô hình beta-nhị thức và mô hình Dirichlet-
đa thức cũng được xem xét.
    Chương 11: chương này trình bày về bài toán phân lớp và họ phân phối mũ,
một họ phân phối có nhiều đặc điểm hữu dụng, được sử dụng rộng rãi trong nghiên
cứu và ứng dụng. Một trong các đặc điểm quan trọng, đồng thời là chủ đề của
chương, đó là đặc điểm entropy cực đại.
    Bạn có thể đọc các chương theo thứ tự:
    -   Đọc trước tiên: chương 2, chương 3, chương 4
    -   Đọc theo thứ tự tùy ý: chương 5, chương 6 và chương 9, chương 7, chương 8,
        chương 10-11
     Ngoài các chương nêu trên, giáo trình còn có hai phụ lục: Phụ lục 1 là danh sách
thuật ngữ Anh-Việt liên quan đến nội dung được trình bày trong giáo trình. Phụ lục
2 là lời giải mẫu của một số bài tập ở mỗi chương. Phụ lục này giúp sinh viên biết
cách vận dụng kiến thức đã học để làm bài tập cũng như cách trình bày lời giải một
cách hợp lý.




                                                                                   9
Chương 2
NHẮC LẠI KIẾN THỨC CƠ BẢN VỀ XÁC SUẤT
THỐNG KÊ


                           Probability theory is nothing but common sense reduced to calculation.
                                                                                Pierre Laplace


     Như chúng ta đã biết, rất nhiều sự kiện trong cuộc sống và công việc của chúng
ta là không chắc chắn mà có yếu tố may rủi, ngẫu nhiên (Hình 2.1). Chẳng hạn như
thời tiết ngày mai là mưa hay nắng, từ kế tiếp mà cô phát thanh viên truyền hình nói
ra là gì, hoặc đội bóng mà ta ưa thích tối nay thắng, hòa, hay thua. Ta có thể dễ dàng
lấy ví dụ liên quan đến công việc, sức khỏe, hay thời tiết. Chính vì sự tồn tại khách
quan của nó mà các qui luật của sự ngẫu nhiên cần phải được nghiên cứu và đó là
nhiệm vụ của lý thuyết xác suất.




                Hình 2.1. Cuộc sống gắn liền với các yếu tố ngẫu nhiên, may rủi




     Lý thuyết xác suất, thống kê là nền tảng của lý thuyết thông tin. Cụ thể hơn, các
khái niệm cơ bản trong lý thuyết thông tin như entropy và thông tin tương hỗ được
xây dựng dựa trên cơ sở xác suất, bên cạnh đó lý thuyết xác suất cũng cung cấp các
công cụ toán học hữu hiệu cho lý thuyết thông tin. Trong cả khóa học này chúng ta
sẽ thấy mình luôn phải làm việc với biến ngẫu nhiên, hàm phân phối, giá trị trung
bình, v.v.


2.1. CÁC KHÁI NIỆM CƠ BẢN CỦA LÝ THUYẾT XÁC SUẤT

                                                                                              10
2.1.1. Các khái niệm cơ bản
    Có một số khái niệm cơ bản chúng ta cần nắm được bao gồm:
    -   Phép thử: là một thí nghiệm hay quan sát nào đó
    -   Biến cố sơ cấp: tất cả các kết quả có thể có của thí nghiệm
    -   Không gian mẫu, thường ký hiệu là Ω: tập các biến cố sơ cấp
    -   Biến cố: một tập con của không gian mẫu
    Các ví dụ:
   - Gieo một đồng xu, biến cố sơ cấp sẽ là sự xuất hiện của mặt sấp hay mặt
ngửa, không gian mẫu là Ω={H, T} (Hình 2.2).




                 Hình 1.2. Mặt ngửa (H - head) và mặt sấp (T - tail) của một đồng xu

    - Gieo một đồng xu hai lần, không gian mẫu là Ω={TT, TH, HT, HH}
    - Gieo một con xúc xắc, biến cố sơ cấp sẽ là sự xuất hiện một trong sáu mặt của
nó, không gian mẫu sẽ lớn hơn các ví dụ trên Ω={1, 2, …, 6} (Hình 2.3).




                              Hình 2.3. Sáu mặt của một con xúc xắc

    Cái hay của việc sử dụng biến cố thay vì biến cố sơ cấp là chúng ta có thể kết
hợp các biến cố để tạo thành biến cố khác sử dụng các phép toán tập hợp:
    - Số biến cố là 2n (giả sử số phần tử của Ω là n)
    - Ω được gọi là biến cố chắc chắn, ᴓ được gọi là biến cố không
    - Biến cố 𝐴 ∪ 𝐵 = {𝑤: 𝑤 ∈ 𝐴 hoặc 𝑤 ∈ 𝐵} được gọi là hợp của A và B
    - Biến cố 𝐴 ∩ 𝐵 = {𝑤: 𝑤 ∈ 𝐴 và 𝑤 ∈ 𝐵} được gọi là giao của A và B. Biến cố này
còn được ký hiệu là AB
    - Biến cố 𝐴\𝐵 = {𝑤: 𝑤 ∈ 𝐴 và 𝑤 ∉ 𝐵} được gọi là hiệu của A và B
    - Biến cố 𝐴̅ = {𝑤: 𝑤 ∉ 𝐴 } được gọi là biến cố đối của A
    Theo ngôn ngữ xác suất, các biến cố trên có nghĩa là:
    - 𝐴 ∪ 𝐵 xảy ra  hoặc A hoặc B xảy ra
    - 𝐴 ∩ 𝐵 xảy ra  cả A và B cùng xảy ra

                                                                                       11
    - 𝐴\𝐵 xảy ra  A xảy ra và B không xảy ra
    - 𝐴̅ xảy ra  A không xảy ra
     Sau đây ta xét một số ví dụ về biến cố liên quan đến thí nghiệm gieo hai con xúc
xắc. Không gian mẫu của thí nghiệm này được thể hiện trong Hình 2.4.




                 Hình 2.4. Không gian mẫu của thí nghiệm gieo hai con xúc xắc




    Mô tả biến cố                   Tập các biến cố sơ cấp tương ứng
    A: tổng số chấm bằng 3          {(1, 2), (2, 1)}
    B: tổng số chấm bằng 6          {(1, 5), (2, 4), (3, 3), (4, 2), (5, 1)}
    C: xúc xắc trắng là 1           {(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6)}
    D: xúc xắc đen là 1             {(1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1)}
    Biến cố 𝐶 ∪ 𝐷 và 𝐶 ∩ 𝐷 được minh họa trong Hình 2.5. Trong đó 𝐶 ∪ 𝐷 là phần
được tô đen bao gồm hàng cuối cùng và cột cuối cùng, còn 𝐶 ∩ 𝐷 là phần tử ở góc
phải dưới.




                                                                                       12
                       Hình2.5. Biến cố Biến cố 𝐂 ∪ 𝐃 và biến cố 𝐂 ∩ 𝐃


2.1.2. Xác suất
    a) Xác suất của biến cố
    Giả sử 𝐴 là biến cố của phép thử nào đó:
     - 𝑃(𝐴), tồn tại khách quan, đo khả năng xuất hiện của 𝐴
     Số này bằng 1 nếu 𝐴 là biến cố chắc chắn, bằng 0 nếu 𝐴 là biến cố không, nếu
𝐴, 𝐵 là hai biến cố xung khắc thì 𝑃(𝐴 ∪ 𝐵) = 𝑃(𝐴) + 𝑃(𝐵)
     - Giả sử Ω = {𝑤 , 𝑤 , … , 𝑤 , … }, mỗi biến cố sơ cấp được gắn với một “trọng số”
𝑝 = 𝑝 (𝑤 ) sao cho:
                                  𝑝 ≥ 0 với mọi 𝑘 ≥ 1
                                            𝑝 =1

    - Khi đó:

                                   𝑃(𝐴) =                𝑝
                                             { :   ∈ }

    b) Định nghĩa cổ điển của xác suất
    Giả sử Ω = {𝑤 , … , 𝑤 } là không gian mẫu mà các kết quả có cùng khả năng
xuất hiện, nghĩa là: 𝑃(𝑤 ) = 1/𝑁 với mọi 𝑖. Khi đó theo công thức tổng quát nêu
trên, xác suất của biến cố A là:
                                              |𝐴| 𝑛
                                    𝑃(𝐴) =       =
                                              |Ω| 𝑁




                                                                                   13
     Định nghĩa này cho ta một mô hình toán rất tốt với các hiện tượng ngẫu nhiên
liên quan đến phép thử có tính đối xứng và đo đó các kết quả của nó được coi là có
cùng khả năng xuất hiện.
    c) Một số tính chất
                           𝑃(ᴓ) = 0, 𝑃(Ω) = 1, 0 ≤ 𝑃(𝐴) ≤ 1
                           𝑃(𝐴 ∪ 𝐵) = 𝑃(𝐴) + 𝑃(𝐵) − 𝑃(𝐴𝐵)
    Nếu A và B là các biến cố xung khắc thì 𝑃(𝐴 ∪ 𝐵) = 𝑃(𝐴) + 𝑃(𝐵)
                                     𝑃(𝐴̅) = 1 − 𝑃(𝐴)
    d) Ví dụ
     Một cái hộp N quả cầu được đánh số bởi các số của tập hợp các số tự nhiên từ 1
đến N. Rút lần lượt từng quả n lần, sao cho mỗi lần rút một quả, quả đó được hoàn
trả lại hộp rồi mới rút lần tiếp theo. Hãy tính xác suất của biến cố:
               A = {các quả đã được rút là đôi một khác nhau}
    Không gian mẫu: Ω = {𝑤 = (𝑎 , … , 𝑎 ): 1 ≤ 𝑎 ≤ 𝑁} với |Ω| = 𝑁
                          |𝐴| = 𝐴 = 𝑁(𝑁 − 1) … (𝑁 − 𝑛 + 1)
    Do đó:
                                   |𝐴| 𝑁(𝑁 − 1) … (𝑁 − 𝑛 + 1)
                          𝑃(𝐴) =       =
                                   |Ω|          𝑁


2.2. XÁC SUẤT CÓ ĐIỀU KIỆN

2.2.1. Xác suất có điều kiện




                           Hình 2.6. Minh họa xác suất có điều kiện




                                                                                14
                               Hình 2.7. Không gian mẫu thu gọn

Ta lại xét thí nghiệm gieo hai con xúc xắc. Gọi A là biến cố tổng số chấm bằng 3, C là
biến cố xúc xắc trắng là 1. Ta dễ tính được xác suất của A là 𝑃(𝐴) = 2/36. Bây giờ
giả sử biến cố C đã xảy ra (Hình 2.6), khi đó xác suất của A là bao nhiêu?

Ta ký hiệu P(A|C) là xác suất của biến cố A với điều kiện biến cố C. 𝑃(𝐴|𝐶) được gọi
là xác suất có điều kiện. Trước khi bất kỳ con xúc xắc nào được gieo, không gian
mẫu của ta có 36 biến cố sơ cấp, nhưng khi C đã xảy ra, biến cố sơ cấp phải thuộc về
không gian mẫu thu gọn, bao gồm chỉ 6 biến cố sơ cấp (Hình 2.7). Trong không gian
thu gọn này, chỉ có (1,2) có tổng bằng 3, vậy xác suất có điều kiện cần tính là 1/6.

    Xác suất có điều kiện của biến cố A với điều kiện B là một số xác định theo công
thức:
                                          𝑃(𝐴𝐵)
                              𝑃(𝐴|𝐵) =          nếu P(B)>0
                                          𝑃(𝐵)
    Công thức nhân xác suất:
                 𝑃(𝐴𝐵) = 𝑃(𝐵)𝑃(𝐴|𝐵) = 𝑃(𝐴)𝑃(𝐵|𝐴) nếu P(A)P(B)≠0
    Bằng qui nạp, bạn dễ dàng suy ra công thức nhân tổng quát.
    Ví dụ 1: Gieo một con xúc xắc cân đối và đồng chất hai lần. A là biến cố “lần đầu
gieo xuất hiện mặt 1 chấm”, B là biến cố “tổng số chấm trong hai lần gieo không
vượt quá 3”. Tính 𝑃(𝐴|𝐵).
    Ta thấy Ω = {(𝑖, 𝑗): 1 ≤ 𝑖, 𝑗 ≤ 6}
                    𝐴 = {(1, 1), … , (1, 6)}, 𝐵 = {(1, 1), (1, 2), (2, 1)}
                     𝑃(𝐴) = 6/36; 𝑃(𝐵) = 3/36; 𝑃(𝐴𝐵) = 2/36
    Nếu biết rằng B đã xảy ra thì A xảy ra khi một trong hai kết quả (1, 1) và (1, 2)
xảy ra. Do đó:
                                                 2
                                             2 36
                                     𝑃(𝐴|𝐵) = =
                                             3   3
                                                36




                                                                                       15
    Ví dụ 2: Từ một hộp chứa a quả cầu trắng và b quả cầu đen, người ta rút ngẫu
nhiên không hoàn lại từng quả một hai lần. Tính xác suất để lần thứ hai mới rút
được quả cầu trắng.
   Ký hiệu Ak là biến cố “lần thứ k rút được quả trắng”, k = 1, 2, … Theo công thức
nhân xác suất ta có xác suất cần tìm là:
                                                    𝑏    𝑎
                    𝑃(𝐴̅ 𝐴 ) = 𝑃(𝐴̅ )𝑃(𝐴 |𝐴̅ ) =      ×
                                                   𝑎+𝑏 𝑎+𝑏−1

2.2.2. Công thức Bayes
                                      𝑃(𝐵𝐴) 𝑃(𝐴|𝐵)𝑃(𝐵)
                           𝑃(𝐵|𝐴) =        =
                                      𝑃(𝐴)     𝑃(𝐴)
    Giả sử 𝑃(𝐴) > 0 và {B1, B2, …, Bn} là hệ đầy đủ các biến cố với 𝑃(𝐵 ) >
0 với mọi i. Khi đó ta có:
                                𝑃(𝐵 )𝑃(𝐴|𝐵 )    𝑃(𝐵 )𝑃(𝐴|𝐵 )
                    𝑃(𝐵 |𝐴) =                =
                                    𝑃(𝐴)       ∑ 𝑃(𝐵 )𝑃(𝐴|𝐵 )




                             Hình 2.8 Thomas Bayes, 1701-1761




    Ví dụ 1: Từ một hộp chứa a quả cầu trắng và b quả cầu đen, người ta rút ngẫu
nhiên không hoàn lại từng quả một hai lần. Hãy tính xác suất để lần đầu rút được
quả trắng biết rằng lần thứ hai cũng rút được quả trắng.
    Ký hiệu Ak là biến cố “lần thứ k rút được quả trắng”, k = 1, 2, …
    Theo đề bài ta cần tính P(A1|A2). Theo công thức Bayes ta có:
                                           𝑃(𝐴 |𝐴 )𝑃(𝐴 )
                             𝑃(𝐴 |𝐴 ) =
                                               𝑃(𝐴 )
     Ở lần rút thứ hai, có a+b-1 khả năng rút, và nếu A1 đã xảy ra thì số quả cầu trắng
chỉ còn a-1, do đó
                                               𝑎−1
                                 𝑃(𝐴 |𝐴 ) =
                                              𝑎+𝑏−1




                                                                                    16
    Tổng số khả năng rút cặp quả cầu (cũng là kích thước của không gian mẫu) sẽ là
chỉnh hợp chập 2 của a+b tức là (a+b)(a+b-1). Ta ký hiệu các biến cố như sau:
    BW: quả đầu tiên là đen, quả thứ hai là trắng, |BW| = ba
    BB: quả đầu tiên là đen, quả thứ hai cũng là đen, |BB| = b(b-1)
    WB: quả đầu tiên là trắng, quả thứ hai là đen, |WB| = ab
    WW: quả đầu tiên là trắng, quả thứ hai cũng là trắng, |BB| = a(a-1)
    Với qui ước như trên thì A1 là hợp của WB và WW do đó:
                                     𝑎𝑏 + 𝑎(𝑎 − 1)      𝑎
                         𝑃(𝐴 ) =                     =
                                   (𝑎 + 𝑏)(𝑎 + 𝑏 − 1) 𝑎 + 𝑏
    Còn A2 là hợp của BW và WW, do đó:
                                     𝑏𝑎 + 𝑎(𝑎 − 1)      𝑎
                         𝑃(𝐴 ) =                     =
                                   (𝑎 + 𝑏)(𝑎 + 𝑏 − 1) 𝑎 + 𝑏
    Thay vào công thức Bayes ta có
                                    𝑃(𝐴 |𝐴 )𝑃(𝐴 )    𝑎−1
                       𝑃(𝐴 |𝐴 ) =                 =
                                        𝑃(𝐴 )       𝑎+𝑏−1


     Ví dụ 2: Xét một ví dụ về xét nghiệm y học. Giả sử bạn là một phụ nữ ở tuổi 40
và bạn quyết định đến bệnh viện để làm xét nghiệm y học xem có bị ung thư vú hay
không, xét nghiệm này gọi là mammogram. Nếu kết quả xét nghiệm là dương tính,
liệu xác suất bị ung thư của bạn là bao nhiêu? Tất nhiên, độ tin cậy của xét nghiệm
này là hết sức quan trọng. Giả sử bác sĩ nói với bạn là độ nhạy của xét nghiệm là
80%, nghĩa là nếu bạn bị ung thư, kết quả xét nghiệm sẽ là dương tính với xác suất
80%. Nói cách khác:
    P(A|B) = 0.8, trong đó A là biến cố kết quả xét nghiệm dương tính, B là biến cố
bạn bị ung thư.
    Vậy liệu hình huống có bi quan quá không, tức là khả năng bạn bị ung thư là
80%? Ở đây có một yếu tố chưa tính đến đó là xác suất tiên nghiệm, may mắn là nó
khá nhỏ
    P(B) = 0.004, tức là khả năng một người bị ung thư là 4 phần nghìn.
    Còn một yếu tố nữa trước khi ta có thể tính được xác suất ung thư trong cụ thể
trương hợp này, đó là xác suất báo sai (người không bị ung thư nhưng kết quả xét
nghiệm vẫn là dương tính):
                                     𝑃(𝐴|𝐵) = 0.1
    Có thể thấy xác suất này là khá cao, do hạn chế của công nghệ quét (screening)
hiện nay.
    Áp dụng công thức Bayes ta có:

                                                                                17
                       𝑃(𝐴|𝐵)𝑃(𝐵)         𝑃(𝐴|𝐵)𝑃(𝐵)
            𝑃(𝐵|𝐴) =              =                          = 0.031
                          𝑃(𝐴)      𝑃(𝐵)𝑃(𝐴|𝐵) + 𝑃(𝐵)𝑃(𝐴|𝐵 )
    Như vậy, xác suất để bạn bị ung thư chỉ là 3.1%.

2.2.3. Sự độc lập của hai biến cố




                           Hình 2.9. Minh họa biến cố phụ thuộc




     Hai biến cố A và B được gọi là độc lập với nhau nếu sự xuất hiện của biến cố
này không ảnh hưởng đến xác suất của biến cố kia. Ví dụ, khi gieo hai con xúc xắc
thì con này lăn thế nào không ảnh hưởng đến con còn lại, trừ khi chúng được nối với
nhau như ở Hình 2.9.
                                    𝑃(𝐴𝐵) = 𝑃(𝐴)𝑃(𝐵)
    Nếu 𝑃(𝐵) > 0 thì dễ thấy A và B độc lập khi và chỉ khi
                                     𝑃(𝐴|𝐵) = 𝑃(𝐴)


2.3. BIẾN NGẪU NHIÊN

2.3.1. Khái niệm biến ngẫu nhiên
    Từ đầu chương đến giờ ta đã làm quen với các khái niệm như thí nghiệm, biến
cố sơ cấp, không gian mẫu, v.v. Bản thân biến cố sơ cấp và biến cố đều có xác suất
của nó. Qua các khái niệm cơ bản đó ta cũng đã có được một mô hình để áp dụng
xác suất vào thực tế hay liên hệ giữa xác suất với thực tế. Tuy nhiên, người ta muốn
hình thức hóa hơn nữa về các khái niệm này bằng cách sử dụng các con số thay vì
biến cố, chính vì vậy khái niệm biến ngẫu nhiên ra đời. Biến ngẫu nhiên là hàm
𝑋: Ω → 𝑅 (thường 𝑛 = 1). Hàm phân phối xác suất (probability mass function –
pmf) của biến ngẫu nhiên có dạng:
                             𝑝(𝑥) = 𝑃(𝑋 = 𝑥) = 𝑃(𝐴 )
    trong đó 𝐴 = {𝑤 ∈ Ω: 𝑋(𝑤) = 𝑥}.
    Với biến ngẫu nhiên rời rạc ta có:

                                                                                 18
                              𝑝(𝑥 ) =      𝑃 𝐴      = 𝑃(Ω) = 1

    Chú ý về mặt ký hiệu thì x biểu diễn một giá trị còn X biểu diễn biến ngẫu
nhiên. Nếu liên hệ với khái niệm biến số ta đã học trong giải tích thì biến ngẫu nhiên
khác ở chỗ nó nhận các giá trị khác nhau với xác suất khác nhau qui định bởi hàm
mật độ xác suất hay hàm phân phối.

2.3.2. Kỳ vọng và phương sai của biến ngẫu nhiên
    Kỳ vọng là giá trị trung bình của biến ngẫu nhiên. Giả sử X là biến ngẫu nhiên
với phân phối xác suất là p(x) mà ∑ |𝑥|𝑝(𝑥) < ∞ thì kỳ vọng là:

                                    𝐸(𝑋) =        𝑥𝑝(𝑥)

    Phương sai của biến ngẫu nhiên là một số không âm dùng để đo mức độ phân
tán (tản mát) của các giá trị của biến ngẫu nhiên xung quanh giá trị trung bình của
nó.

                    𝑉𝑎𝑟(𝑋) = 𝐸      𝑋 − 𝐸(𝑋)        = 𝐸(𝑋 − 𝐸 (𝑋))

    Ví dụ: Gieo một con xúc xắc và giả sử Y là giá trị thu được, khi đó:
                                              1     21     1
                     𝐸(𝑌) =         𝑦𝑝(𝑦) =            =3 𝑦=
                                              6      6     2
                                               91 49 35
                      𝑉𝑎𝑟(𝑌) = 𝐸(𝑌 ) − 𝐸 (𝑌) =    −    =
                                                6   4    12
                                                   (      )(   )
    Chú ý: Khi tính 𝐸(𝑌 ) cần dùng ∑       𝑖 =

2.3.3. Phân phối có điều kiện và phân phối phụ thuộc
    Hàm phân phối phụ thuộc cho hai biến ngẫu nhiên rời rạc X, Y là:
                            𝑝(𝑥, 𝑦) = 𝑃(𝑋 = 𝑥, 𝑌 = 𝑦)
    Hàm này thể hiện quan hệ (ngẫu nhiên) giữa X và Y. Biết phân phối phụ thuộc
ta có thể tính được phân phối của X và phân phối của Y chính là phân phối biên
duyên của p(x,y):

                                  𝑝(𝑥) =         𝑝(𝑥, 𝑦)


                                  𝑝(𝑦) =         𝑝(𝑥, 𝑦)

    Hàm phân phối có điều kiện:
                                    𝑝(𝑥, 𝑦)
                         𝑝(𝑥|𝑦) =           với y mà 𝑝(𝑦) > 0
                                     𝑝(𝑦)


                                                                                   19
    Công thức nhân xác suất:
                                𝑝(𝑥, 𝑦, 𝑧) = 𝑝(𝑥)𝑝(𝑦|𝑥)𝑝(𝑧|𝑥, 𝑦)
    Công thức này có thể được khái quát cho n biến.
    Nếu X và Y là các biến ngẫu nhiên độc lập:
                                          𝑝(𝑥, 𝑦) = 𝑝(𝑥)𝑝(𝑦)




                               Hình 2.10. Biểu diễn phân phối phụ thuộc

    Giả sử 𝑥 ∈ 𝒳, |𝒳| = 6 và 𝑦 ∈ 𝒴, |𝒴| = 5. Hình 2.10 ở trên minh họa là khi hai
biến ngẫu nhiên không độc lập, ta cần một bảng với 6x5=30 tham số để định nghĩa
phân phối phụ thuộc của X và Y. Tuy nhiên trong trường hợp độc lập, số tham số ít
hơn hẳn, chỉ cần 6+5 = 11 tham số.


2.4. MỘT SỐ PHÂN PHỐI CHUẨN

    Đã có nhiều phân phối chuẩn (standard distribution) được các nhà thống kê học
nghiên cứu. Mỗi phân phối phù hợp với một loại phép thử khác nhau. Trong phần
này chúng ta sẽ tìm hiểu nhanh một số phân phối chuẩn bao gồm phân phối nhị
thức, phân phối đa thức, phân phối thực nghiệm, phân phối Gauss, phân phối beta,
và phân phối Dirichlet.

2.4.1. Phân phối nhị thức
    Giả sử ta gieo một đồng xu n lần. Đồng xu có xác suất xuất hiện mặt ngửa là 𝜃.
Giả sử 𝑋 ∈ {0,1, … , 𝑛} là số lần xuất hiện mặt ngửa. Khi đó ta nói X có phân phối nhị
thức và viết là 𝑋~𝐵𝑖𝑛(𝑛, 𝜃). Hàm phân phối xác suất là:
                                             𝑛
                              𝐵𝑖𝑛(𝑘|𝑛, 𝜃) =    𝜃 (1 − 𝜃)
                                             𝑘
                           !
    Trong đó      =   !(       )!
                                    là tổ hợp chập k của n.


                                                                                   20
    Phân phối này có giá trị trung bình là 𝜃 và phương sai là 𝑛𝜃(1 − 𝜃).
    Trong trường hợp số lần gieo bằng 1, 𝑋 ∈ {0,1} là một biến ngẫu nhiên nhị phân.
Ta nói X có phân phối Bernoulli và viết 𝑋~𝐵𝑒𝑟(𝜃), trong đó:
                                           (     )
                           𝐵𝑒𝑟(𝑥|𝜃) = 𝜃              (1 − 𝜃) (   )


    Nói cách khác:

                            𝐵𝑒𝑟(𝑥|𝜃) =       𝜃 𝑛ế𝑢 𝑥 = 1
                                           1 − 𝜃 𝑛ế𝑢 𝑥 = 0
    Ví dụ về hai đường cong thuộc họ này, 𝐵𝑖𝑛(𝑘|10, 0.25) và 𝐵𝑖𝑛(𝑘; 10, 0.9) được
thể hiện trong Hình 2.11. Hai đường cong này có cùng số phép thử (gieo đồng xu
chẳng hạn) là 10, tuy nhiên khác nhau về xác suất thành công (xuất hiện mặt ngửa)
của phép thử. Đường cong với 𝜃 = 0.25 có k phân bố xung quanh 2 vì xác suất thành
công thấp, trong khi đường cong với 𝜃 = 0.9 có k phân phối xung quanh 9 vì xác
suất thành công cao hơn. Phân phối nhị thức được dùng nhiều trong nghiên cứu, ví
dụ cho các mô hình n-gram, kiểm định giả thuyết thống kê, v.v. Tổng quát hóa của
phân phối nhị thức là phân phối đa thức.




                              Hình 2.11. Phân phối nhị thức




2.4.2. Phân phối đa thức
Phân phối nhị thức có thể được dùng để mô hình hóa kết quả của thí nghiệm gieo
đồng xu. Với thí nghiệm gieo con xúc xắc K mặt, ta có thể sử dụng phân phối đa
thức. Phân phối này được định nghĩa như sau: giả sử x là một vector ngẫu nhiên
trong đó 𝑥 là số lần mặt j xuất hiện. Khi đó x có hàm phân phối sau:

                                                 𝑛
                            𝑀𝑢(𝑥|𝑛, 𝜃) =                     𝜃
                                               𝑥 …𝑥

Trong đó 𝜃 là xác suất xuất hiện mặt 𝑗 và

                                                                                21
                                     𝑛             𝑛!
                                            =
                                   𝑥 …𝑥         𝑥 !…𝑥 !

Là hệ số đa thức, số cách để chia một tập n phần tử ra các tập con với các kích thước
𝑥 tới 𝑥 .

Bây giờ giả sử 𝑛 = 1, tức là chỉ gieo con xúc xắc 1 lần, do đó x là vector bit mà chỉ có
một thành phần nhận giá trị 1. Cụ thể hơn, nếu con xúc xắc xuất hiện mặt k thì chì
bit thứ k là bật. Khi đó hàm phân phối sẽ có dạng:

                                                      (    )
                                𝑀𝑢(𝑥|1, 𝜃) =      𝜃


Phân phối đa thức trong trường hợp đặc biệt này được gọi là phân phối rời rạc hay
phân phối multinoulli.

                                 𝐶𝑎𝑡(𝑥|𝜃) = 𝑀𝑢(𝑥|1, 𝜃)

Nói cách khác, nếu 𝑥~𝐶𝑎𝑡(𝜃) thì 𝑝(𝑥 = 𝑗|𝜃) = 𝜃 .

2.4.3. Phân phối Poisson
   Ta nói rằng biến ngẫu nhiên 𝑋 ∈ {0, 1, 2, … } có phân phối Poisson với tham số
𝜆 > 0 nếu hàm phân phối của nó có dạng
                                                      𝜆
                                  𝑃𝑜𝑖(𝑥|𝜆) = 𝑒
                                                      𝑥!
    Trong hàm trên, 𝑒 chỉ là một hằng chuẩn hóa để đảm bảo rằng phân phối có
tổng bằng 1. Phân phối Poisson thường được sử dụng để mô hình hóa các biến cố
hiếm như tai nạn giao thông và dòng vào một hệ dịch vụ. Hình 2.12 minh họa một
số phân phối thuộc họ này.




                               Hình 2.12 Phân phối Poisson




                                                                                     22
2.4.4. Phân phối thực nghiệm
Cho tập dữ liệu 𝐷 = {𝑥 , … , 𝑥 }, phân phối thực nghiệm hay còn gọi là độ đo thực
nghiệm được định nghĩa như sau:

                                              1
                                𝑝     (𝐴) =             𝛿 (𝐴)
                                              𝑁

Trong đó 𝛿 (𝐴) là độ đo Dirac

                                 𝛿 (𝐴) = 0 𝑛ế𝑢 𝑥 ∉ 𝐴
                                         1 𝑛ế𝑢 𝑥 ∈ 𝐴

Tổng quát hơn, mỗi ví dụ có thể được gán một trọng số và khi đó


                                    𝑝(𝑥) =        𝑤 𝛿 (𝑥)


Trong đó 0 ≤ 𝑤 ≤ 1 và ∑        𝑤 = 1. Ta có thể hình dung phân phối này như một
biểu đồ dạng cột trong đó các cột được đặt tại các điểm 𝑥 và 𝑤 xác định độ cao của
cột i. Phân phối này gán xác suất bằng 0 cho các điểm không nằm trong tập dữ liệu.

2.4.5. Phân phối chuẩn
   Đây là hàm phân phối được sử dụng phổ biến nhất trong thống kê, học máy, …
hàm mật độ xác suất được định nghĩa như sau:
                                              1         (   ) /(   )
                          𝒩(𝑥; 𝜇, 𝜎 ) =             𝑒
                                             √2𝜋𝜎
    Trong đó 𝜇 là giá trị trung bình và 𝜎 là độ lệch chuẩn (𝜎 là phương sai). √2𝜋𝜎
là hằng chuẩn hóa cần để đảm bảo tích phân của hàm mật độ bằng 1. Tên khác của
phân phối này là Gaussian, tức phân phối Gauss.




                         Hình 2.13 Carl Friederich Gauss, 1777-1855



                                                                                    23
     Ta viết 𝑋~𝒩(𝜇, 𝜎 ) để mô tả rằng 𝑃(𝑋 = 𝑥) = 𝒩(𝑥|𝜇, 𝜎 ). Nếu 𝑋~𝒩(0,1) ta nói
rằng X tuân theo phân phối chuẩn tiêu chuẩn (standard normal distribution). Hình
2.14 biểu diễn hàm mật độ này (còn gọi là đường cong hình chuông).




                                  Hình 2.14. Phân phối chuẩn




     Phân phối chuẩn ứng dụng tốt trong mô hình hóa chiều cao hay chỉ số IQ của
người, các mô hình học máy, thống kê, v.v. Trong thống kê, nhiều khi phân phối nhị
thức (rời rạc) được xấp xỉ bằng phân phối chuẩn (liên tục) – bạn hãy để ý sự tương
tự của các đường cong trong hai hình ví dụ. Phân phối này hay được sử dụng vì một
số lý do :
   -     Thứ nhất, hai tham số của phân phối chuẩn thể hiện các đặc điểm cơ bản nhất
         của một phân phối.
   -     Thứ hai, định lý giới hạn trung tâm trong lý thuyết xác suất nói là tổng của
         các biến ngẫu nhiên độc lập là xấp xỉ phân phối Gauss.
   -     Thứ ba, phân phối Gauss là phân phối thuộc họ mũ, tức là có entropy cực đại.
         Đặc điểm này ta sẽ bàn kỹ hơn ở Chương 11 của giáo trình.
   -     Thứ tư, dạng toán học của phân phối Gauss là đơn giản, dễ sử dụng.

2.4.6. Phân phối beta
       Beta là phân phối trên đoạn [0,1] và được định nghĩa như sau:
                                             1
                          𝐵𝑒𝑡𝑎(𝑥|𝑎, 𝑏) =           𝑥    (1 − 𝑥)
                                           𝐵(𝑎, 𝑏)
        Trong đó B là hàm Beta.
                                                Γ(𝑎)Γ(𝑏)
                                    𝐵(𝑎, 𝑏) =
                                                Γ(𝑎 + 𝑏)



                                                                                  24
                                 Hình 2.15 Phân phối beta




     Hình 2.15 thể hiện một số phân phối Beta. Chú ý là 𝑎, 𝑏 > 0 để đảm bảo tồn tại
𝐵(𝑎, 𝑏). Nếu 𝑎 = 𝑏 = 1 ta có phân phối đều (đường song song với trục hoành). Nếu
𝑎, 𝑏 < 1 ta có hàm phân phối với hai giá trị xác suất cao nhất (đường cong liền nét).
Nếu 𝑎, 𝑏 > 1, phân phối chỉ có một điểm xác suất cao nhất.
   Các giá trị đặc trưng trung bình, mode, phương sai của phân phối beta lần lượt
như sau:
                            𝑎     𝑎−1             𝑎𝑏
                               ;         ;
                          𝑎 + 𝑏 𝑎 + 𝑏 − 2 (𝑎 + 𝑏) (𝑎 + 𝑏 + 1)

2.4.7. Phân phối Dirichlet
    Tổng quát hóa của phân phối beta là phân phối Dirichlet, một phân phối trên
đơn hình xác suất:

                              𝑆 = {𝑥: 0 ≤ 𝑥 ≤ 1,            𝑥 }

    Hàm mật độ xác suất là:

                                        1
                          𝐷𝑖𝑟(𝑥|𝛼) =            𝑥      𝐼(𝑥 ∈ 𝑆 )
                                       𝐵(𝛼)

    Trong đó 𝐵(𝛼 , 𝛼 , … , 𝛼 ) là tổng quát hóa của hàm beta cho K biến:
                                           ∏     Γ(𝛼 )
                                  𝐵(𝛼) =
                                               Γ(𝛼 )
    ở đây 𝛼 = ∑     𝛼 .
    Một số tính chất của phân phối Dirichlet:

                                                                                  25
                                                                      (   )
                      𝐸[𝑋 ] =   , 𝑚𝑜𝑑𝑒[𝑋 ] =          , 𝑣𝑎𝑟[𝑋 ] =
                                                                      (   )




                (a)                                             (b)




                (c)                                             (d)
                                Hình 2.16 Phân phối Dirichlet




    Trong Hình 2.16, hình (a), phân phối Dirichlet khi 𝐾 = 3 biểu diễn bởi mặt tam
giác. Các điểm trên mặt này thỏa mãn 0 ≤ 𝜃 ≤ 1, ∑        𝜃 = 1. Hình (b) thể hiện
phân phối Dirichlet khi 𝛼 = (2,2,2). Hình (c) có tham số 𝛼 = (20,2,2). Hình (d) có
tham số 𝛼 = (0.1,0.1,0.1).


ĐỌC THÊM
     Có hai cách giải thích khác nhau về xác suất: tần suất và Bayes. Theo cách thứ
nhất, xác suất biểu diễn tần suất của biến cố. Ví dụ khi nói “xác suất mà đồng xu
ngửa là 0.5” thì nghĩa là nếu ta gieo đồng xu rất nhiều lần, ta kỳ vọng nó ngửa trong
một nửa số lần gieo. Theo cách giải thích thứ hai, xác suất được dùng để định lượng
hóa sự không chắc chắn về cái gì đó. Như vậy theo cách này xác suất liên quan tới
thông tin hơn là các phép thử lặp đi lặp lại. Theo quan điểm Bayes, câu nói trên sẽ có
nghĩa là ta tin rằng khả năng xuất hiện mặt xấp hay ngửa của đồng xu trong lần gieo
kế tiếp là như nhau.


                                                                                   26
    Một ưu thế lớn của quan điểm Bayes là nó có thể dùng để mô hình hóa sự
không chắc chắn của chúng ta về các sự kiện mà thực tế khó có thể xảy ra nhiều lần.
Ví dụ, ta có thể muốn tính xem xác suất mà băng ở hai cực tan hết vào năm 2020 là
bao nhiêu. Sự kiện này chỉ có thể xảy ra hoặc không xảy ra chứ không có sự lặp lại.
Một ví dụ khác là về dự báo email có phải spam hay không; hay khi ta thấy một vật
thể nhấp nháy trên màn hình radar, ta muốn đoán xem đích đến của vật thể đó
(chim, máy bay, hay tên lửa) có phân phối là gì. Trong những ví dụ như thế này, ý
tưởng về phép thử lặp lại không có nhiều ý nghĩa, nhưng quan điểm Bayes là hợp lý
và thực sự khá tự nhiên. Tuy nhiên điều may mắn là cho dù bạn thích quan điểm
nào, các qui luật cơ bản của xác suất là như nhau.


BÀI TẬP
Bài 2.1. Giả sử Ω = {danh từ, phó từ, tính từ, động từ}
Hàm f được mô tả như sau:
                        x                    f(x)
                        danh từ              0.45
                        phó từ               0.2
                        tính từ              0.25
                        động từ              0.3

   a) f có phải là một hàm phân phối xác suất không?
   b) Nếu không phải, hãy chuẩn hóa f để tạo ra phân phối xác suất g.

Bài 2.2. Hàm phân phối phụ thuộc p(x,y) của hai biến ngẫu nhiên X, Y được cho
trong bảng sau:

       x                  0                  0                  1                   1
       y                  0                  1                  0                   1
     p(x,y)             0.32               0.08               0.48                 0.12

X và Y có phải là hai biến ngẫu nhiên độc lập hay không? Tại sao?

Bài 2.3. Xác suất phụ thuộc vào dạng câu hỏi mà được dùng để sinh ra câu trả lời
Hàng xóm của tôi có hai con. Giả sử rằng giới tính của một đứa trẻ là kết quả của
việc gieo đồng xu. Priori ở đây là người hàng xóm này có một trai và một gái với xác
suất là 1/2. Các khả năng khác (hai trai hoặc hai gái) có xác suất 1/4 mỗi khả năng.
   a) Giả sử rằng tôi hỏi anh ta là anh có con trai không, câu trả lời là có. Xác suất
      để một người con là gái là bao nhiêu?
   b) Giả sử rằng tôi nhìn thấy một đứa trẻ chạy qua và nó là trai. Xác suất để đứa
      còn lại là gái là bao nhiêu?


                                                                                          27
Bài 2.4. Phương sai của một tổng
Chứng minh rằng phương sai của một tổng là var[X+Y] = var[X] + var[Y] + 2cov[X,Y]
trong đó cov[X,Y] là hiệp phương sai giữa X và Y.
Bài 2.5. Luật Bayes trong chuẩn đoán y học
Sau khi bạn khám sức khỏe định kỳ theo năm, bác sĩ nói với bạn một tin xấu và một
tin tốt. Tin xấu là bạn có kết quả xét nghiệm dương tính với một bệnh hiểm nghèo,
và kết quả xét nghiệm chính xác 99% (tức là nếu bạn bị bệnh thì xác suất xét nghiệm
dương tính là 0.99). Tin tốt là đây là một bệnh hiếm gặp, 10.000 người mới có một
người bị. Xác suất bị bệnh thực tế của bạn là bao nhiêu?
Bài 2.6. Bài toán Monty Hall
Trong một trò chơi truyền hình, người chơi được cho biết luật chơi như sau:
       Có ba cửa, đánh số 1, 2, 3, và có một phần quà (giải thưởng) ẩn sau một trong
       các cửa đó. Bạn phải lựa chọn một trong các cửa. Ban đầu cửa mà bạn chọn sẽ
       không mở. Thay vào đó, người dẫn chương trình sẽ mở một trong hai cửa còn
       lại, và anh ta sẽ làm vậy theo cách mà không thuận lợi cho việc khám phá phần
       thưởng. Ví dụ, nếu bạn chọn cửa 1, người dẫn chương trình sẽ mở một trong
       hai cửa 2 và 3, và chắc chắn là anh ta sẽ chọn cửa mà không bị lộ phần
       thưởng. Sau đó, bạn có quyền giữ nguyên lựa chọn của mình hoặc bạn có thể
       chọn cửa đóng còn lại. Sau đó, tất cả các cánh cửa sẽ được mở và bạn sẽ nhận
       được cái ẩn sau cánh của bạn chọn.
Tưởng tượng rằng người chơi chọn cửa số 1; sau đó người dẫn chương trình mở cửa
số 3, và như đã mô tả trong luật chơi, không có gì sau cánh cửa đó cả. Trong trường
hợp này người chơi nên chọn giải pháp nào: (a) vẫn chọn cửa số 1, hay (b) chuyển
sang cửa số 2, hay (c) chọn cửa nào cũng vậy? Bạn có thể giả sử rằng ban đầu khả
năng phần thưởng nằm sau các cửa là như nhau. Gợi ý: dùng luật Bayes.
Bài 2.7. Độc lập có điều kiện
   a) Giả sử 𝐻 ∈ {1, … , 𝐾} là một biến ngẫu nhiên, và giả sử e1 và e2 là các giá trị
      quan sát được của hai biến ngẫu nhiên E1 và E2 khác. Giả sử ta muốn tính
      vector sau:
                   𝑃⃗ (𝐻|𝑒 , 𝑒 ) = (𝑃(𝐻 = 1|𝑒 , 𝑒 ), … , 𝑃(𝐻 = 𝐾|𝑒 , 𝑒 ))
Tập số nào sau đây là đủ cho tính toán?
      i.      𝑃(𝑒 , 𝑒 ), 𝑃(𝐻), 𝑃(𝑒 |𝐻), 𝑃(𝑒 |𝐻)
      ii.     𝑃(𝑒 , 𝑒 ), 𝑃(𝐻), 𝑃(𝑒 , 𝑒 |𝐻)
      iii.    𝑃(𝑒 |𝐻), 𝑃(𝑒 |𝐻), 𝑃(𝐻)
   b) Giả sử 𝐸 ⊥ 𝐸 |𝐻 (E1 và E2 là độc lập với điều kiện H). Khi đó tập số nào ở
      trên là đủ cho tính toán của ta?
   Gợi ý: sử dụng luật Bayes


                                                                                  28
Bài 2.8. Độc lập theo cặp không có nghĩa là độc lập lẫn nhau
Ta nói rằng hai biến ngẫu nhiên là độc lập theo cặp nếu:
                                     𝑝(𝑋 |𝑋 ) = 𝑝(𝑋 )
Và do đó:
                         𝑝(𝑋 , 𝑋 ) = 𝑝(𝑋 )𝑝(𝑋 |𝑋 ) = 𝑝(𝑋 )𝑝(𝑋 )
Ta nói rằng n biến ngẫu nhiên là độc lập lẫn nhau nếu:
                             𝑝(𝑋 |𝑋 ) = 𝑝(𝑋 )∀𝑆 ∈ {1, … , 𝑛}{𝑖}
Và do đó:

                                    𝑝(𝑋   :   )=   𝑝(𝑋 )

Chứng minh rằng nếu mọi cặp biến ngẫu nhiên là độc lập không có nghĩa là chúng
độc lập lẫn nhau. Bạn có thể đưa ra một phản ví dụ.
Bài 2.9. Độc lập có điều kiện nếu và chỉ nếu tách được đồng thời (joint factorizes)
Trong chương này ta đã biết 𝑋 ⊥ 𝑌|𝑍 nếu và chỉ nếu
                                  𝑝(𝑥, 𝑦|𝑧) = 𝑝(𝑥|𝑧)𝑝(𝑦|𝑧)
Với mọi x, y, z mà p(z)>0. Bạn hãy chứng minh một cách định nghĩa khác như sau:
𝑋 ⊥ 𝑌|𝑍 nếu tồn tại các hàm g và h sao cho:
                                 𝑝(𝑥, 𝑦|𝑧) = 𝑔(𝑥, 𝑧)ℎ(𝑦, 𝑧)
Với mọi x, y, z mà p(z)>0.
Bài 2.10. Độc lập có điều kiện
Các tính chất sau là đúng hay sai? Bạn có thể chứng minh hoặc bác bỏ. Chú ý rằng ta
không chỉ giới hạn ở các phân phối mà có thể biểu diễn được ở dạng đồ thị.
   a) (𝑋 ⊥ 𝑊|𝑍, 𝑌)⋀ (𝑋 ⊥ 𝑌|𝑍) ⇒ ( 𝑋 ⊥ 𝑌, 𝑊|𝑍)
   b) (𝑋 ⊥ 𝑌|𝑍)⋀ (𝑋 ⊥ 𝑌|𝑊) ⟹ ( 𝑋 ⊥ 𝑌|𝑍, 𝑊)




                                                                                      29
Chương 3
ENTROPY, ENTROPY TƯƠNG ĐỐI VÀ THÔNG TIN TƯƠNG
HỖ


                                      We are drowning in information but starved for knowledge.
                                                                                 John Naisbitt
                                                    Information is the resolution of uncertainty.
                                                                               Claude Shannon


     Thông tin là khái niệm không đơn giản đến mức có thể được tóm gọn trong một
định nghĩa đơn giản. Trong chương này, trước tiên chúng ta sẽ tìm hiểu entropy,
một đại lượng do Shannon định nghĩa cho các phân phối xác suất. Đại lượng này có
nhiều tính chất phù hợp với cảm nhận trực quan về độ đo lượng thông tin. Sau đó,
chúng ta tìm hiểu định nghĩa thông tin tương hỗ, đại lượng dùng để đo lượng tin
chung giữa hai biến ngẫu nhiên. Khi đó entropy có thể được hiểu là lượng thông tin
tự thân của biến ngẫu nhiên. Thông tin tương hỗ là một trường hợp đặc biệt của
entropy tương đối, một độ đo khoảng cách giữa hai phân phối xác suất. Ba đại lượng
này có mối quan hệ chặt chẽ và có chung một số tính chất đơn giản. Chúng ta cũng
sẽ tìm hiểu các tính chất cơ bản của các đại lượng này (luật xích, tính không âm,
v.v.), bất đẳng thức Jensen, bất đẳng thức xử lý dữ liệu, và bất đẳng thức Fano.
     Trong các chương sau, chúng ta sẽ tìm hiểu xem làm thế nào mà các đại lượng
này lại chính là lời giải tự nhiên cho một số bài toán quan trọng trong truyền thông,
trò chơi cá cược, suy diễn thống kê. Qua đó ta sẽ thấy được giá trị to lớn của các khái
niệm cơ bản được trình bày trong chương này.


3.1. ENTROPY

    3.1.1 Định nghĩa
    Entropy là độ đo mức độ không chắc chắn của biến ngẫu nhiên. Giả sử 𝑋 là một
biến ngẫu nhiên rời rạc với bảng chữ cái 𝒳 và hàm phân phối xác suất
                               𝑝(𝑥) = 𝑃{𝑋 = 𝑥}, 𝑥 ∈ 𝒳
                                                                1
                       𝐻(𝑋) = −       𝑝(𝑥) log 𝑝(𝑥) = 𝐸 log
                                                               𝑝(𝑋)
                                  ∈

    Chú ý :
    - Ta cũng có thể viết 𝐻(𝑝) để thể hiện đại lượng trên. Logarit tính theo cơ số 2
và entropy được tính theo bit. Ta cũng qui ước rằng 0 log 0 = 0 để tiện cho việc tính
toán.

                                                                                              30
    - Ta có : 𝐻(𝑋) = 𝐸 𝑙𝑜𝑔
                             ( )

    Ví dụ:
                   1   𝑣ớ𝑖 𝑥á𝑐 𝑠𝑢ấ𝑡 𝑝
    - Giả sử : 𝑋 =
                   0 𝑣ớ𝑖 𝑥á𝑐 𝑠𝑢ấ𝑡 1 − 𝑝
    - Khi đó: 𝐻(𝑋) = 𝐻(𝑝) = −𝑝 log 𝑝 − (1 − 𝑝)log (1 − 𝑝)




                             Hình 3.1. Quan hệ giữa p và H(p)

     Hình 3.1 cho thấy quan hệ giữa p và H(p). Khi xác suất p là nhỏ (gần 0), biến
ngẫu nhiên X hiếm khi nhận giá trị 1, do đó tính ngẫu nhiên không cao, tương ứng
là giá trị entropy cũng nhỏ. Trường hợp p gần 1 cũng tương tự như vậy. Khi p=1/2
tính ngẫu nhiên rất cao do hai khả năng là như nhau, khi đó entropy đạt giá trị cực
đại bằng 1.
    Các bạn dễ dàng chứng minh hai tính chất sau của entropy:
                                       𝐻(𝑋) ≥ 0
    Chứng minh: 0 ≤ 𝑝(𝑥) ≤ 1 chỉ ra rằng log       ( )
                                                         ≥0

                               𝐻 (𝑋) = (log 𝑎)𝐻 (𝑋)
    Chứng minh: log 𝑝 = log 𝑎 log 𝑝
    Tính chất thứ 2 của entropy cho phép chúng ta thay đổi cơ số của logarit trong
định nghĩa. Entropy có thể thay đổi từ một cơ số sang cơ số khác bằng cách nhân với
một hệ số thích hợp.
    3.1.2 Thảo luận
     Trong trường hợp logarit tính theo cơ số 2, thông tin được đo bằng bit. Tất nhiên
biết được lượng thông tin khác với chính thông tin đó nghĩa là gì, hàm ý gì. Ở đây ta
sẽ thảo luận một chút về lượng tin, chứ không xem xét nội dung hay ý nghĩa của
thông tin.


                                                                                   31
     Thông tin được lượng hóa như thế nào? Xét một tình huống mà có thể có vài
khả năng xảy ra. Chẳng hạn như gieo một đồng xu (2 khả năng) hay chọn một quân
bài từ bộ bài tú lơ khơ (52 khả năng). Một người (Hằng) có thể nói với một người
khác (Minh) ngắn gọn đến mức nào về kết quả?
    Trước tiên xem xét ví dụ tung đồng xu, giả sử hai khả năng sấp-ngửa là như
nhau. Nếu Hằng muốn nói với Minh về kết quả, cô ấy có vài cách nói. Cô ta có thể
nói “sấp” hay “ngửa” hoặc đơn giản là 0 hay 1. Theo cả hai cách này lượng tin là
bằng nhau, 1 bit.
     Nếu Hằng gieo hai đồng xu, cô ấy có thể nói kết quả nào trong 4 khả năng đã
xảy ra, bằng cách nói 0 hay 1 hai lần. Tương tự, kết quả của thí nghiệm với 8 khả
năng như nhau có thể được truyền tải bằng 3 bit, và tổng quát hơn 2 kết quả với 𝑛
bit. Do đó lượng tin là logarit (cơ số 2) của số khả năng.
     Chú ý rằng trao đổi thông tin bao gồm hai pha. Đầu tiên là pha “thiết lập”, trong
đó Hằng và Minh thống nhất về cách mà họ sẽ giao tiếp, và chính xác mỗi chuỗi bit
có ý nghĩa là gì. Qui ước chung này gọi là mã. Sau đó đến pha “giao tiếp”, trong đó
các chuỗi nhị phân (dữ liệu) được gửi. Chẳng hạn để giao tiếp về loại quân bài được
chọn ra từ bộ bài, họ có thể qui ước mã: 00-nhép, 01-rô, 10-cơ, 11-bích. Sử dụng mã
đó, Hằng có thể nói với Minh về loại quân bài đã được rút sử dụng 2 bit dữ liệu. Cô
ta có thể làm như vậy lặp lại nhiều lần, sử dụng cùng một mã.
     Sau khi Minh biết một quân bài đã được rút nhưng Hằng chưa nói cho anh ta
kết quả, anh ta không chắc chắn về kết quả. Sự không chắc chắn, hay thiếu thông tin,
của Minh cũng có thể được mô tả bằng bit. Sau khi nghe được kết quả từ Hằng, sự
không chắc chắn của anh ta giảm đi nhờ thông tin nhận được. Sự không chắc chắn
của Minh tăng lên trong pha thiết lập và sau đó giảm đi trong pha giao tiếp.
    Một số chú ý quan trọng về thông tin:
    - Thông tin có thể thu được qua quan sát, thí nghiệm, hay đo đạc
    - Thông tin có tính chủ quan, hay phụ thuộc người quan sát
     - Sự không chắc chắn của một người có thể tăng lên khi anh ta chưa biết thông
tin nhưng biết nó tồn tại đâu đó và sau đó có thể giảm đi sau khi nhận được tin
    - Thông tin có thể bị mất, do mất dữ liệu, hay mất mã
    - Thông tin có thể được lưu trữ, được gửi đi


3.2. ENTROPY PHỤ THUỘC VÀ ENTROPY ĐIỀU KIỆN

   Entropy phụ thuộc của một cặp biến ngẫu nhiên rời rạc (𝑋, 𝑌) với phân phối
phụ thuộc 𝑝(𝑥, 𝑦) là:

                        𝐻(𝑋, 𝑌) = −           𝑝(𝑥, 𝑦)𝑙𝑜𝑔𝑝(𝑥, 𝑦)
                                      ∈   ∈


                                                                                   32
Hay
                            𝐻(𝑋, 𝑌) = −𝐸𝑙𝑜𝑔𝑝(𝑋, 𝑌)
Entropy điều kiện:

             𝐻(𝑌|𝑋) = −                 𝑝(𝑥, 𝑦)𝑙𝑜𝑔𝑝(𝑦|𝑥) = −𝐸𝑙𝑜𝑔𝑝(𝑌|𝑋)
                            ∈       ∈

Luật xích:


                            𝐻(𝑋, 𝑌) = 𝐻(𝑋) + 𝐻(𝑌|𝑋)
Chứng minh:

       𝐻(𝑋, 𝑌) = −               𝑝(𝑥, 𝑦)log 𝑝(𝑥, 𝑦)
                         ∈𝒳 ∈𝒴

               =−               𝑝(𝑥, 𝑦)log 𝑝(𝑥)𝑝(𝑦|𝑥)
                     ∈𝒳 ∈𝒴

               = −              𝑝(𝑥, 𝑦) log 𝑝(𝑥) −            𝑝(𝑥, 𝑦)log𝑝(𝑦|𝑥)
                     ∈𝒳 ∈𝒴                            ∈𝒳 ∈𝒴

               =−         𝑝(𝑥, 𝑦) log 𝑝(𝑥) −             𝑝(𝑥, 𝑦)log𝑝(𝑦|𝑥)
                     ∈𝒳                          ∈𝒳 ∈𝒴
               = 𝐻(𝑋) + 𝐻(𝑌|𝑋)



Hệ quả:
                         𝐻(𝑋, 𝑌|𝑍) = 𝐻(𝑋|𝑍) + 𝐻(𝑌|𝑋, 𝑍)
Ví dụ: Giả sử (𝑋, 𝑌) có phân phối phụ thuộc sau:
                                X
                     Y                    1     2      3       4
                                1         1      1     1        1
                                          8     16    32       32
                                2         1      1     1        1
                                         16      8    32       32
                                3         1      1     1        1
                                         16     16    16       16
                                4         1     0      0       0
                                          4


Hãy tính 𝐻(𝑋), 𝐻(𝑌), 𝐻(𝑋|𝑌).



                                                                                 33
    Phân phối biên duyên của 𝑋 là (1/2, 1/4, 1/8, 1/8) và của 𝑌 là (1/4, 1/4, 1/4, 1/4).
Do đó 𝐻(𝑋) = 7/4 và 𝐻(𝑌) = 2. Từ luật xích ta suy ra :
                                 𝐻(𝑋|𝑌) = 𝐻(𝑋, 𝑌) − 𝐻(𝑌)

                                                 1   1 1   1     1   1
     𝐻(𝑋, 𝑌) = −          𝑝(𝑥, 𝑦)𝑙𝑜𝑔𝑝(𝑥, 𝑦) = − 2 𝑙𝑜𝑔 − 𝑙𝑜𝑔 − 6 𝑙𝑜𝑔
                                                 8   8 4   4    16  16
                     1       1    3 1 3 5 6 + 4 + 12 + 5 27
                 − 4 𝑙𝑜𝑔        = + + + =                   =
                    32      32 4 2 2 8                8       8
              27       11
     𝐻(𝑋|𝑌) =    −2=
               8        8


3.3. ENTROPY TƯƠNG ĐỐI VÀ THÔNG TIN TƯƠNG HỖ

    Entropy tương đối hay khoảng cách Kullback-Leibler giữa hai hàm phân phối
xác suất 𝑝(𝑥) và 𝑞(𝑥) là :
                                                  𝑝(𝑥)         𝑝(𝑋)
                       𝐷(𝑝||𝑞) =        𝑝(𝑥)𝑙𝑜𝑔        = 𝐸 𝑙𝑜𝑔
                                                  𝑞(𝑥)         𝑞(𝑋)
                                    ∈

    Chú ý :
   - Entropy tương đối không phải khoảng cách thực sự vì nó không đối xứng và
không thỏa mãn bất đẳng thức tam giác
   - Tuy vậy, để dễ hình dung, ta có thể coi Entropy tương đối là "khoảng cách"
    Thông tin tương hỗ :
     Giả sử 𝑋 và 𝑌 là các biến ngẫu nhiên với hàm phân phối xác suất phụ thuộc là
𝑝(𝑥, 𝑦) và các hàm phân phối xác suất biên là 𝑝(𝑥) và 𝑝(𝑦). Thông tin tương hỗ
𝐼(𝑋; 𝑌) là độ đo cho ta biết biến ngẫu nhiên này chứa bao nhiêu thông tin về biến
ngẫu nhiên khác. Nó được tính bởi entropy tương đối giữa phân phối phụ thuộc và
phân phối tích 𝑝(𝑥)𝑝(𝑦):
                                 𝑝(𝑥, 𝑦)                                           𝑝(𝑋, 𝑌)
  𝐼(𝑋; 𝑌) =        𝑝(𝑥, 𝑦)𝑙𝑜𝑔            = 𝐷(𝑝(𝑥, 𝑦)| 𝑝(𝑥)𝑝(𝑦) = 𝐸    ( , ) 𝑙𝑜𝑔
                                𝑝(𝑥)𝑝(𝑦)                                          𝑝(𝑋)𝑝(𝑌)

    Ví dụ : Giả sử 𝒳 = {0,1} và 𝑝 và 𝑞 là hai phân phối trên đó. Giả sử 𝑝(0) = 1 − 𝑟,
𝑝(1) = 𝑟 và 𝑞(0) = 1 − 𝑠, 𝑞(1) = 𝑠. Khi đó:
                                                   1−𝑟        𝑟
                          𝐷(𝑝||𝑞) = (1 − 𝑟)𝑙𝑜𝑔         + 𝑟𝑙𝑜𝑔
                                                   1−𝑠        𝑠
    Và
                                                   1−𝑠        𝑠
                          𝐷(𝑞||𝑝) = (1 − 𝑠)𝑙𝑜𝑔         + 𝑠𝑙𝑜𝑔
                                                   1−𝑟        𝑟
    Nếu 𝑟 = 𝑠 thì 𝐷(𝑝||𝑞) = 𝐷(𝑞||𝑝) = 0. Nếu 𝑟 = 1/2 và 𝑠 = 1/4 thì 𝐷(𝑝||𝑞) = 1 −
 𝑙𝑜𝑔3 = 0.2075bit


                                                                                         34
    Còn 𝐷(𝑞||𝑝) = 𝑙𝑜𝑔3 − 1 = 0.1887 bit




                    Hình 3.2. Quan hệ giữa entropy và thông tin tương hỗ

    Hình vẽ 3.2 minh họa các quan hệ sau:
                          𝐼(𝑋; 𝑌) = 𝐻(𝑋) − 𝐻(𝑋|𝑌)
                          𝐼(𝑋; 𝑌) = 𝐻(𝑌) − 𝐻(𝑌|𝑋)
                          𝐼(𝑋; 𝑌) = 𝐻(𝑋) + 𝐻(𝑌) − 𝐻(𝑋, 𝑌)
                          𝐼(𝑋; 𝑌) = 𝐼(𝑌; 𝑋)
                          𝐼(𝑋; 𝑋) = 𝐻(𝑋)


3.4. CÁC LUẬT XÍCH CHO ENTROPY, ENTROPY TƯƠNG ĐỐI VÀ
THÔNG TIN TƯƠNG HỖ

    Luật xích cho entropy:
    Giả sử 𝑋 , 𝑋 , … , 𝑋 là các biến ngẫu nhiên có hàm phân phối phụ thuộc là
𝑝(𝑥 , 𝑥 , … , 𝑥 ). Khi đó:

                     𝐻(𝑋 , 𝑋 , … , 𝑋 ) =          𝐻(𝑋 |𝑋      ,…,𝑋 )

    Chứng minh:
Bằng cách lặp lại các áp dụng của luật mở rộng hai biến cho entropy, chúng ta có

                    𝐻(𝑋 , 𝑋 ) = 𝐻(𝑋 ) + 𝐻(𝑋 |𝑋 )
                  𝐻(𝑋 , 𝑋 , 𝑋 ) = 𝐻(𝑋 ) + 𝐻(𝑋 , 𝑋 |𝑋 )

                                                                                   35
                                  = 𝐻(𝑋 ) + 𝐻(𝑋 |𝑋 ) + 𝐻(𝑋 |𝑋 , 𝑋 )

                                                      ⋮

           𝐻(𝑋 , 𝑋 , … , 𝑋 ) = 𝐻(𝑋 ) + 𝐻(𝑋 |𝑋 ) + ⋯ + 𝐻(𝑋 |𝑋                       ,…,𝑋 )

                              =           𝐻(𝑋 |𝑋          ,…,𝑋 )


    Chứng minh khác: Chúng ta viết 𝑝(𝑥 , … , 𝑥 ) = ∏                          𝑝( 𝑥 |𝑥   , … , 𝑥 ) và ước
lượng

      𝐻(𝑋 , 𝑋 , … , 𝑋 ) = −                𝑝(𝑥 , 𝑥 , … , 𝑥 ) log 𝑝(𝑥 , 𝑥 , … , 𝑥 )
                              ,   ,…,


                       =−                  𝑝(𝑥 , 𝑥 , … , 𝑥 ) log        𝑝(𝑥 |𝑥     ,𝑥    ,…,𝑥 )
                              ,   ,…,


                       =−                         𝑝(𝑥 , 𝑥 , … , 𝑥 )𝑙𝑜𝑔𝑝(𝑥 |𝑥       ,𝑥   ,…,𝑥 )
                              ,   ,…,


                       =−                        𝑝(𝑥 , 𝑥 , … , 𝑥 )𝑙𝑜𝑔𝑝(𝑥 |𝑥       ,𝑥    ,…,𝑥 )
                                      ,   ,…,

                       =          𝐻(𝑋 |𝑋            ,…,𝑋 )



    Luật xích cho thông tin tương hỗ:

                    𝐼(𝑋 , 𝑋 , … , 𝑋 ; 𝑌) =                 𝐼(𝑋 ; 𝑌|𝑋    ,…,𝑋 )

    Chứng minh:
            𝐼(𝑋 , 𝑋 , … , 𝑋 ; 𝑌) = 𝐻(𝑋 , 𝑋 , … , 𝑋 ) − 𝐻(𝑋 , 𝑋 , … , 𝑋 |𝑌)

                                  =             𝐻(𝑋 |𝑋      ,…,𝑋 ) −         𝐻(𝑋 |𝑋     , … , 𝑋 , 𝑌)


                                  =             𝐼(𝑋 ; 𝑌|𝑋 , 𝑋 , … , 𝑋   )



    Trong đó, thông tin tương hỗ có điều kiện của các biến ngẫu nhiên X và Y cho
trước Z là:
                                                                              𝑝(𝑋, 𝑌|𝑍)
            𝐼(𝑋; 𝑌|𝑍) = 𝐻(𝑋|𝑍) − 𝐻(𝑋|𝑌, 𝑍) = 𝐸                ( , , ) 𝑙𝑜𝑔
                                                                            𝑝(𝑋|𝑍)𝑝(𝑌|𝑍)
    Luật xích cho entropy tương đối:


                                                                                                       36
                 𝐷(𝑝(𝑥, 𝑦)||𝑞(𝑥, 𝑦)) = 𝐷(𝑝(𝑥)||𝑞(𝑥)) + 𝐷(𝑝(𝑦|𝑥)||𝑞(𝑦|𝑥))
       Chứng minh:


                                                              𝑝(𝑥, 𝑦)
                 𝐷(𝑝(𝑥, 𝑦)| 𝑞(𝑥, 𝑦) =           𝑝(𝑥, 𝑦) log
                                                              𝑞(𝑥, 𝑦)
                                                              𝑝(𝑥)𝑝(𝑦|𝑥)
                                    =           𝑝(𝑥, 𝑦) log
                                                              𝑞(𝑥)𝑞(𝑦|𝑥)
                                                              𝑝(𝑥)                           𝑝(𝑦|𝑥)
                                    =           𝑝(𝑥, 𝑦) log        +         𝑝(𝑥, 𝑦) log
                                                              𝑞(𝑥)                           𝑞(𝑦|𝑥)
                                    = 𝐷(𝑝(𝑥)||𝑞(𝑥)) + 𝐷(𝑝(𝑦|𝑥)||𝑞(𝑦|𝑥))

       Trong đó, entropy tương đối có điều kiện là:
                                                            𝑝(𝑦|𝑥)                  𝑝(𝑌|𝑋)
          𝐷(𝑝(𝑦|𝑥)||𝑞(𝑦|𝑥)) =     𝑝(𝑥)        𝑝(𝑦|𝑥)𝑙𝑜𝑔            =𝐸   ( , ) 𝑙𝑜𝑔
                                                            𝑞(𝑦|𝑥)                  𝑞(𝑌|𝑋)


3.5. BẤT ĐẲNG THỨC JENSEN

3.5.1. Hàm lồi và hàm lõm
       Trước khi phát biểu bất đẳng thức Jensen và hệ quả, ta nhắc lại định nghĩa hàm
lồi.
    Hàm lồi: Hàm f(x) được gọi là hàm lồi trên khoảng (a, b) nếu với mọi x1, x2 ∈ (a,
b) và 0 ≤ 𝜆 ≤ 1:
                       𝑓(𝜆𝑥 + (1 − 𝜆)𝑥 ) ≤ 𝜆𝑓(𝑥 ) + (1 − 𝜆)𝑓(𝑥 )
       Hàm f(x) được gọi là lồi chặt nếu dấu bằng xảy ra khi và chỉ khi 𝜆 = 0 hoặc 𝜆 =
1.




                                        Hình 3.3. Hàm lồi




                                                                                                  37
     Hình 3.3 minh họa một hàm lồi, ta có thể thấy đoạn thẳng nối hai điểm
(𝑥 , 𝑓(𝑥 )) và (𝑥 , 𝑓(𝑥 )) nằm bên trên đồ thị của 𝑓(𝑥) xét trên đoạn [𝑥 , 𝑥 ]. Một số ví
dụ về hàm lồi: 𝑥 , |𝑥|, 𝑒 , 𝑥𝑙𝑜𝑔𝑥
      Hàm lõm: Hàm f(x) được gọi là hàm lõm nếu -f(x) là hàm lồi.
      Một số ví dụ về hàm lõm: 𝑙𝑜𝑔𝑥, √𝑥
      Nhân tiện ta cũng nhắc lại định lý sau nói về điều kiện hàm lồi trên khoảng (a,
b):
    Định lý: Nếu hàm f có đạo hàm bậc hai không âm (dương) trên một khoảng nào
đó thì hàm f lồi (lồi chặt) trên khoảng đó.




                          Hình 3.4. Ví dụ về hàm lồi (a) và hàm lõm (b)




3.5.2. Bất đẳng thức Jensen
      Giả sử 𝑓 là một hàm lồi và 𝑋 là một biến ngẫu nhiên:
                                      𝐸𝑓(𝑋) ≥ 𝑓(𝐸𝑋)
    Thêm vào đó, nếu 𝑓 là lồi chặt, dấu bằng của bất đẳng thức trên ngụ ý rằng 𝑋 =
𝐸𝑋 với xác suất 1.
      Chứng minh:
     Ta sẽ chứng minh qui nạp theo 𝑘 = |𝒳|. Trong trường hợp k=2, bất đẳng thức
(bất đẳng thức) cần chứng minh là:
                          𝑝 𝑓(𝑥 ) + 𝑝 𝑓(𝑥 ) ≥ 𝑓(𝑝 𝑥 + 𝑝 𝑥 )



                                                                                      38
     Dễ thấy bất đẳng thức này là đúng vì f là hàm lồi. Giả sử bất đẳng thức Jensen là
đúng với k-1, ta sẽ chứng minh nó đúng với k. Ta đặt 𝑞 = 𝑝 /(1 − 𝑝 ) với i = 1, 2, …,
k-1. Ta có:

                       𝑝 𝑓(𝑥 ) = 𝑝 𝑓(𝑥 ) + (1 − 𝑝 )                𝑞 𝑓(𝑥 )

                               ≥ 𝑝 𝑓(𝑥 ) + (1 − 𝑝 )𝑓(               𝑞𝑥)

                               ≥ 𝑓(𝑝 𝑥 + (1 − 𝑝 )                  𝑞𝑥)

                               = 𝑓(      𝑝𝑥)

    Trong đó bất đẳng thức thứ nhất đúng do giả thiết qui nạp, và bất đẳng thức
thứ hai đúng do f là hàm lồi. Trường hợp dấu bằng xảy ra thì sinh viên tự xem xét.


3.6. BẤT ĐẲNG THỨC THÔNG TIN

    Giả sử 𝑝(𝑥), 𝑞(𝑥), 𝑥 ∈ 𝒳 là các hàm phân phối xác suất. Khi đó:
                                       𝐷(𝑝||𝑞) ≥ 0
    Dấu = xảy ra khi và chỉ khi 𝑝(𝑥) = 𝑞(𝑥) với mọi 𝑥.
    Chứng minh: Để chứng minh bất đẳng thức này, ta sử dụng bất đẳng thức
Jensen vừa nêu ở phần trên. Chú ý vì log là hàm lõm nên chiều của bất đẳng thức
Jensen sẽ là 𝐸𝑓(𝑋) ≤ 𝑓(𝐸𝑋). Theo định nghĩa của entropy tương đối:
                                                            𝑝(𝑥)
                          −𝐷(𝑝||𝑞) = −          𝑝(𝑥)𝑙𝑜𝑔
                                                            𝑞(𝑥)
                                            ∈
                                                        𝑞(𝑥)
                                   =        𝑝(𝑥)𝑙𝑜𝑔
                                                        𝑝(𝑥)
                                        ∈
                                                           𝑞(𝑥)
                                   ≤ 𝑙𝑜𝑔            𝑝(𝑥)
                                                           𝑝(𝑥)
                                                ∈

                                   = 𝑙𝑜𝑔            𝑞(𝑥) = 𝑙𝑜𝑔1 = 0
                                                ∈

    Do đó: 𝐷(𝑝||𝑞) ≥ 0.
    Hệ quả 1: Giả sử X và Y là các biến ngẫu nhiên, khi đó:
                                       𝐼(𝑋; 𝑌) ≥ 0
    Dấu = xảy ra khi và chỉ khi X và Y là độc lập.
    Hệ quả 2: 𝐷(𝑝(𝑦|𝑥)||𝑞(𝑦|𝑥)) ≥ 0
    Dấu = xảy ra khi và chỉ khi 𝑝(𝑦|𝑥) = 𝑞(𝑦|𝑥) với mọi 𝑥, 𝑦 mà 𝑝(𝑥) > 0.


                                                                                   39
    Hệ quả 3 : 𝐼(𝑋; 𝑌|𝑍) ≥ 0
    Dấu = xảy ra khi và chỉ khi X và Y là độc lập với điều kiện 𝑍.


3.7. ĐỊNH LÝ VỀ GIÁ TRỊ CỰC ĐẠI CỦA ENTROPY

    Giả sử X là biến ngẫu nhiên có giá trị thuộc tập 𝒳. Khi đó :
                                       𝐻(𝑋) ≤ 𝑙𝑜𝑔|𝒳|
    Dấu = xảy ra khi và chỉ khi X có phân phối đều.
    Chứng minh :
    Gọi 𝑢(𝑥) = |𝒳| là hàm mật độ xác suất đều trên 𝒳, và giả sử 𝑝(𝑥) là hàm mật độ
xác suất của 𝑋, ta có :
                          ( )
    𝐷(𝑝||𝑢) = ∑ 𝑝(𝑥)𝑙𝑜𝑔   ( )
                                = 𝑙𝑜𝑔|𝒳| − 𝐻(𝑋)

    Vì 𝐷(𝑝||𝑢) không âm nên suy ra đpcm.


3.8. CÓ ĐIỀU KIỆN LÀM GIẢM ENTROPY

    Giả sử 𝑋 và 𝑌 là hai biến ngẫu nhiên, khi đó :
                                       𝐻(𝑋|𝑌) ≤ 𝐻(𝑋)
    Dấu = xảy ra khi và chỉ khi 𝑋 và 𝑌 độc lập.
    Chứng minh: 0 ≤ 𝐼(𝑋; 𝑌) = 𝐻(𝑋) − 𝐻(𝑋|𝑌), suy ra đpcm.
    Về trực quan, định lý nói rằng biết biến ngẫu nhiên khác sẽ làm giảm sự không
chắc chắn trong 𝑋. Chú ý rằng điều này là đúng về trung bình. Cụ thể hơn, 𝐻(𝑋|𝑌 =
𝑦) có thể lớn hơn, nhỏ hơn, hay bằng H(X), tuy nhiên về trung bình thì 𝐻(𝑋|𝑌) =
∑ 𝑝(𝑦)𝐻(𝑋|𝑌 = 𝑦) ≤ 𝐻(𝑋). Ví dụ, trong một phiên tòa, một chứng cớ mới có thể
làm tăng sự không chắc chắn, tuy nhiên về trung bình thì chứng cớ làm giảm sự
không chắc chắn.
    Ví dụ: Giả sử X, Y có phân phối phụ thuộc sau:
                                          X
                                   Y           1       2
                                          1    0       3
                                                       4
                                          2    1       1
                                               8       8




                                                                               40
    Ta dễ dàng tính được 𝐻(𝑋) = 𝐻( , ) = 0.544 bit, 𝐻(𝑋|𝑌 = 1) = 0 bit, 𝐻(𝑋|𝑌 =
2) = 1 bit. 𝐻(𝑋|𝑌) = 𝐻(𝑋|𝑌 = 1) + 𝐻(𝑋|𝑌 = 2) = 0.25 bit. Như vậy, tính ngẫu
nhiên của 𝑋 giảm đi khi 𝑌 = 1 và tăng lên khi 𝑌 = 2, nhưng trung bình là giảm.


3.9. CẬN ĐỘC LẬP CỦA ENTROPY

     Giả sử 𝑋 , 𝑋 , … , 𝑋 là các biến ngẫu nhiên có hàm phân phối xác suất phụ thuộc
là 𝑝(𝑥 , 𝑥 , … , 𝑥 ). Khi đó:

                               𝐻(𝑋 , 𝑋 , … , 𝑋 ) ≤             𝐻(𝑋 )

    Dấu = xảy ra khi và chỉ khi các Xi là độc lập.
    Chứng minh: Theo luật xích ta có

                        𝐻(𝑋 , 𝑋 , … , 𝑋 ) =            𝐻(𝑋 |𝑋        ,…,𝑋 )


                                               ≤       𝐻(𝑋 )

    Dấu = xảy ra khi và chỉ khi các biến ngẫu nhiên 𝑋 là độc lập.


3.10. BẤT ĐẲNG THỨC TỔNG LOG VÀ ỨNG DỤNG

    Định lý: Giả sử a1, a2, …, an và b1, b2, …, bn là các số không âm, khi đó:

                                         𝑎                       ∑     𝑎
                               𝑎 𝑙𝑜𝑔       ≥           𝑎 𝑙𝑜𝑔
                                         𝑏                       ∑     𝑏

    Dấu bằng xảy ra khi và chỉ khi ai/bi là hằng số.
     Chứng minh: Không mất tính tổng quát ta giả sử ai>0 và bi>0. Hàm f(t) = tlogt là
lồi chặt do 𝑓’’(𝑡) = 𝑙𝑜𝑔𝑒 > 0 với mọi t>0. Áp dụng bất đẳng thức Jensen ta có :

                                         𝛼 𝑓(𝑡 ) ≥ 𝑓(          𝛼𝑡)

    Với 𝛼 ≥ 0 và ∑ 𝛼 = 1. Đặt 𝑡 =              và 𝛼 = ∑         , khi đó :

                           𝑎             𝑎             𝑎                     𝑎
                                   𝑙𝑜𝑔     ≥                    𝑙𝑜𝑔
                       ∑       𝑏         𝑏         ∑       𝑏            ∑        𝑏
    Đơn giản ∑     𝑏 ở hai vế ta được bất đẳng thức tổng log :

                                         𝑎                       ∑     𝑎
                               𝑎 𝑙𝑜𝑔       ≥           𝑎 𝑙𝑜𝑔
                                         𝑏                       ∑     𝑏


                                                                                     41
3.10.1. Tính chất lồi của entropy tương đối
    D(p||q) là lồi theo (p,q), cụ thể hơn, nếu (p1, q1) và (p2, q2) là hai cặp hàm mật độ
xác suất thì:
         𝐷(𝜆𝑝 + (1 − 𝜆)𝑝 ||𝜆𝑞 + (1 − 𝜆)𝑞 ) ≤ 𝜆𝐷(𝑝 ||𝑞 ) + (1 − 𝜆)𝐷(𝑝 ||𝑞 )

3.10.2. Tính chất lõm của entropy
    H(p) là hàm lõm theo p.

3.10.3. Tính chất lồi/lõm của thông tin tương hỗ
    Giả sử 𝑋, 𝑌 là hai biến ngẫu nhiên mà (𝑋, 𝑌)~𝑝(𝑥, 𝑦) = 𝑝(𝑥)𝑝(𝑦|𝑥). Thông tin
tương hỗ 𝐼(𝑋 ; 𝑌) là hàm lõm của 𝑝(𝑥) với 𝑝(𝑦|𝑥) cố định và là hàm lồi của 𝑝(𝑦|𝑥) với
𝑝(𝑥) cố định.


3.11. BẤT ĐẲNG THỨC XỬ LÝ DỮ LIỆU

   Xích Markov: Các biến ngẫu nhiên 𝑋, 𝑌, 𝑍 được gọi là tạo thành một xích
Markov theo thứ tự đó (ký hiệu 𝑋 → 𝑌 → 𝑍) nếu phân phối có điều kiện của 𝑍 chỉ
phụ thuộc vào Y và độc lập có điều kiện với X. Nói cách khác:
                               𝑝(𝑥, 𝑦, 𝑧) = 𝑝(𝑥)𝑝(𝑦|𝑥)𝑝(𝑧|𝑦)
    Một số hệ quả đơn giản:
    - 𝑋 → 𝑌 → 𝑍 suy ra 𝑋 và 𝑍 là độc lập có điều kiện khi biết 𝑌:
                               𝑝(𝑥, 𝑦, 𝑧) 𝑝(𝑥, 𝑦)𝑝(𝑧|𝑦)
                 𝑝(𝑥, 𝑧|𝑦) =             =              = 𝑝(𝑥|𝑦)𝑝(𝑧|𝑦)
                                 𝑝(𝑦)          𝑝(𝑦)
    - 𝑋 → 𝑌 → 𝑍 cũng có nghĩa là 𝑍 → 𝑌 → 𝑋, do đó đôi khi người ta viết 𝑋 ↔ 𝑌 ↔ 𝑍
    - Nếu 𝑍 = 𝑓(𝑌) thì 𝑋 → 𝑌 → 𝑍
    Bất đẳng thức xử lý dữ liệu: Nếu 𝑋 → 𝑌 → 𝑍 thì 𝐼(𝑋; 𝑌) ≥ 𝐼(𝑋; 𝑍). Đây là bất
đẳng thức quan trọng và hữu ích, nó cho ta biết rằng không thể tăng thông tin chứa
trong 𝑌 về 𝑋 bằng cách xử lý 𝑌 (dù là đơn định hay ngẫu nhiên).
    Chứng minh: Sử dụng luật xích, ta khai triển thông tin tương hỗ theo hai cách :
                 𝐼(𝑋; 𝑌, 𝑍) = 𝐼(𝑋; 𝑍) + 𝐼(𝑋; 𝑌|𝑍) = 𝐼(𝑋; 𝑌) + 𝐼(𝑋; 𝑍|𝑌)
     Vì 𝐼(𝑋 ; 𝑍|𝑌) = 0 (sinh viên tự lập luận chỗ này) và 𝐼(𝑋; 𝑌|𝑍) ≥ 0, ta có : 𝐼(𝑋; 𝑌) ≥
𝐼(𝑋; 𝑍)
    Dấu = xảy ra khi và chỉ khi 𝐼(𝑋; 𝑌|𝑍) = 0 (tức là 𝑋 → 𝑍 → 𝑌).
    Hệ quả 1 : Nếu 𝑍 = 𝑔(𝑌) thì 𝐼(𝑋; 𝑌) ≥ 𝐼(𝑋; 𝑔(𝑌))
    Chứng minh: dành cho bạn đọc.
    Hệ quả 2: Nếu 𝑋 → 𝑌 → 𝑍 thì 𝐼(𝑋; 𝑌|𝑍) ≤ 𝐼(𝑋; 𝑌)


                                                                                       42
   Như vậy, sự phụ thuộc giữa 𝑋 và 𝑌 giảm hoặc không đổi khi ta quan sát được
một biến ngẫu nhiên "xuôi dòng" 𝑍. Chú ý là khi 𝑋, 𝑌, 𝑍 không tạo thành xích
Markov thì có thể 𝐼(𝑋; 𝑌|𝑍) > 𝐼(𝑋; 𝑌).
    Chứng minh: dành cho bạn đọc.


3.12. THỐNG KÊ ĐỦ

    Phần này là một ví dụ cho thấy sức mạnh của bất đẳng thức xử lý dữ liệu trong
việc làm rõ một khái niệm quan trọng và đẹp đẽ trong thống kê học, khái niệm
thống kê đầy đủ. Để hiểu rõ khái niệm này trước hết cần hiểu thống kê là gì. Một
thống kê là một hàm số được áp dụng vào dữ liệu. Nói cách khác thống kê chính là
đầu ra (output) của một giải thuật sử dụng dữ liệu như là đầu vào (input). Còn
thống kê đầy đủ đối với một (họ) hàm phân phối là những thống kê chứa đựng mọi
thông tin có thể có được từ dữ liệu về các tham số của (họ) hàm phân phối đó. Nghĩa
là nếu bỏ hết dữ liệu đi, chỉ cần giữa lại các thống kê đầy đủ, vẫn không bị mất
thông tin gì về (họ) hàm phân phối. Sau đây ta sẽ tìm hiểu cách phát biểu khái niệm
thống kê đầy đủ dựa trên các khái niệm của lý thuyết thông tin.
    Giả sử ta có một họ hàm mật độ xác suất {𝑓 (𝑥)} và giả sử 𝑋 là một mẫu thống
kê (sample) từ một phân phối trong họ này. Giả sử 𝑇(𝑋) là một thống kê (hàm của
mẫu) nào đó như trung bình mẫu hay phương sai mẫu. Khi đó 𝜃 → 𝑋 → 𝑇(𝑋) và
theo bất đẳng thức xử lý dữ liệu ta có 𝐼(𝜃; 𝑇(𝑋)) ≤ 𝐼(𝜃; 𝑋). Nếu dấu bằng xảy ra thì
không có thông tin bị mất. Một thống kê 𝑇(𝑋) được gọi là đủ với 𝜃 nếu nó chứa mọi
thông tin trong 𝑋 về 𝜃.
    Định nghĩa: Một hàm 𝑇(𝑋) được gọi là thống kê đủ đối với họ {𝑓 (𝑥)} nếu 𝑋 độc
lập với 𝜃 cho trước 𝑇(𝑋) với bất kỳ phân phối nào trên 𝜃 (nghĩa là 𝜃 → 𝑇(𝑋) → 𝑋).
    Ví dụ 1: Giả sử 𝑋 , 𝑋 , … , 𝑋 là các biến ngẫu nhiên độc lập và cùng phân phối,
𝑋 ∈ {0,1}. Đây là kết quả của thí nghiệm gieo đồng xu với tham số chưa biết là 𝜃 =
𝑃(𝑋 = 1). Cho trước n, số lần xuất hiện mặt ngửa 𝑇(𝑋) = ∑ 𝑋 là một thống kê đủ
cho 𝜃. Để chứng minh 𝑇(𝑋) là thống kê đủ, ta cần chỉ ra:

                                𝜃→       𝑋 → (𝑋 , 𝑋 , … , 𝑋 )

                                                                   nếu ∑    𝑥 =𝑘
    Ta có : 𝑃{(𝑋 , 𝑋 , … , 𝑋 ) = (𝑥 , 𝑥 , … , 𝑥 )| ∑   𝑋 = 𝑘} =
                                                                  0 nếu ngược lại
     Như vậy khi biết 𝑇(𝑋) = 𝑘, xác suất của các chuỗi mà có số lượng mặt ngửa là
𝑘 là bằng nhau và không phụ thuộc vào 𝜃, do đó: 𝜃 → ∑ 𝑋 → (𝑋 , 𝑋 , … , 𝑋 ).
    Chú ý: 𝑃(∑     𝑋 = 𝑘|𝜃) và 𝑃(𝑋 , 𝑋 , … , 𝑋 |𝜃) là phụ thuộc 𝜃.
    Ví dụ 2 : Giả sử X1, X2, …, Xn là dãy biến ngẫu nhiên độc lập và cùng phân phối
chuẩn

                                                                                    43
                                      1
                           𝑓 (𝑥) =         𝑒   (       ) /
                                                             = N(𝜃, 1)
                                     √2𝜋
    Thống kê đủ cho 𝜃 là trung bình mẫu 𝑋 = ∑                    𝑋 . Sinh viên hãy tự kiểm tra là
𝑃(𝑋 , 𝑋 , … , 𝑋 |𝑋 ) không phụ thuộc vào 𝜃.


3.13. BẤT ĐẲNG THỨC FANO

    Giả sử ta biết biến ngẫu nhiên 𝑌 và ta muốn đoán giá trị của một biến ngẫu
nhiên 𝑋 có liên quan đến 𝑌. Bất đẳng thức Fano liên hệ xác suất lỗi của việc đoán
biến ngẫu nhiên 𝑋 với entropy có điều kiện 𝐻(𝑋|𝑌). Kết quả này là rất quan trọng
với việc chứng minh phần ngược của định lý dung lượng kênh của Shannon. Qua
phần bài tập, ta biết rằng entropy có điều kiện của biến ngẫu nhiên 𝑋 cho trước biến
ngẫu nhiên 𝑌 chỉ bằng không khi và chỉ khi 𝑋 là hàm của 𝑌. Do đó ta có thể ước
lượng 𝑋 từ 𝑌 với xác suất lỗi bằng không nếu và chỉ nếu 𝐻(𝑋|𝑌) = 0.
    Mở rộng lập luận này, ta muốn ước lượng 𝑋 với xác suất lỗi nhỏ chỉ nếu entropy
có điều kiện 𝐻(𝑋|𝑌) nhỏ. Bất đẳng thức Fano lượng hóa ý tưởng này. Giả sử ta cần
ước lượng biến ngẫu nhiên 𝑋 nhận giá trị trong 𝒳 với phân phối 𝑝(𝑥). Ta quan sát
một biến ngẫu nhiên 𝑌 liên quan với 𝑋 bởi phân phối có điều kiện 𝑝(𝑦|𝑥). Từ 𝑌, ta
tính hàm 𝑔(𝑌) = 𝑋 , ở đây 𝑋 là một ước lượng của 𝑋 và nhận giá trị trong 𝒳 . Ta
muốn tìm cận của xác suất 𝑋 ≠ 𝑋. Ta thấy rằng 𝑋 → 𝑌 → 𝑋. Ta gọi 𝑃 = 𝑃(𝑋 ≠ 𝑋).
    Bất đẳng thức Fano :
                       𝐻(𝑃 ) + 𝑃 𝑙𝑜𝑔|𝒳| ≥ 𝐻(𝑋|𝑋) ≥ 𝐻(𝑋|𝑌)
    Bất đẳng thức này có dạng yếu là :
                               1 + 𝑃 𝑙𝑜𝑔|𝒳| ≥ 𝐻(𝑋|𝑌)
    Hay
                                           𝐻(𝑋|𝑌) − 1
                                     𝑃 ≥
                                             𝑙𝑜𝑔|𝒳|
    Chứng minh: Trước tiên ta bỏ qua vai trò của 𝑌 và chứng minh bất đẳng thức
đầu tiên. Sau đó ta sẽ sử dụng bất đẳng thức xử lý dữ liệu để chứng minh bất đẳng
thức thứ hai. Ta định nghĩa biến ngẫu nhiên lỗi:

                                  𝐸 = 1 𝑛ế𝑢 𝑋 ≠ 𝑋
                                      0 𝑛ế𝑢 𝑋 = 𝑋
    Sử dụng luật xích để khai triển 𝐻(𝐸, 𝑋|𝑋) theo 2 cách ta có:
                           𝐻 𝐸, 𝑋 𝑋 = H X X + H(E|X, X)

                                      = 𝐻 𝐸 𝑋 + 𝐻(𝑋|𝐸, 𝑋)
                                                   (   )          |𝒳|




                                                                                              44
    Vì có điều kiện làm giảm entropy nên 𝐻 𝐸 𝑋 ≤ 𝐻(𝐸) = 𝐻(𝑃 ). Vì E là hàm của
𝑋 và 𝑋 nên H E X, X = 0. Tương tự, vì 𝐸 là biến ngẫu nhiên nhị phân, 𝐻(𝐸) = 𝐻(𝑃 ).
Số hạng còn lại, 𝐻(𝑋|𝐸, 𝑋), có thể được tính cận như sau:
           𝐻 𝑋 𝐸, 𝑋 = 𝑃(𝐸 = 0)𝐻 𝑋 𝑋, 𝐸 = 0 + 𝑃(𝐸 = 1)𝐻 𝑋 𝑋, 𝐸 = 1
                    ≤ (1 − 𝑃 )0 + 𝑃 𝑙𝑜𝑔|𝒳|
    (vì biết 𝐸 = 0, 𝑋 = 𝑋, và biết 𝐸 = 1, ta có thể lấy cận trên của entropy có điều
kiện bởi log của số lượng output có thể). Tóm lại ta có:
                            𝐻(𝑃 ) + 𝑃 𝑙𝑜𝑔|𝒳| ≥ 𝐻(𝑋|𝑋)
    Vì 𝑋 → 𝑌 → 𝑋 nên 𝐼(𝑋; 𝑌) ≥ 𝐼(𝑋; 𝑋 ), suy ra 𝐻(𝑋|𝑋 ) ≥ 𝐻(𝑋|𝑌). Do đó ta có:
                       𝐻(𝑃 ) + 𝑃 𝑙𝑜𝑔|𝒳| ≥ 𝐻(𝑋|𝑋) ≥ 𝐻(𝑋|𝑌)
    Hệ quả 1 : Giả sử 𝑋 và 𝑌 là các biến ngẫu nhiên, 𝑝 = 𝑃(𝑋 ≠ 𝑌), khi đó :
                             𝐻(𝑝) + 𝑝𝑙𝑜𝑔|𝒳| ≥ 𝐻(𝑋|𝑌)
    Hệ quả 2 : Giả sử 𝑃 = 𝑃(𝑋 ≠ 𝑋) và 𝑋:Y→X, khi đó
                         𝐻(𝑃 ) + 𝑃 log (|𝒳| − 1) ≥ 𝐻(𝑋|𝑌)
    Sinh viên tự tìm hiểu cách CM hai hệ quả trên.




                                                                                 45
    ĐỌC THÊM
    Khái niệm entropy đã được giới thiệu trong nhiệt động lực học, cụ thể là trong
định luật thứ hai của lĩnh vực này. Sau đó, trong cơ học thống kê, Boltzmann đã tìm
ra một liên hệ giữa entropy nhiệt động lực học và logarit của số trạng thái vi mô
trong một trạng thái vĩ mô của hệ thống. Đây là một thành tựu chói lọi của
Boltzmann, đến mức mà phương trình 𝑆 = 𝑘 ln 𝑊 được khắc trên bia mộ ông.
     Vào những năm 1930, Hartley đưa ra một độ đo thông tin cho truyền thông. Độ
đo này về cơ bản dựa trên logarit của kích thước bảng chữ cái. Shannon là người đầu
tiên định nghĩa entropy và thông tin tương hỗ như đã trình bày trong chương này.
Entropy tương đối được Kullback và Leibler định nghĩa và sau đó được Csiszar và
Amari nghiên cứu sâu. Đại lượng này được biết tới dưới nhiều tên khác nhau, chẳng
hạn như khoảng cách Kullback-Leibler, entropy chéo, sự khác nhau về thông tin, …
    Nhiều tính chất đơn giản của các đại lượng kể trên được Shannon phát hiện và
chứng minh. Bất đẳng thức Fano do nhà toán học Fano chứng minh. Khái niệm
thống kê đủ do Fisher định nghĩa. Quan hệ giữa thông tin tương hỗ và tính đủ do
Kullback nghiên cứu. Quan hệ giữa lý thuyết thông tin và nhiệt động lực học đã
được Brillouin và Jaynes phân tích kỹ lưỡng trong các nghiên cứu của họ.




                                                                                46
    BÀI TẬP
    Bài 3.1. Gieo đồng xu
    Một đồng xu cân đối và đồng chất được gieo cho tới khi mặt ngửa đầu tiên xuất
hiện. Gọi X là số lần gieo cần thiết:
   a) Tìm độ đo thông tin entropy H(X) bằng bit. Các biểu thức sau có thể được sử
dụng:
                                       
                     1                                        r
     r
     n 0
            n
                
                    1 r
                         ;              nr
                                       n0
                                                 n
                                                      
                                                          (1  r ) 2
    b) Một biến ngẫu nhiên X được xác định theo phân bố trên. Hãy tìm một chuỗi
“hiệu quả” các câu hỏi có – không theo mẫu “Có phải X được chứa trong tập S?”. So
sánh H(X) với số câu hỏi kỳ vọng cần để xác định X.
    Bài 3.2. Entropy của hàm
   Giả sử X là một biến ngẫu nhiên nhận một số hữu hạn giá trị số. Quan hệ bất
đẳng thức của X và Y là gì nếu:
    a) Y  2 X ?
    b) Y  cos X ?
    Bài 3.3. Entropy của các hàm của biến ngẫu nhiên
    Giả sử X là một biến ngẫu nhiên rời rạc. Hãy chỉ ra rằng entropy của một hàm
của X là nhỏ hơn hoặc bằng entropy của X bằng cách justify các bước sau:
                                                (a)
                              H ( X , g( X )  H ( X )  H (g( X ) | X )
                              (b )
                               H (X )
                                                 (c)
                              H ( X , g ( X ))  H ( g ( X ))  H ( X | g ( X ))
                              (d )
                                H ( g ( X ))

                      Do đó: H ( g ( X ))  H ( X )
    Bài 3.4. Entropy của một tổng
    Giả sử X và Y là các biến ngẫu nhiên nhận các giá trị lần lượt là x1 , x2 ,..., xr và
y1 , y2 ,..., ys . Giả sử Z= X+Y

    a) Hãy chứng minh rằng H(Z|X) = H(Y|X). Đồng thời hãy chỉ ra rằng nếu X, Y
là độc lập thì H (Y )  H ( Z ) và H ( X )  H ( Z ) . Do đó, phép cộng các biến ngẫu nhiên
độc lập làm tăng thêm tính không chắc chắn của thông tin.
   b) Lấy ví dụ về các biến ngẫu nhiên trong trường hợp H(X) > H(Z) và H(Y) >
H(Z)
    c) Với điều kiện gì thì H(Z) = H(X) + H(Y)

                                                                                        47
     Bài 3.5. World series
    Trò chơi world series tạo bởi một chuỗi gồm 7 trận đấu được kết thúc ngay sau
khi một đội nào đó thắng 4 trận. Giả sử X là một biến ngẫu nhiên biểu diễn kết quả
của một world series giữa hai đội A và B; Các giá trị có thể có của X là AAAA,
BABABAB và BBBAAAA. Giả sử Y là số trận đã đấu, có phạm vi từ 4 tới 7. Giả sử A
và B là ngang sức nhau và các trận đấu là độc lập. Hãy tính: H(X), H(Y), H(Y|X) và
H(X|Y)
     Bài 3.6. Thứ tự logic của ý tưởng
    Các ý tưởng được phát triển theo yêu cầu cần thiết và sau đó được tổng quát
hóa nếu cần thiết. Sắp xếp lại các ý tưởng sau, cái mạnh nhất trước, cái hệ quả sau:
     a) Luật xích của I ( X1 , X 2 ,..., X n ; Y ) , luật xích của D( p( x1 ,..., xn ) || q( x1 , x2 ,..., xn )) và
luật xích của H ( X1 , X 2 ,..., X n ) .

     b) D( f || g )  0 , bất đẳng thức Jensen, I ( X ; Y )  0
     Bài 3.7. Entropy cực đại
    Tìm hàm mật độ xác suất p(x) làm cực đại entropy H(X) của một biến ngẫu
nhiên với giá trị nguyên, không âm X thỏa mãn ràng buộc:
              
      EX   np(n)  A (A - một giá trị xác định, A>0)
             n 0

         Hãy tính giá trị cực đại của H(X)?
     Bài 3.8. Giá trị của một câu hỏi
   Giả sử X ~ p(x), x = 1,2,…,m. Chúng ta được cho trước một tập S  {1,2,...,m} .
Chúng ta hỏi liệu X  S hay không và nhận được câu trả lời
        1 if X  S
     Y 
        0 if X  S
         Giả sử rằng Pr( X  S )   . Tìm độ suy giảm không chắc chắn H(X) – H(X|Y)
     Bài 3.9. Câu hỏi ngẫu nhiên
     Một người mong muốn nhận ra đối tượng ngẫu nhiên X ~ p(x). Một câu hỏi Q ~
r(q) được hỏi ngẫu nhiên theo r(q). Câu hỏi này dẫn tới một câu trả lời xác định A =
A(x,q) {a1 , a2 ,...} , giả sử rằng X và Q là độc lập. Khi đó I(X;Q,A) là lượng không
chắc chắn trong X bị loại bỏ bởi cặp câu hỏi – câu trả lời (Q,A)
     a) Chỉ ra rằng I(X;Q,A) = H(A|Q). Hãy giải thích?
   b) Giả sử rằng hai câu hỏi iid Q1, Q2, ~ r(q) được hỏi, và các câu trả lời là A1 và A2.
Hãy chỉ ra rằng hai câu hỏi trên là kém giá trị hơn 2 lần một câu hỏi đơn theo nghĩa:
                           I ( X ; Q1 , A1 , Q2 , A2 )  2I ( X ; Q1 , A1 )


                                                                                                               48
      Bài 3.10. Thông tin tương hỗ của các mặt sấp và các mặt ngửa
    a) Xem xét một lần gieo đồng xu cân đối và đồng chất. Thông tin tương hỗ giữa
mặt trên và mặt dưới của đồng xu là gì?
      b) Tung một con súc sắc 6 mặt. Thông tin tương hỗ giữa mặt trên và mặt trước là
gì?
      Bài 3.11. Entropy có điều kiện bằng 0
    Hãy chỉ ra rằng nếu H(Y|X) = 0, thì Y là một hàm của X (có nghĩa là với mọi x
mà p(x) > 0, chỉ có một giá trị của y sao cho p(x,y) > 0)
      Bài 3.12. Xử lý dữ liệu
      Cho xích Markov X1  X 2  X 3 ...  X n với điều kiện:

     p( x1 , x2 ,..., xn )  p( x1 ) p( x2 | x1 )... p( xn | xn1 ) . Hãy biến đổi I ( X1; X 2 ,..., X n ) thành
biểu thức đơn giản nhất.
      Bài 3.13. Thắt cổ chai
      Giả         sử         X1  X 2  X 3               là      xích   Markov          với           xác        suất
p( x1 , x2 , x3 )  p( x1 ) p( x2 | x1 ) p( x3 | x2 ) ,   trong     đó   x1 {1, 2,..., n} ,         x2 {1, 2,..., k} ,
x3 {1, 2,..., m} , và 𝑘 < 𝑛, 𝑚 > 𝑘 (𝑛, 𝑘, 𝑚 là các số nguyên dương).
   a. Hãy chỉ ra sự phụ thuộc giữa X1 và X3 bị giới hạn bởi thắt cổ chai bằng việc
chứng minh rằng I ( X1; X 3 )  log k

      b. Tính biểu thức I ( X1 ; X 3 ) với k=1, và kết luận rằng trong trường hợp này thắt
cổ chai làm triệt tiêu sự phụ thuộc.


                                                                                           X31
                                                                                           +



                                                                                               X21
                                                                                               +




                                                                                               X11
                                                                                               +




                                      Hình 3.5. Thắt cổ chai ở làn đường bên phải




                                                                                                                    49
                        Hình 3.6. Thắt cổ chai do đường đang được sửa

   Một ví dụ về thắt cổ chai là lưu lượng giao thông qua quãng đường đang sửa
chữa sẽ bị hạn chế (xem Hình 3.5 và Hình 3.6).
    Bài 3.14. Fano
    Cho bảng phân phối xác suất hợp của (X,Y) như sau:
                                    Y
                              X            a        b            c

                                    1           1       1            1
                                                6       12           12
                                    2          1         1           1
                                               12        6           12
                                    3          1        1             1
                                               12       12            6


                                                                         
    Cho X (Y ) là một ước lượng của 𝑋 (dựa vào 𝑌) và cho Pe  Pr( X (Y )  X )
                                                             
    a. Hãy tìm xác suất cực tiểu của ước lượng lỗi X (Y ) và Pe tương ứng

    b. Hãy tính bất đẳng thức Fano cho vấn đề này và so sánh
    Bài 3.15. Entropy rời rạc
    Giả sử 𝑋 và 𝑌 là hai biến ngẫu nhiên nguyên và độc lập. Giả sử 𝑋 được phân bố
đều trong {1,2, … ,8}, và P{Y=k} = 2-k , k = 1,2,3,…
    a. Tính H(X)
    b. Tính H(Y)
    c. Tính H(X + Y,X - Y)
    Bài 3.16. Metric
    Một hàm 𝜌(𝑥, 𝑦) là một metric nếu với mọi 𝑥, 𝑦
      (1) 𝜌(𝑥, 𝑦) ≥ 0
      (2) 𝜌(𝑥, 𝑦) = 𝜌(𝑦, 𝑥)
      (3) 𝜌(𝑥, 𝑦) = 0 nếu và chỉ nếu 𝑥 = 𝑦


                                                                                 50
       (4) 𝜌(𝑥, 𝑦) + 𝜌(𝑦, 𝑧) ≥ 𝜌(𝑥, 𝑧)

     a) Ta định nghĩa 𝜌(𝑋, 𝑌) = 𝐻(𝑋|𝑌) + 𝐻(𝑌|𝑋). Chứng minh rằng 𝜌(𝑋, 𝑌) thỏa mãn
các đặc điểm (1), (2) và (4). Chú ý: nếu ta bổ sung ý 𝑋 = 𝑌 nếu có ánh xạ 1-1 biến 𝑋 thành
𝑌 thì đặc điểm (3) cũng được thỏa mãn và 𝜌(𝑋, 𝑌) là một metric.
    b) Chứng minh rằng 𝜌(𝑋, 𝑌) có thể được biểu diễn
                           𝜌(𝑋, 𝑌) = 𝐻(𝑋) + 𝐻(𝑌) − 2𝐼(𝑋; 𝑌)
                                   = 𝐻(𝑋, 𝑌) − 𝐼(𝑋; 𝑌)
                                   = 2𝐻(𝑋, 𝑌) − 𝐻(𝑋) − 𝐻(𝑌)

    Chú ý câu b) này có 3 ý nhỏ (đẳng thức) cần chứng minh.




                                                                                       51
Chương 4
TÍNH CHẤT TIỆM CẬN PHÂN PHỐI ĐỀU (AEP)


    Tính chất tiệm cận phân hoạch đều (asymptotic equipartition 3 property (AEP))
trong lý thuyết thông tin tương tự với luật số lớn trong lý thuyết xác suất. AEP là
một hệ quả trực tiếp của luật số lớn yếu. Luật số lớn nói rằng với các biến ngẫu
nhiên độc lập và cùng phân phối, ∑ 𝑋 gần tới giá trị kỳ vọng EX với n đủ lớn.
AEP thì lại nói rằng 𝑙𝑜𝑔                             gần tới entropy H, trong đó 𝑝(𝑋 , 𝑋 , … , 𝑋 ) là
                                   (   ,   ,…,   )
xác suất quan sát được dãy 𝑋 , 𝑋 , … , 𝑋 . Do đó, xác suất 𝑝(𝑋 , 𝑋 , … , 𝑋 ) sẽ gần tới 2-
nH
  .
    Tính chất này cho phép ta chia tập các chuỗi có thể có thành hai tập: tập điển
hình, trong đó entropy mẫu gần tới entropy thực, và tập không điển hình, chứa các
chuỗi còn lại. Hầu hết sự chú ý của ta sẽ tập trung vào tập điển hình. Bất kỳ tính chất
nào đã được chứng minh cho tập điển hình sẽ đúng với xác suất cao và sẽ xác định
hành vi trung bình của một mẫu lớn.
    Xét một ví dụ như sau. Giả sử biến ngẫu nhiên X thuộc {0,1} có hàm hàm mật độ
xác suất p(x) xác định bởi P(X=1) = p và P(X=0) = q. Nếu X 1, X2, …, Xn là dãy biến
ngẫu nhiên độc lập và cùng phân phối p(x) thì xác suất của dãy x 1, x2, …, xn là
∏ 𝑝(𝑥 ). Ví dụ, xác suất của dãy (1, 0, 1, 1, 0, 1) là p 4q2. Rõ ràng, tất cả 2n dãy độ dài
n có cùng xác suất là không đúng.
     Tuy nhiên, ta có thể đoán xác suất của dãy mà thực tế ta quan sát được. Ta
muốn biết xác suất 𝑝(𝑋 , 𝑋 , … , 𝑋 ) của các outcome 𝑋 , … , 𝑋 , ở đây 𝑋 , 𝑋 , … , 𝑋 là
độc lập cùng phân phối p(x). Đây là sự tự tham chiếu, tuy nhiên lại được định nghĩa
tốt. Rõ ràng, ta đang muốn biết xác suất của một sự kiện được sinh ra theo cùng
phân phối xác suất. Ở đây, hóa ra 𝑝(𝑋 , 𝑋 , … , 𝑋 ) gần tới 2-nH với xác suất cao.
    Ta tổng kết ý này bằng cách nói “hầu hết mọi biến cố là đồng khả năng”. Điều
này tương đương với:
                                                                         ( ∓ )
                       𝑃{(𝑋 , 𝑋 , … , 𝑋 ): 𝑝(𝑋 , 𝑋 , … , 𝑋 ) = 2                 }≈1
     nếu 𝑋 , 𝑋 , … , 𝑋 là độc lập và cùng phân phối 𝑝(𝑥).
    Hội tụ của biến ngẫu nhiên: Cho chuỗi biến ngẫu nhiên 𝑋 , 𝑋 , …, ta nói rằng
dãy 𝑋 , 𝑋 , … hội tụ đến một biến ngẫu nhiên 𝑋:
     (1) Theo xác suất nếu với mọi 𝜀 > 0, 𝑃(|𝑋 − 𝑋| > 𝜀) → 0
     (2) Theo bình phương trung bình nếu 𝐸(𝑋 − 𝑋) → 0
     (3) Với xác suất bằng 1 (hầu như chắc chắn) nếu 𝑃{𝑙𝑖𝑚              →   𝑋 = 𝑋} = 1


3
 Thuật ngữ phân hoạch đều (equipartition) được dùng để mô tả tính chất các thành viên của tập điển hình có
xác suất xấp xỉ bằng nhau

                                                                                                             52
4.1. TÍNH CHẤT TIỆM CẬN PHÂN HOẠCH ĐỀU

    Định lý: Nếu 𝑋 , 𝑋 , … , 𝑋 là độc lập và cùng phân phối p(x) thì
    − 𝑙𝑜𝑔𝑝(𝑋 , 𝑋 , … , 𝑋 ) → 𝐻(𝑋) theo xác suất.

    Chứng minh: Áp dụng luật số lớn

                1                         1
               − 𝑙𝑜𝑔𝑝(𝑋 , 𝑋 , … , 𝑋 ) = −                                   𝑙𝑜𝑔𝑝(𝑋 )
                𝑛                         𝑛
                                                            1       1
                                                        =             𝑙𝑜𝑔
                                                            𝑛     𝑝(𝑋 )
                                                                  1
                                                        → 𝐸 𝑙𝑜𝑔        = 𝐻(𝑋) theo xác suất.
                                                                𝑝(𝑋 )
                                                            ( )
    Tập điển hình: Tập điển hình 𝐴                                theo phân phối p(x) là tập các chuỗi (x1, x2,
…, xn) thuộc Xn với tính chất:
                                    ( ( )        )                                               ( ( )    )
                           2                          ≤ 𝑝(𝑥 , 𝑥 , … , 𝑥 ) ≤ 2

    Các tính chất của tập điển hình:
                                        ( )
    (1) Nếu 𝑥 , 𝑥 , … , 𝑥 ∈ 𝐴                   thì 𝐻(𝑋) − 𝜀 ≤ − 𝑙𝑜𝑔𝑝(𝑋 , 𝑋 , … , 𝑋 ) ≤ 𝐻(𝑋) + 𝜀
            ( )
    (2) 𝑃 𝐴       > 1 − 𝜀 với n đủ lớn
         ( )
    (3) 𝐴      ≤2      ( ( )    )
                                    , trong đó |A| thể hiện số phần tử của tập hợp A
         ( )
    (4) 𝐴      ≥ (1 − 𝜀)2       ( ( )           )
                                                     với n đủ lớn

    Các tính chất này cho ta thấy: xác suất của tập điển hình là gần bằng 1, mọi phần
tử của tập điển hình là gần như đồng khả năng, và số phần tử của tập điển hình là
gần bằng 2nH.
    Chứng minh: Từ định nghĩa tập điển hình ta dễ dành suy ra được tính chất (1).
    Từ định lý về AEP ta cũng dễ dàng suy ra được tính chất (2).
    Để chứng minh tính chất (3), ta biến đổi như sau:
                                                                                    ( ( )    )            ( ( )    )       ( )
            1=          𝑝(𝑥) ≥                      𝑝(𝑥) ≥                  2                    =2                    𝐴
                  ∈𝒳                        ( )                       ( )
                                        ∈                         ∈

    Từ đó suy ra được (3).
    Để chứng minh tính chất (4), xuất phát từ tính chất (2), ta biến đổi như sau:
                          ( )                                                        ( ( )       )         ( ( )       )    ( )
         1−𝜀 <𝑃 𝐴                   =                 𝑝(𝑥) ≤                    2                    =2                    𝐴
                                                ( )                       ( )
                                            ∈                         ∈

    Từ đó ta suy ra được (4).

                                                                                                                                  53
    Ví dụ về tập điển hình:
     Xét dãy biến ngẫu nhiên độc lập và cùng phân phối nhị thức với n = 100 và p1 =
0.1. Hình 4.1 chỉ ra 15 mẫu của dãy biến ngẫu nhiên này.



          𝑥                                                                         𝑙𝑜𝑔𝑝(𝑥 ))




Hình 4.1. Phần trên là 15 xâu được lấy mẫu từ X100 trong đó p1 = 0.1 và p0 = 0.9. Phần dưới là xâu xác
suất lớn nhất và xác suất bé nhất. Cột bên phải cho biết xác suất log của các xâu tương ứng, các giá trị
                         này không chênh lệch nhiều lắm với H(X100) = 46.9 bit.

    Xác suất của một xâu xn chứa r ký tự ‘1’ và n-r ký tự ‘0’ là:
                                      𝑝(𝑥 ) = 𝑝 (1 − 𝑝 )
    Số lượng xâu chứa r ký tự ‘1’ là 𝐶 . Vì vậy r có phân phối nhị thức là:
                                     𝑞(𝑟) = 𝐶 𝑝 (1 − 𝑝 )
    Các hàm này được chỉ ra trong Hình 2. Giá trị trung bình của r là np1, độ lêch
chuẩn của r là 𝑛𝑝 (1 − 𝑝 ). Với n = 100, 𝑟~𝑛𝑝 ± 𝑛𝑝 (1 − 𝑝 ) ≅ 10 ± 3.
    Nếu n = 1000, 𝑟 ≅ 100 ± 10. Chú ý là khi n tăng, phân phối xác suất của r trở nên
tập trung hơn theo nghĩa giá trị của r tăng theo n trong khi độ lệch chuẩn của r chỉ
tăng theo √𝑛. Khả năng r rơi vào khoảng nhỏ với xác suất cao cho thấy rằng, với xác
suất cao, biến cố x rơi vào tập con nhỏ gọi là tập điển hình.




                                                                                                      54
           𝐶




           𝑝(𝑥)




       𝑙𝑜𝑔𝑝(𝑥)




         𝑞(𝑥)




Hình 4.2. Đồ thị của 𝐂𝐧𝐫 , p(xn), logp(xn), q(xn) với n = 100 và n = 1000. Trục ngang là giá trị của r. Trên đồ
                                                                         (𝟏𝟎𝟎)    (𝟏𝟎𝟎𝟎)
                        thị logp(xn) đoạn có nhãn T là tập điển hình 𝐀 𝟎.𝟐𝟗 và 𝐀 𝟎.𝟎𝟗 .



4.2. HỆ QUẢ CỦA AEP: NÉN DỮ LIỆU

    Giả sử 𝑋 , 𝑋 , … , 𝑋 là các biến ngẫu nhiên độc lập và cùng phân phối p(x). Ta
muốn tìm các mô tả ngắn cho các chuỗi biến ngẫu nhiên đó. Ta chia các chuỗi trong
                                    ( )
Xn ra thành hai tập: tập điển hình 𝐴 và phần còn lại (Hình 4.3).



                                                                          Tập không điển
                                                                               hình



                                                                         Tập điển hình




                                 Hình 4.3. Tập điển hình và mã hóa nguồn


                                                                                                            55
     Ta sắp xếp các phần tử trong mỗi tập theo một thứ tự nào đó (chẳng hạn thứ tự
                                                         ( )
từ điển). Sau đó ta có thể biểu diễn mỗi chuỗi của 𝐴         bằng chỉ số của chuỗi đó
                                                              ( )
trong tập hợp này. Vì có không quá 2    (     )
                                                chuỗi trong 𝐴 , việc đánh chỉ số cần
không quá 𝑛(𝐻 + 𝜀) + 1 bit. Thêm tiền tố 0 cho tất cả các chỉ số này, khi đó độ dài
                            ( )
chỉ số của các chuỗi trong 𝐴 không quá 𝑛(𝐻 + 𝜀) + 2 bit. Lập luận tương tự, ta có
                                          ( )
thể đánh chỉ số các chuỗi không thuộc 𝐴 bằng cách dùng không quá 𝑛𝑙𝑜𝑔|𝒳| + 1
bit. Thêm tiền tố 1 cho các chỉ số đó ta được một mã cho tất cả các chuỗi trong X n
(Hình 4.4).




                         Hình 4.4. Mã hóa nguồn sử dụng tập điển hình

      Cách mã hóa trên có các tính chất sau:
    - Mã là ánh xạ 1-1 và việc giải mã là dễ dàng. Bit đầu tiên đóng vai trò bit cờ
cho biết độ dài từ mã sau nó.
    - Ta đã sử dụng một cách đánh số brute-force cho tập điển hình mà không cần
tính đến thực tế là số phần tử trong tập điển hình nhỏ hơn số phần tử trong 𝒳 n. Thật
ngạc nhiên, cách mà ta đã làm là đủ tốt để đạt được một mô tả hiệu quả.
    - Các chuỗi điển hình có mô tả ngắn xấp xỉ nH.
      Ta sử dụng ký hiệu xn để mô tả chuỗi 𝑥 , 𝑥 , … , 𝑥 . Gọi l(xn) là độ dài từ mã
                                                  ( )
tương ứng với xn. Nếu n đủ lớn sao cho 𝑃 𝐴              ≥ 1 − 𝜀, độ dài kỳ vọng của từ mã
là:

                               𝐸 𝑙(𝑋 ) =         𝑝(𝑥 )𝑙(𝑥 )

    Định lý: Giả sử Xn là dãy biến ngẫu nhiên độc lập và cùng phân phối p(x). Giả
sử 𝜀 > 0. Khi đó tồn tại một mã ánh xạ các chuỗi xn dài n thành các xâu nhị phân sao
cho ánh xạ là 1-1 và:
                                     1
                                 𝐸     𝑙(𝑋 ) ≤ 𝐻(𝑋) + 𝜀
                                     𝑛
      Do đó, ta có thể biểu diễn các chuỗi Xn sử dụng trung bình nH(X) bit.
      Chứng minh: Ta có



                                                                                      56
            𝐸 𝑙(𝑋 ) =          𝑝(𝑥 )𝑙(𝑥 ) =                      𝑝(𝑥 )𝑙(𝑥 ) +                    𝑝(𝑥 )𝑙(𝑥 )
                                                           ( )                             ( )
                                                      ∈                                ∈

                                                ( )                                                            ( )
     Theo lập luận ở trên, với 𝑥 ∈ 𝐴                  ta có: 𝑙(𝑥) ≤ 𝑛(𝐻 + 𝜀) + 2 và với 𝑥 ∈ 𝐴                        ta
có 𝑙(𝑥) ≤ 𝑛𝑙𝑜𝑔|𝒳| + 2. Do đó:

            𝐸 𝑙(𝑋 ) ≤                𝑝(𝑥 )[𝑛(𝐻 + 𝜀) + 2] +                           𝑝(𝑥 )[𝑛𝑙𝑜𝑔|𝒳| + 2]
                               ( )                                             ( )
                           ∈                                               ∈

                               ( )                                   ( )
                     =𝑃 𝐴             [𝑛(𝐻 + 𝜀) + 2] + 𝑃 𝐴                     [𝑛𝑙𝑜𝑔|𝒳| + 2]
                                                                                           ( )
      Theo tính chất của tập điển hình, với n đủ lớn ta có 𝑃 𝐴                                     < 𝜀. Bên cạnh đó
      ( )
𝑃 𝐴         ≤ 1. Do đó ta có:

                          𝐸 𝑙(𝑋 ) ≤ [𝑛(𝐻 + 𝜀) + 2] + 𝜀[𝑛𝑙𝑜𝑔|𝒳| + 2]
      Suy ra
                          1                2            2𝜀
                      𝐸     𝑙(𝑋 ) ≤ 𝐻 + 𝜀 + + 𝜀𝑙𝑜𝑔|𝒳| +    = 𝐻 + 𝜀′
                          𝑛                𝑛            𝑛

      Trong đó ε = ε + + ϵlog|𝒳| +                    là nhỏ tùy ý khi 𝜀 đủ nhỏ và n đủ lớn. Ta có
điều phải chứng minh.


4.3. CÁC TẬP XÁC SUẤT CAO VÀ TẬP ĐIỂN HÌNH
                                ( )                    ( )
    Từ định nghĩa của 𝐴 , ta dễ thấy 𝐴 là tập khá nhỏ mà chứa hầu hết xác suất.
Tuy nhiên, đó là tập nhỏ nhất hay chưa thì không rõ lắm. Ta sẽ chứng minh rằng tập
điển hình có gần như cùng số phần tử với tập nhỏ nhất.
      Định nghĩa: 𝑎 =̇ 𝑏 có nghĩa 𝑙𝑜𝑔                      → 0 khi 𝑛 → ∞

      Tập nhỏ nhất: Giả sử 𝑋 , 𝑋 , … , 𝑋 là các biến ngẫu nhiên độc lập và cùng phân
                                         ( )                                                       ( )
phối p(x). Với 𝛿 < 1/2, giả sử 𝐵               ⊂ X là tập nhỏ nhất sao cho 𝑃 𝐵                           ≥ 1 − 𝛿. Khi
đó:
                                                     ( )
                                                 𝐵         =̇ 2


      BÀI TẬP
      Bài 4.1. Bất đẳng thức Markov và bất đẳng thức Chebyshev
      a) Bất đẳng thức Markov
      Chứng minh rằng
                                                                   𝐸𝑋
                                               Pr {𝑋 ≥ 𝑡} ≤
                                                                    𝑡

                                                                                                                     57
    trong đó X là biến ngẫu nhiên không âm và t là một số dương tùy ý. Lấy một ví
dụ về trường hợp dấu bằng xảy ra.
    b) Bất đẳng thức Chebyshev
   Giả sử Y là biến ngẫu nhiên với giá trị trung bình 𝜇 và Phương sai 𝜎 . Chứng
minh rằng:
                                                       𝜎
                                  Pr {|𝑌 − 𝜇| > 𝜖} ≤
                                                       𝜖
    trong đó 𝜖 > 0.
    c) Luật số lớn yếu
    Giả sử Z1, …, Zn là dãy biến ngẫu nhiên độc lập và cùng phân phối với giá trị
trung bình 𝜇 và phương sai 𝜎 . Gọi 𝑍̅ = ∑ 𝑍 là trung bình mẫu. Chứng minh :
                                                       𝜎
                                  Pr{|𝑍̅ − 𝜇| > 𝜖} ≤
                                                       𝑛𝜖
    Do đó, Pr{|𝑍̅ − 𝜇| > 𝜖} → 0 khi 𝑛 → ∞. Đây chính là luật số lớn yếu.
    Bài 4.2. AEP và thông tin tương hỗ
     Giả sử (Xi, Yi) là dãy biến ngẫu nhiên độc lập và cùng phân phối p(x,y). Hãy tính
giới hạn của
                                    1     𝑝(𝑋 )𝑝(𝑌 )
                                      𝑙𝑜𝑔
                                    𝑛      𝑝(𝑋 , 𝑌 )
    Bài 4.3. Cắt bánh
    Một chiếc bánh được cắt ngẫu nhiên nhiều lần theo phương pháp sau:
                                           2 1                  3
                              𝑐ắ𝑡 𝑡ℎ𝑒𝑜 𝑡ỉ 𝑙ệ ,   𝑣ớ𝑖 𝑥á𝑐 𝑠𝑢ấ𝑡
                         𝑃=                3   3                4
                                           2 3                  1
                            𝑐ắ𝑡 𝑡ℎ𝑒𝑜 𝑡ỉ 𝑙ệ   ,   𝑣ớ𝑖 𝑥á𝑐 𝑠𝑢ấ𝑡
                                           5 5                  4
    Sau n lần cắt thì kích thước miếng bánh còn lại như thế nào?
    Bài 4.4. Tính tập điển hình
    Xét dãy biến ngẫu nhiên độc lập và cùng phân phối X1, X2, …, Xn, trong đó xác
suất để Xi = 1 là 0.6 (và do đó xác suất để Xi = 0 là 0.4).
    a) Tính H(X)
                                                                    ( )
    b) Với n = 25 và 𝜀 = 0.1, những chuỗi nào thuộc tập điển hình 𝐴 ? Xác suất của
tập điển hình là bao nhiêu ? Kích thước của tập điển hình là bao nhiêu ? (Để làm câu
này bạn cần sử dụng thông tin trong bảng dưới đây, bao gồm số lượng và xác suất
của các chuỗi gồm k số 1, 0 ≤ 𝑘 ≤ 25).
    c) Có bao nhiêu phần tử trong tập nhỏ nhất mà xác suất là 0.9 ?
    d) Có bao nhiêu phần tử trong phần giao của hai tập trong phần b và phần c ?
Xác suất của tập giao này là bao nhiêu ?

                                                                                   58
                                Hình 4.5. Bảng của bài tập 4

    Bài 4.5. Tập hợp định nghĩa bằng xác suất
    Giả sử X1,X2,… là dãy biến ngẫu nhiên rời rạc với entropy H(X). Giả sử
                           𝐶 (𝑡) = {𝑥 ∈ 𝒳 : 𝑝(𝑥 ) ≥ 2          }
    biểu diễn tập các chuỗi dài n có xác suất ≥ 2        .
    a) Chứng minh |𝐶 (𝑡)| ≤ 2 .
    b) Với giá trị nào của t thì 𝑃({𝑋 ∈ 𝐶 (𝑡)}) → 1 ?
    Bài 4.6. AEP và mã hóa nguồn
    Một nguồn không nhớ rời rạc phát ra một chuỗi các chữ số nhị phân độc lập với
xác suất p(1) = 0.005 và p(0) = 0.995. Mỗi lần có 100 chữ số được lấy và một từ mã nhị
phân được cung cấp cho mỗi dãy 100 chữ số chứa không quá ba chữ số 1.
    a) Giả sử rằng tất cả các từ mã có cùng độ dài, tìm độ dài tối thiểu cần để cung
       cấp từ mã cho các dãy với không quá 3 chữ số 1.

                                                                                   59
    b) Tính xác suất quan sát được một chuỗi nguồn mà được gán từ mã nào.
    c) Áp dụng bất đẳng thức Chebyshev để bao xác suất quan sát được một chuỗi
       nguồn mà chưa được gán từ mã nào. So sánh cận này với xác suất thực tính
       ở câu b.
    Bài 4.7. Kích thước hộp ngẫu nhiên
    Một hộp chữ nhật n chiều có các kích thước X1,X2, …, Xn cần được xây dựng.
Thể tích của hộp là 𝑉 = ∏ 𝑋 . Độ dài cạnh l của một hình khối n có cùng thể tích
                           /
với hộp ngẫu nhiên là 𝑙 = 𝑉 . Giả sử 𝑋 , 𝑋 , … là dãy biến ngẫu nhiên độc lập và
                                                               /
cùng phân phối đều trên khoảng đơn vị [0, 1]. Tính 𝑙𝑖𝑚 → 𝑉       và so sánh với
(𝐸𝑉 ) . Rõ ràng, độ dài cạnh kỳ vọng không thể hiện ý tưởng thể tích của hộp. Giá
trị trung bình hình học, hơn là giá trị trung bình số học, mô tả hành vi của các tích.




                                                                                   60
Chương 5
TỈ LỆ ENTROPY CỦA QUÁ TRÌNH NGẪU NHIÊN


     Tính chất tiệm cận phân phối đều được mô tả trong Chương 4 cho thấy 𝑛𝐻(𝑋)
bits đủ để mô tả 𝑛 biến ngẫu nhiên độc lập và phân phối giống nhau (i.i.d). Nhưng
nếu các biến ngẫu nhiêu này phụ thuộc lẫn nhau thì kết quả thay đổi thế nào? Cụ thể
hơn, nếu các biến ngẫu nhiêu tạo thành một quá trình dừng? Chúng ta sẽ chỉ ra rằng,
giống như trong trường hợp độc lập và cùng phân phối, giá trị của 𝐻(𝑋 , 𝑋 , . . . , 𝑋 )
tăng (tiệm cận) tuyến tính theo 𝑛 với tỉ lệ là 𝐻(𝒳), còn được gọi là tỉ lệ entropy. Trong
các Chương 6 và 9, ta sẽ thấy là 𝐻(𝒳) còn có ý nghĩa là hiệu suất nén dữ liệu tốt nhất
có thể đạt được.


5.1. CHUỖI MARKOV

     Một quá trình ngẫu nhiên {𝑋 } là một dãy biến ngẫu nhiên có chỉ số. Nói chung,
có thể có sự phụ thuộc bất kì giữa các biến ngẫu nhiên này. Quá trình này được đặc
trưng bởi hàm xác suất:
      𝑃{(𝑋 , 𝑋 , . . . , 𝑋 ) = (𝑥 , 𝑥 , . . . , 𝑥 )} = 𝑝(𝑥 , 𝑥 , . . . , 𝑥 ), (𝑥 , 𝑥 , . . . , 𝑥 ) ∈ 𝒳 với 𝑛 =
1,2, . ..


    Định nghĩa: Một quá trình ngẫu nhiên được gọi là dừng nếu hàm phân phối
phụ thuộc của bất kì tập con liên tiếp nào của dãy biến ngẫu nhiên là không thay đổi
theo vị trí bắt đầu của chỉ số thời gian. Cụ thể là:
         𝑃(𝑋 = 𝑥 , 𝑋 = 𝑥 , . . . , 𝑋 = 𝑥 ) = 𝑃(𝑋              = 𝑥 ,𝑋       = 𝑥 ,...,𝑋        =𝑥 )
      với mọi giá trị của 𝑛 và 𝑙 với 𝑥 , 𝑥 , . . . , 𝑥 ∈ 𝒳.
    Một ví dụ đơn giản về quá trình ngẫu nhiên với độ phụ thuộc có giá trị một là
dãy mà mỗi biến ngẫu nhiên chỉ phụ thuộc vào biến ngẫu nhiên đứng ngay trước nó
và độc lập có điều kiện với tất các các biến ngẫu nhiên khác đứng trước nó. Dãy này
được gọi là dãy Markov.


   Định nghĩa: Một quá trình ngẫu nhiên rời rạc 𝑋 , 𝑋 , . .. được gọi là một chuỗi
Markov hoặc là một quá trình Markov nếu với mỗi 𝑛 = 1,2, . . .,
                          𝑃(𝑋         = 𝑥 |𝑋 = 𝑛, 𝑋 = 𝑥 ,...,𝑋 = 𝑥 )
                                      = 𝑃(𝑋  = 𝑥 |𝑋 = 𝑥 )
      với mọi giá trị 𝑥 , 𝑥 , . . . , 𝑥 , 𝑥     ∈ 𝒳.
     Trong trường hợp này, hàm phân phối hợp có thể được viết lại như sau:


                                                                                                           61
                  𝑝(𝑥 , 𝑥 , . . . , 𝑥 ) = 𝑝(𝑥 )𝑝(𝑥 |𝑥 )𝑝(𝑥 |𝑥 ). . . 𝑝(𝑥 |𝑥   ).


    Định nghĩa: Chuỗi Markov được gọi là không phụ thuộc thời gian nếu xác suất
có điều kiện 𝑝(𝑥 |𝑥 ) không phụ thuộc vào 𝑛; cụ thể là, với 𝑛 = 1,2, . ..
                𝑃{𝑋    = 𝑏|𝑋 = 𝑎} = 𝑃𝑟{𝑋 = 𝑏|𝑋 = 𝑎} 𝑣ớ𝑖 𝑚ọ𝑖 𝑎, 𝑏 ∈ 𝒳.


    Nếu {𝑋 } là một chuỗi Markov, 𝑋 được gọi là trạng thái tại thời điểm 𝑛. Một
chuỗi Markov không phụ thuộc thời gian được đặc trưng bởi trạng thái bắt đầu và
một ma trận xác suất chuyển 𝑃 = [𝑃 ], 𝑖, 𝑗 ∈ {1,2, . . . , 𝑚}, với 𝑃 = 𝑃{𝑋 = 𝑗|𝑋 = 𝑖}.
    Nếu có thể đi từ một trạng thái đến một trạng thái bất kì khác trong một số hữu
hạn bước và với xác suất dương, thì chuỗi Markov gọi là tối giản. Nếu ước chung lớn
nhất của các độ dài từ một trạng thái bất kì đi đến chính nó là 1 thì chuỗi Markov
được gọi là phi chu kì.
   Nếu hàm phân phối xác suất của biến ngẫu nhiên tại thời điểm 𝑛 là 𝑝(𝑥 ), hàm
phân phối xác suất tại thời điểm 𝑛 + 1 là
                                 𝑝(𝑥    )=∑       𝑝(𝑥 )𝑃        .


    Một phân phối trên các trạng thái sao cho phân phối tại thời điểm 𝑛 + 1 giống
với phân phối tại thời điểm 𝑛 được gọi là một phân phối dừng. Cách gọi này gắn với
việc nếu trạng thái bắt đầu của chuỗi Markov là do phân phối dừng sinh ra, thì
chuỗi Markov tạo nên một quá trình dừng.
    Nếu một chuỗi Markov hữu hạn trạng thái là tối giản và phi chu kì thì phân
phối dừng là duy nhất, và cho dù trạng thái bắt đầu tuân theo phân phối nào thì
phân phối của 𝑋 sẽ trở thành phân phối dừng khi 𝑛 → ∞.
    Ví dụ Cho một chuỗi Markov với 2 trạng thái và ma trận chuyển trạng thái
                                            1−𝛼      𝛼
                                       𝑃=
                                            𝛽        1−𝛽
    được mô tả ở Hình 5.1.




                                                                                   62
                           Hình 5.1. Chuỗi Markov hai trạng thái




    Giả sử phân phối dừng được thể hiện bởi vector 𝜇 mà các thành phần là các xác
suất dừng của trạng thái 1 và 2, theo thứ tự. Từ đó, xác suất dừng có thể được tìm
thấy bằng cách giải phương trình 𝜇𝑃 = 𝜇 hoặc, một cách đơn giản hơn, bằng cách
cân bằng các xác suất. Đối với phân phối dừng, xác suất của đồ thị thể hiện ở bất kì
tập phân cách nào trên đồ thị chuyển trạng thái đều có giá trị là 0. Áp dụng tính chất
này cho hình 1, chúng ta nhận được
                                          𝜇 𝛼 = 𝜇 𝛽.
    Vì 𝜇 + 𝜇 = 1, phân phối dừng là

                                     𝜇 =        ,𝜇 =        .



     Nếu chuỗi Markov có trạng thái bắt đầu được lấy từ một phân phối dừng, thì
kết quả sẽ nhận được là một quá trình dừng. Entropy của trạng thái 𝑋 tại thời điểm
n là

                                   𝐻(𝑋 ) = 𝐻(          ,    ).



    Tuy nhiên đây không phải là tỉ lệ mà entropy 𝐻(𝑋 , 𝑋 , . . . , 𝑋 ) tăng. Chúng ta
cần phải tính đến sự phụ thuộc giữa các 𝑋 .


5.2. TỈ LỆ ENTROPY

    Nếu chúng ta có một dãy 𝑛 biến ngẫu nhiên, câu hỏi thông thường sẽ là: Sự
thay đổi của entropy diễn ra như thế nào khi 𝑛 tăng? Tỉ lệ tăng entropy này được
định nghĩa như sau:


   Định nghĩa: Tỉ lệ entropy (entropy rate) của một quá trình ngẫu nhiên {𝑋 }
được định nghĩa là


                                                                                   63
                                𝐻(𝒳) = lim 𝐻(𝑋 , 𝑋 , . . . , 𝑋 )
                                                 →

    nếu giới hạn này tồn tại.


    Sau đây là một số quá trình ngẫu nhiên và các tỉ lệ entropy tương ứng.
      1. Máy chữ Xét trường hợp một máy chữ có 𝑚 kí tự có khả năng bằng nhau.
Số lượng các dãy có độ dài 𝑛 là 𝑚 , và tất cả đều có xác suất bằng nhau. Do đó
𝐻(𝑋 , 𝑋 , . . . , 𝑋 ) = log𝑚 và tỉ lệ entropy là 𝐻(𝒳) = log𝑚 bit trên một kí tự.
      2. 𝑋 , 𝑋 , . .. là các biến ngẫu nhiên độc lập và cùng phân phối. Ta có:
                                        (    ,       ,...,   )           (    )
                           𝐻(𝒳) = lim                            = lim            = 𝐻(𝑋 ),

    giá trị này bằng với tỉ lệ entropy cho từng symbol.
      3. Dãy các biên ngẫu nhiên độc lập nhưng không cùng phân phối. Trong trường
hợp này,
                                𝐻(𝑋 , 𝑋 , . . . . , 𝑋 ) = ∑              𝐻(𝑋 ),
     nhưng các 𝐻(𝑋 ) không bằng nhau. Chúng ta có thể chọn dãy các phân phối
𝑋 , 𝑋 , . .. sao cho giới hạn của ∑ 𝐻(𝑋 ) không tồn tại. Ví dụ chúng ta có thể chọn
một dãy các biến nhị phân ngẫu nhiêu sao cho 𝑝 = 𝑃(𝑋 = 1) không là hằng số
nhưng là một hàm số của i như sau
                               0.5 nếu 2k < log log 𝑖 ≤ 2𝑘 + 1,
                           𝑝 = 0   nếu 2k + 1 < log log 𝑖 ≤ 2𝑘 + 2

    với 𝑘 = 0,1,2, . ...
    Khi đó sẽ có các dãy biến ngẫu nhiên dài tùy ý mà trong đó 𝐻(𝑋 ) = 1, và tiếp
theo là các đoạn dài hơn (theo hàm mũ) mà 𝐻(𝑋 ) = 0. Do đó, trung bình của 𝐻(𝑋 )
sẽ không cố định mà dao động giữa 0 và 1, và 𝐻(𝒳) sẽ không xác định trong trường
hợp này.


    Bây giờ ta định nghĩa một đại lượng có quan hệ với tỉ lệ entropy như sau:
                              𝐻′(𝒳) = lim 𝐻(𝑋 |𝑋                    ,𝑋       ,...,𝑋 )
                                         →

    khi giới hạn này tồn tại.
    Hai đại lượng 𝐻(𝒳) và 𝐻′(𝒳) khác nhau như sau: đại lượng đầu thể hiện
entropy trung bình trên một biến của 𝑛 biến ngẫu nhiên, và đại lượng thứ hai là
entropy có điều kiện của biến ngẫu nhiên cuối cùng khi biết các biến ngẫu nhiên
trước đó. Bây giờ, chúng ta sẽ chứng minh một kết quả quan trọng cho quá trình
dừng là cả hai giới hạn trên đều tồn tại và bằng nhau.



                                                                                             64
     Định lí 5.2.1 Với một quá trình ngẫu nhiên dừng, các giới hạn được nêu trong
các định nghĩa trên tồn tại và bằng nhau, do đó:
                                                  𝐻(𝒳) = 𝐻′(𝒳)


    Trước tiên chúng ta sẽ chứng minh là giới hạn 𝐻(𝑋 |𝑋                                  , . . . , 𝑋 ) tồn tại.
     Định lí 5.2.2 Với một quá trình ngẫu nhiên dừng, đại lượng 𝐻(𝑋 |𝑋                                             ,...,𝑋 )
là không tăng theo 𝑛 và có giới hạn là 𝐻′(𝒳).
    Chứng minh
                       𝐻(𝑋        |𝑋 , 𝑋 , . . . , 𝑋 ) ≤ 𝐻(𝑋 |𝑋 , . . . , 𝑋 )
                                                       = 𝐻(𝑋 |𝑋 , . . . , 𝑋 ),


    trong đó quan hệ bất đẳng thức được suy ra từ tính chất của entropy có điều
kiện và quan hệ đẳng thức được suy ra từ tính chất của quá trình dừng. Vì
𝐻(𝑋 |𝑋 , . . . 𝑋 ) là dãy số giảm của các số không âm, nên nó có giới hạn là 𝐻′(𝒳).
    Chúng ta sẽ sử dụng kết quả đơn giản sau từ giải tích.
    Định lí 5.2.3 (trung bình Cesaro) Nếu 𝑎 → 𝑎 and 𝑏 = ∑                                         𝑎 , thì 𝑏 → 𝑎.

    Ý tưởng chứng minh: Vì tất cả các giá trị của dãy 𝑎 sẽ hội tụ về 𝑎, nên 𝑏 , trung
bình của 𝑛 phần tử đầu tiên cũng sẽ hội tụ về 𝑎.
     Chứng minh: Đặt 𝜀 > 0. Vì 𝑎 → 𝑎, do đó tồn tại 1 số nguyên dương 𝑁(𝜀) sao
cho |𝑎 − 𝑎| ≤ 𝜀 với mọi 𝑛 >= 𝑁(𝜀). Do đó,


                          |𝑏 − 𝑎|             =| ∑                   (𝑎 − 𝑎)|
                                              ≤ ∑                   |(𝑎 − 𝑎)|
                                                              ( )                       ( )
                                              ≤ ∑                   |(𝑎 − 𝑎)| +               𝜀
                                                              ( )
                                              ≤ ∑                   |(𝑎 − 𝑎)| + 𝜀

     với mọi giá trị 𝑛 ≥ 𝑁(𝜀). Do số hạng đầu tiên dần về 0 khi 𝑛 → ∞, chúng ta có
thể chọn |𝑏 − 𝑎| ≤ 2𝜀 bằng cách chọn 𝑛 đủ lớn. Do đó, 𝑏 → 𝑎 khi 𝑛 → ∞.
    Chứng minh định lí 5.2.1: Từ quy tắc chuỗi,
                             (    ,   ,...,   )
                                                  = ∑                𝐻(𝑋 |𝑋     , . . . , 𝑋 ),

      có nghĩa là, tỉ lệ entropy là trung bình theo thời gian của entropy có điều kiện.
Nhưng chúng ta đã biết rằng entropy có điều kiện sẽ dần về 𝐻′. Do đó, theo định lí
5.2.3, trung bình nói trên có giới hạn, bằng với giá trị 𝐻′. Theo định lí 5.2.2,
                                              (   ,   ,...,     )
                     𝐻(𝒳)        = lim                               = lim𝐻(𝑋 |𝑋          ,...,𝑋 )
                                 = 𝐻′(𝒳)

                                                                                                                        65
   Tỉ lệ entropy được định nghĩa tốt cho tất cả các quá trình dừng. Trong trường
hợp quá trình dừng là chuỗi Markov, việc tính toán tỉ lệ entropy trở nên khá dễ
dàng.
    Chuỗi Markov: Với một xích Markov dừng, tỉ lệ entropy được tính theo công
thức
                𝐻(𝒳) = 𝐻′(𝒳) = lim𝐻(𝑋 |𝑋          , . . . , 𝑋 ) = lim𝐻(𝑋 |𝑋   )
                     = 𝐻(𝑋 |𝑋 ),
     trong đó, entropy có điều kiện được tính bằng cách sử dụng phân phối dừng đã
cho. Biết rằng phân phối dừng 𝜇 là nghiệm của các phương trình

                               𝜇 =      𝜇 𝑃 với mọi 𝑗.

    Giá trị của entropy có điều kiện được tính rõ ràng hơn trong định lí sau.
     Định lí 5.2.4 Cho {𝑋 } là một chuỗi Markov dừng với phân phối dừng 𝜇 và ma
trận chuyển 𝑃. Giả sử 𝑋 ~𝜇. Thì tỉ lệ entropy là :

                              𝐻(𝒳) = −      𝜇 𝑃 log𝑃

    Chứng minh:

                     𝐻(𝒳) = 𝐻(𝑋 |𝑋 ) =       𝜇(       − 𝑃 log𝑃 )



      Ví dụ (Chuỗi Markov với 2 trạng thái) Tỉ lệ entropy của chuỗi Markov hai trạng
thái trong Hình 5.1 là:
                                         𝛽          𝛼
                   𝐻(𝒳) = 𝐻(𝑋 |𝑋 ) =        𝐻(𝛼) +     𝐻(𝛽).
                                        𝛼+𝛽        𝛼+𝛽
    Nếu chuỗi Markov là tối giản và phi chu kì, nó có một phân phối dừng duy nhất
trên các trạng thái, và xuất phát từ bất kì phân phối nào sẽ dần đến phân phối dừng
khi 𝑛 → ∞. Trong trường hợp này, ngay cả khi phân phối ban đầu không là phân
phối dừng, thì tỉ lệ entropy (được định nghĩa để thể hiện hành vi dài hạn) sẽ là
𝐻(𝒳), như đã định nghĩa ở trên.


5.3. TỈ LỆ ENTROPY CỦA ĐƯỜNG ĐI NGẪU NHIÊN TRONG ĐỒ THỊ
CÓ TRỌNG SỐ




                                                                                  66
                         Hình 5.2. Đường đi ngẫu nhiên trên đồ thị

     Hình 5.2 là một ví dụ về đường đi ngẫu nhiên trên một đồ thị liên thông. Xét
một đồ vô hướng thị gồm 𝑚 đỉnh {1,2, … , 𝑚}, với trọng số 𝑊 ≥ 0 là trọng số của
cạnh giữa hai đỉnh 𝑖 và 𝑗. Do đồ thị là vô hướng nên 𝑊 = 𝑊 . Khi không có cạnh
nối 𝑖 với 𝑗 thì 𝑊 = 0
     Một vật thể đi ngẫu nhiên từ đỉnh này sang đỉnh khác trên đồ thị đó. Ta gọi một
đường đi ngẫu nhiên {𝑋 }, 𝑋 ∈ {1,2, … , 𝑚}, là một chuỗi các đỉnh của đồ thị. Khi cho
biết 𝑋 = 𝑖, đỉnh tiếp theo 𝑗 sẽ được chọn trong các đỉnh kề của 𝑖 với xác suất được
xác định dựa trên trọng số của các cạnh đi từ 𝑖. 𝑃 = 𝑊 / ∑ 𝑊
    Trong trường hợp này phân phối dừng chúng ta cần xác định có một dạng rất
đơn giản. Phân phối dừng cho chuỗi Markov này đặt xác suất cho mỗi đỉnh 𝑖 dựa
trên tổng trọng số của các cạnh có chứa đỉnh 𝑖. Đặt

                                     𝑊 =           𝑊

    là tổng trọng số của cạnh có chứa 𝑖 và

                                    𝑊=             𝑊
                                            , :

    là tổng trọng số của tất cả các cạnh. Khi đó ∑ 𝑊 = 2𝑊.
    Phân phối dừng đơn giản nhất mà chúng ta có thể đoán ra là:
                                                  𝑊
                                        𝜇 =
                                                  2𝑊
     Chúng ta có thể xác định xem đó có phải là phân phối dừng hay không bằng
cách kiểm tra xem giá trị 𝜇𝑃 = 𝜇 hay không.
                                                   𝑊 𝑊
                                    𝜇𝑃 =
                                                   2𝑊 𝑊𝑖
                                                    1
                                          =           𝑊
                                                   2𝑊
                                              𝑊
                                          =
                                              2𝑊

                                                                                  67
                                          =𝜇


     Như vậy, phân phối dừng của trạng thái 𝑖 tỉ lệ với trọng số của các cạnh có chứa
𝑖. Phân phối này có một tính chất rất thú vị: nó chỉ phụ thuộc vào tộng trọng số và
các trọng số thành phần chứa đỉnh, nó sẽ không thay đổi nếu trọng số của một phần
nào đó trên đồ thị bị thay đổi nhưng vẫn giữ được tổng trọng số như ban đầu.
Chúng ta có thể tính tỉ lệ entropy dựa theo công thức:
                      𝐻(𝒳) = 𝐻(𝑋 |𝑋 )
                            =−       𝜇     𝑃? log(𝑃 )

                                     𝑊         𝑊     𝑊
                            =−                   log
                                     2𝑊        𝑊     𝑊
                                          𝑊      𝑊
                            =−               log
                                          2𝑊     𝑊
                                          𝑊      𝑊 𝑊       𝑊
                            =−               𝑙𝑜𝑔       𝑙𝑜𝑔
                                          2𝑊     2𝑊 2𝑊     2𝑊
                                     𝑊            𝑊
                            = 𝐻 …,      ,… − 𝐻 …,    ,…
                                     2𝑊           2𝑊
     Nếu tất cả các cạnh đều có trọng số bằng nhau, phân phối dừng sẽ đặt trọng số
𝐸 /2𝐸 lên đỉnh 𝑖. Trong đó 𝐸 là số cạnh xuất phát từ 𝑖 và 𝐸 là tổng số cạnh của đồ
thị. Trong trường hợp này, tỉ lệ entropy của một đường đi ngẫu nhiên được tính như
sau:
                                                𝐸 𝐸       𝐸
                       𝐻(𝒳) = 𝑙𝑜𝑔(2𝐸) − 𝐻         ,   ,…,
                                                2𝐸 2𝐸     2𝐸
    Điều này giải thích vì sao tỉ lệ entropy lại rất dễ gây hiểu nhầm. Rõ ràng, tỉ lệ
entropy hay giá trị trung bình của entropy chuyển trạng thái chỉ phụ thuộc vào
entropy của phân phối dừng và tổng số cạnh.
    Ví dụ (đường đi ngẫu nhiên trong một bàn cờ) Giả sử quân Vua di chuyển một cách
ngẫu nhiên trong bàn cờ 8x8. Quân Vua có thể di chuyển đến 8 ô khác nhau nếu nó
nằm giữa bàn cờ, 5 ô nếu nó nằm ở cạnh, và 3 ô nếu nó nằm ở góc. Dựa vào nhận xét
trên, phân phối dừng của các vị trí trên tương ứng là:      ,  , và    . Khi đó tỉ lệ
entropy sẽ là 0.92log8 vì ảnh hưởng của các cạnh bàn cờ. Nếu chúng ta có một bàn
cờ vô hạn thì tỉ lệ entropy sẽ là log8.
     Tương tự như vậy, tỉ lệ của quân Xe (log14 bits vì quân Xe luôn có thể đi được
tới 14 ô), quân Tịnh, và quân Hậu. Quân Hậu có thể đi được tất cả các nước của quân
Xe và quân Tịnh, khi đó thì quân hậu sẽ tự do hơn hai quân trên không?
    Rất đơn giản để nhận thấy rằng một đường đi dừng trên đồ thị có thể bị đảo
ngược lại như sau: xác suất của một chuỗi trạng thái bất kỳ là giống nhau theo cả hai
chiều

                                                                                  68
        𝑃(𝑋 = 𝑥 , 𝑋 = 𝑥 , … , 𝑋 = 𝑥 ) = 𝑃(𝑋 = 𝑥 , 𝑋           =𝑥        ,…,𝑋 = 𝑥 )
     Như vậy, tất cả các chuỗi Markov có thể đảo chiều đều được đều có thể được
biểu diễn dưới dạng một đồ thị vô hướng có trọng số.


5.4. ĐỊNH LUẬT 2 NHIỆT ĐỘNG LỰC HỌC

    Định luật 2 nhiệt động lực học là một định luật cơ bản của Vật lý, định luật này
phát biểu rằng entropy của một hệ cô lập (hệ không có trao đổi năng lượng với các
tác nhân bên ngoài) không bao giờ giảm. Chúng ta sẽ cũng tìm hiểu mối quan hệ
giữa định luật này với entropy.
    Trong nhiệt động lực học thống kê, entropy thường được định nghĩa là logarit
của số lượng các trạng thái con (microstate) trong hệ. Định nghĩa này có liên quan
trực tiếp tới định nghĩa entropy của chúng ta nếu tất cả các trạng thái có xác suất
xuất hiện bằng nhau. Tuy nhiên, tại sao entropy lại tăng?
     Chúng ta cùng mô hình hóa một hệ cô lập thành một chuỗi Markov với các
chuyển đổi tuân theo các quy luật vật lý chi phối hệ. Tất nhiên, giả thuyết này có bao
hàm khái niệm trạng thái tổng thể (overall state) của hệ cũng như điều kiện trạng
thái quá khứ và tương lai là độc lập khi chúng ta biết trạng thái của hiện tại. Trong
hệ này, chúng ta có thể tìm ra bốn cách khác nhau để biểu diễn định luật 2. Như ta
sẽ thấy, điều đáng ngạc nhiên là entropy của hệ không luôn luôn tăng, tuy nhiên
entropy tương đối của hệ luôn giảm.


    1. Entropy tương đối 𝐷(𝜇 ||𝜇′ ) giảm theo n. Giả sử 𝜇 và 𝜇′ là hai phân phối xác
suất trong không gian trạng thái của một chuỗi Markov tại thời gian 𝑛. Đặt 𝜇      và
𝜇′     là các phân phối xác suất tương ứng trong tại thời gian 𝑛 + 1. Gọi hai hàm
phân bố đồng thời tương ứng là 𝑝 và 𝑞. Khi đó, 𝑝(𝑥 , 𝑥 ) = 𝑝(𝑥 )𝑟(𝑥 |𝑥 ) và
𝑞(𝑥 , 𝑥 ) = 𝑞(𝑥 )𝑟(𝑥 |𝑥 ) trong đó 𝑟(⋅ | ⋅) là hàm xác suất chuyển của chuỗi
Markov. Như vậy khi áp dụng luật xích của entropy tương đối, chúng ta sẽ có hai
cách mở rộng như sau:

              𝐷(𝑝(𝑥 , 𝑥    )||𝑞(𝑥 , 𝑥       )) = 𝐷(𝑝(𝑥 )||𝑞(𝑥 ))
              +𝐷(𝑝(𝑥      |𝑥 )||𝑞(𝑥        |𝑥 ))
              = 𝐷(𝑝(𝑥     )||𝑞(𝑥      ))
              +𝐷(𝑝(𝑥 |𝑥      )||𝑞(𝑥 |𝑥        ))

   Vì 𝑝 và 𝑞 đều thu được từ cùng một chuỗi Markov, xác suất có điều kiện
𝑝(𝑥 |𝑥 ) và 𝑞(𝑥 |𝑥 ) đều bằng 𝑟(𝑥 |𝑥 ). Do đó chúng ta thu được
𝐷(𝑝(𝑥 |𝑥 )||𝑞(𝑥 |𝑥 )) = 0. Như vậy nếu ta sử dụng tính chất không âm của
𝐷(𝑝(𝑥 |𝑥 )||𝑞(𝑥 |𝑥 )) chúng ta sẽ có:
                          𝐷(𝑝(𝑥 )||𝑞(𝑥 )) ≥ 𝐷(𝑝(𝑥         )||𝑞(𝑥   ))

                                                                                     69
     hay
                                𝐷(𝜇 ||𝜇′ ) ≥ 𝐷(𝜇     ||𝜇′    )
     Hệ quả của điều này là khoảng cách giữa hai hàm phân phối tích lũy giảm theo
thời gian 𝑛 cho tất cả các chuỗi Markov.
    Một ví dụ của bất đẳng thức trên là hệ thống thuế. Giả sử hệ thống thuế áp
dụng theo thu nhập của Anh và Canada là như nhau. Khi đó nếu ta coi 𝜇 và 𝜇′ thể
hiện phân phối về thu nhập của hai nước, bất đẳng thức trên tương đương với
khoảng cách entropy tương đối sẽ giảm xuống theo thời gian. Hay thu nhập của hai
nước sẽ trở nên giống nhau hơn theo thời gian.


    2. Entropy tương đối 𝐷(𝜇 ||𝜇) giữa một phân phối 𝜇 của trạng thái tại thời gian 𝑛 và
phân phối dừng 𝜇 giảm theo thời gian n. Trong công thức ở phần trên, 𝜇′ là một phân
phối bất kỳ trong không gian trạng thái tại thời gian 𝑛. Nếu chúng ta để 𝜇′ là một
phân phối dừng 𝜇, phân phối 𝜇′       tại thời điểm 𝑛 + 1 cũng vẫn là 𝜇. Do đó:
                                   𝐷(𝜇 ||𝜇) ≥ 𝐷(𝜇     ||𝜇)
     Điều này tương đương với việc phân phối trạng thái sẽ ngày càng giống với
phân phối dừng theo thời gian. Chuỗi 𝐷(𝜇 ||𝜇) là một chuỗi giảm không âm do đó
nó cần có giới hạn. Giớ hạn ở đây sẽ là 0 nếu phân phối dừng là duy nhất, tuy nhiên
chứng minh điều này sẽ khó khăn hơn.


     3. Entropy tăng nếu phân phối dừng là phân phối đều. Thông thường, việc entropy
tương đối giảm không tương đương với entropy tăng. Một ví dụ đơn giản cho điều
này là với tất cả các chuỗi Markov với phân phối dừng không phải là phân phối đều.
Nếu chúng ta bắt đầu chuỗi Markov này với một phân phối đều entropy sẽ đạt giá
trị lớn nhất, phân phối sẽ có xu hướng trở thành phân phối dừng (có entropy nhỏ
hơn phân phối đều). Như vậy entropy giảm theo thời gian.
    Tuy nhiên, nếu phân phối dừng đang xét là phân phối đều, chúng ta có thể thể
hiện entropy tương đối theo cách sau:
                       𝐷(𝜇 ||𝜇) = log|𝒳| − 𝐻(𝜇 ) = log|𝒳| − 𝐻(𝑋 )
    Trong trường hợp này, việc entropy tương đối giảm theo thời gian sẽ chứng
minh entropy tăng theo thời gian. Đây là giải thích gần nhất với nhiệt động lực học
thống kê (tất cả các trạng thái con là tương đương). Chúng ta đã có thể xác định
được tính chất của tiến trình chứa phân phối dừng đều.


     Định nghĩa: Một ma trận xác suất chuyển 𝑃 , 𝑃 = 𝑃[𝑋             = 𝑖|𝑋 = 𝑗], được
gọi là doubly stochastic - ngẫu nhiên hai lần nếu:



                                                                                     70
                                    𝑃 = 1, 𝑗 = 1,2, …

    và

                                    𝑃 = 1, 𝑖 = 1,2, …



   Phân phối đều là một phân phối dừng của 𝑃 khi và chỉ khi ma trận phân phối
chuyển là ngẫu nhiên hai lần.
     4. Entropy có điều kiện 𝐻(𝑋 |𝑋 ) tăng theo n với một tiến trình Markov dừng. Nếu
tiến trình Markov là tiến trình dừng, 𝐻(𝑋 ) là hằng số. Do vậy entropy là không
tăng. Tuy nhiên, chúng ta sẽ chứng minh rằng 𝐻(𝑋 |𝑋 ) tăng theo n. Hay độ không
chắc chắn phụ thuộc của tương lai sẽ tăng. Chúng ta sẽ có hai cách chứng minh điều
này.
    Cách đầu tiên sẽ sử dụng tính chất của entropy,
                              𝐻(𝑋 |𝑋 ) ≥ 𝐻(𝑋 |𝑋 , 𝑋 )
                                       = 𝐻(𝑋 |𝑋 )
                                       = 𝐻(𝑋 |𝑋 )
    Cách thứ hai, áp dụng bất đẳng thức xử lý dữ liệu vào chuỗi Markov 𝑋 →
𝑋   → 𝑋 , chúng ta có:
                                  𝐼(𝑋 ; 𝑋     ) ≥ 𝐼(𝑋 ; 𝑋 )
    Chuyển thông tin tương hỗ về dạng entropy ta được:
                       𝐻(𝑋     ) − 𝐻(𝑋      |𝑋 ) ≥ 𝐻(𝑋 ) − 𝐻(𝑋 |𝑋 )
    Bằng tính chất dừng, 𝐻(𝑋      ) = 𝐻(𝑋 ), khi đó:
                                 𝐻(𝑋        |𝑋 ) ≤ 𝐻(𝑋 |𝑋 )
     [Các kỹ thuật này có thể được sử dụng để chứng minh 𝐻(𝑋 |𝑋 ) luôn tăng theo
𝑛 với mọi chuỗi Markov].


    5. Sự xáo trộn làm tăng entropy. Nếu 𝑇 là một xáo trộn (hoán vị) của một bộ bài và
𝑋 là vị trí ban đầu (ngẫu nhiên) của các quân bài bộ bài. Khi đó xáo trộn 𝑇 sẽ không
phụ thuộc vào 𝑋, nên
                                       𝐻(𝑇𝑋) ≥ 𝐻(𝑋)
    Trong đó, 𝑇𝑋 là một hoán vị của bộ bài có chứa xáo trộn 𝑇 trong trạng thái ban
đầu 𝑋.


5.5. HÀM CỦA CHUỖI MARKOV


                                                                                   71
     Dưới đây là một ví dụ khó nếu ta không làm đúng cách. Nó cho thấy hiệu quả
của các phương pháp được phát triển cho đến bây giờ. Cho 𝑋 , 𝑋 , … , 𝑋 , … là một
chuỗi Markov dừng và 𝑌 = 𝜙(𝑋 ) là một quá trình mà mỗi phần tử là một hàm của
trạng thái tương ứng trong chuỗi Markov. Câu hỏi đặt ra là tỉ lệ entropy 𝐻(𝒴) sẽ
được tính như thế nào? Các hàm của chuỗi Markov như thế này thường xuyên xuất
hiện trong thực tế. Trong nhiều trường hợp, chúng ta chỉ có một phần thông tin về
trạng thái của hệ thống. Sẽ đơn giản hơn rất nhiều nếu 𝑌 , 𝑌 , … , 𝑌 cũng tạo thành
một chuỗi Markov, nhưng trong nhiều trường hợp điều này không đúng. Do chuỗi
Markov là dừng nên 𝑌 , 𝑌 , … , 𝑌 cũng vậy, và tỉ lệ entropy được định nghĩa một cách
tường minh. Tuy nhiên nếu chúng ta muốn tính 𝐻(𝒴), chúng ta có thể tính
𝐻(𝑌 |𝑌 , … , 𝑌 ) cho mỗi 𝑛 và tìm giới hạn của nó. Do sự hội tụ có thể chậm một
cách tùy ý, chúng ta sẽ không bao giờ biết được là đã gần giới hạn như thế nào.
(Chúng ta không thể dựa vào sự thay đổi giá trị ở 𝑛 và 𝑛 + 1, do sự sai khác này có
thể rất nhỏ ngay cả khi đang còn cách xa điểm giới hạn -- ví dụ như trường hợp ∑ .)

    Việc ước lượng cận trên và cận dưới cùng hội tụ đến giới hạn từ hai phía có thể
giúp ích cho việc tính toán. Chúng ta có thể dừng việc tính toán lại khi sự khác biệt
giữa cận trên và cận dưới là nhỏ và chúng ta khi đó sẽ có một ước lượng tốt của giới
hạn đó.
    Như đã biết, 𝐻(𝑌 |𝑌 , … , 𝑌 ) hội tụ một cách đơn điệu đến 𝐻(𝒴) từ trên xuống.
Đối với cận dưới, chúng ta sẽ sử dụng 𝐻(𝑌 |𝑌 , … , 𝑌 , 𝑋 ). Đây là một cách làm hay
dựa trên ý tưởng 𝑋 chứa lượng thông tin về 𝑌 tương đương với 𝑌 , 𝑌 , 𝑌 − 1, ….
    Định lý 5.5.1
                                 𝐻(𝑌 |𝑌        , … , 𝑌 , 𝑋 ) ≤ 𝐻(𝒴)


    Chứng minh: Với 𝑘 = 1,2, …, ta có
                                     ( )
              𝐻(𝑌 |𝑌     , … , 𝑌 , 𝑋 ) = 𝐻(𝑌 |𝑌        ,…,𝑌 ,𝑌 ,𝑋 )
              ( )
              = 𝐻(𝑌 |𝑌      ,…,𝑌 ,𝑋 ,𝑋 ,𝑋 ,…,𝑋 )


              ( )
              = 𝐻(𝑌 |𝑌      , … , 𝑌 , 𝑋 , 𝑋 , 𝑋 , …,
              𝑋 ,𝑌 ,…,𝑌 )
              ( )
              ≤ 𝐻(𝑌 |𝑌      ,…,𝑌 ,𝑌 ,…,𝑌 )
              ( )
              = 𝐻(𝑌        |𝑌𝑛 + 𝑘, … , 𝑌 ),
     trong đó có (𝑎) do 𝑌 là một hàm của 𝑋 , và (𝑏) do tính chất chuỗi Markov của
𝑋, (𝑐) do 𝑌 là một hàm của 𝑋 , (𝑑) do có điều kiện làm giảm entropy, và (𝑒) do tính
chất dừng. Vì bất đẳng thức là đúng với mọi 𝑘 nên nó cũng đúng với giới hạn của
dãy. Do đó,

                                                                                  72
                𝐻(𝑌 |𝑌     , … , 𝑌 , 𝑋 ) ≤ lim𝐻(𝑌            |𝑌𝑛 + 𝑘, … , 𝑌 )

                = 𝐻(𝒴).
     Định lý tiếp theo sẽ chỉ ra rằng khoảng cách giữa cận trên và cận dưới giảm
theo độ dài.
      Định lý 5.5.2
                           𝐻(𝑌 |𝑌       , … , 𝑌 ) − 𝐻(𝑌 |𝑌      , … , 𝑌 , 𝑋 ) → 0.
      Chứng minh: Độ dài khoảng cách có thể được viết lại như sau
                 𝐻(𝑌 |𝑌        , … , 𝑌 ) − 𝐻(𝑌 |𝑌     , … , 𝑌 , 𝑋 ) = 𝐼(𝑋 ; 𝑌 |𝑌      ,…,𝑌 )
      Theo tính chất của thông tin tương hỗ thì
                                       𝐼(𝑋 ; 𝑌 , 𝑌 … , 𝑌 ) ≤ 𝐻(𝑋 ),
      và 𝐼(𝑋 ; 𝑌 , 𝑌 , … , 𝑌 ) tăng theo 𝑛. Do đó lim𝐼(𝑋 ; 𝑌 , 𝑌 , … , 𝑌 ) tồn tại và thỏa mãn
                                      lim 𝐼(𝑋 ; 𝑌 , 𝑌 … , 𝑌 ) ≤ 𝐻𝑋 .
                                       →

      Theo chain rule ta có,
                𝐻(𝑋) ≥ lim 𝐼(𝑋 ; 𝑌 , 𝑌 … , 𝑌 )
                           →

                = lim ∑         𝐼(𝑋 ; 𝑌 |𝑌   ,…,𝑌 )
                    →

                =∑       𝐼(𝑋 ; 𝑌 |𝑌     , … , 𝑌 ).
      Do tổng vô hạn này là hữu hạn và không âm nên nó phải bằng 0, do đó
                                      lim𝐼(𝑋 ; 𝑌 |𝑌       , … , 𝑌 ) = 0,
      Kết hợp hai định lý 5.5.1 và 5.5.2 ta có định lý sau đây:
      Định lý 5.5.3: Nếu 𝑋 , 𝑋 , … , 𝑋 tạo thành một chuỗi Markov dừng và 𝑌 = 𝜙(𝑋 )
thì
                         𝐻(𝑌 |𝑌       , … , 𝑌 , 𝑋 ) ≤ 𝐻(𝒴) ≤ 𝐻(𝑌 |𝑌         ,…,𝑌 )
      và
                      lim𝐻(𝑌 |𝑌       , … , 𝑌 , 𝑋 ) = 𝐻(𝒴) = lim𝐻(𝑌 |𝑌          , … , 𝑌 ).
     Một cách tổng quát, chúng ta có thể quan tâm đến trường hợp khi 𝑌 là một hàm
ngẫu nhiên (trái với một hàm tất định) của 𝑠𝑋 . Xét một quá trình Markov
𝑋 , 𝑋 , … , 𝑋 , và định nghĩa một quá trình mới 𝑌 , 𝑌 , … , 𝑌 , trong đó 𝑌 được xác định
dựa theo 𝑝(𝑦 |𝑥 ), không phụ thuộc theo điều kiện vào tất cả các 𝑋 , 𝑗 ≠ 𝑖; ta có
                          𝑝(𝑥 , 𝑦 ) = 𝑝(𝑥 ) ∏          𝑝(𝑥      |𝑥 ) ∏     𝑝(𝑦 |𝑥 )
    Một quá trình như thế này còn được gọi là một Mô hình Markov ẩn (HMM),
được sử dụng rộng rãi trong nhận dạng tiếng nói, nhận dạng chữ viết tay, v.v. Lý
luận tương tự như được sử dụng ở trên cho hàm của một chuỗi Markov được áp
dụng với các Mô hình Markov ẩn, và chúng ta có thể chặn dưới tỉ lệ entropy của một

                                                                                               73
mô hình Markov ẩn bằng cách đặt điều kiện nó trên trạng thái Markov cơ sở. Chi tiết
của lý luận được dành cho độc giả.


    ĐỌC THÊM
    Ý nghĩa của tỉ lệ entropy của quá trình ngẫu nhiên phát sinh từ tính chất tiệm
cận phân phối đều (AEP) của một quá trình ergodic dừng. Người ta đã chứng minh
được AEP tổng quát cho quá trình ergidic dừng như sau:
                                  − log𝑝(𝑋 , 𝑋 , . . . , 𝑋 ) → 𝐻(𝒳)

     với xác suất bằng 1. Sử dụng tính chất này, các định lí đã nêu trong Chương 4
có thể dễ dàng được mở rộng cho một quá trình ergodic dừng. Chúng ta có thể định
nghĩa tập điển hình theo cách giống như trường hợp độc lập và cùng phân phối ở
Chương 4. Với những lập luận tương tự, chúng ta có thể chỉ ra là tập điển hình có
xác suất gần tới 1 và có khoảng 2 (𝒳) dãy điển hình độ dài 𝑛, mỗi dãy có xác suất
khoảng −2 (𝒳) . Do đó, chúng ta có thể biểu diễn các dãy điển hình độ dài 𝑛 sử
dụng xấp xỉ 𝑛𝐻(𝒳) bit. Điều này cho thấy tỉ lệ entropy có ý nghĩa là độ dài mô tả
trung bình của một quá trình ergodic dừng.


    BÀI TẬP
    Bài 5.1. Đường đi ngẫu nhiên trong khối lập phương
    Một con chim bay từ phòng này sang phòng khác trong một khối lập phương
kích thước 3×3×3. Tỉ lệ entropy là bao nhiêu?


    Bài 5.2. Entropy của đồ thị
    Xét đường đi ngẫu nhiên trên đồ thị (liên thông) 3 cạnh.
    a) Đồ thị nào có tỉ lệ entropy nhỏ nhất? Giá trị đó là bao nhiêu?
    b) Đồ thị nào có tỉ lệ entropy cao nhất?


    Bài 5.3. Quá trình dừng
   Giả sử . . . , X−1, X0, X1, . . . là một quá trình ngẫu nhiên dừng (không nhất thiết là
Markov). Phát biểu nào sau đây là đúng? Chứng minh hoặc đưa ra phản ví dụ.
    (a) H(Xn|X0) = H(X−n|X0) .
    (b) H(Xn|X0) ≥ H(Xn−1|X0) .
    (c) H(Xn|𝑋     , Xn+1) không tăng theo n.
    (d) H(Xn+1|𝑋 , 𝑋      ) không tăng n.
    Bài 5.4. Tỉ lệ entropy của quá trình con chó tìm xương

                                                                                       74
    Một con chó đi bộ trên dãy số nguyên trong đó ở mỗi bước, xác suất nó đảo
chiều là p = 0.1. Giả sử X0 = 0. Ở bước đầu tiên, xác suất nó đi theo chiều dương hay
âm là như nhau. Một dãy bước đi có thể là:
     (𝑋 , 𝑋 , … ) = (0, −1, −2, −3, −4, −3, −2, −1,0,1, … )
    a) Tìm 𝐻(𝑋 , 𝑋 , … , 𝑋 ).
    b) Tìm tỉ lệ entropy của con chó.
    c) Tính kỳ vọng của số bước mà con chó đi trước khi đổi chiều.
    Bài 5.5. Tỉ lệ entropy của xích Markov
    a) Tìm tỉ lệ entropy của xích Markov hai trạng thái có ma trận chuyển sau
                                       1−𝑝          𝑝
                                 𝑃=
                                        𝑝          1−𝑝
    b) Tìm các giá trị của 𝑝 , 𝑝 mà làm cực đại tỉ lệ entropy.
    c) Tìm tỉ lệ entropy của xích Markov hai trạng thái với ma trận chuyển
                                             1−𝑝    𝑝
                                      𝑃=
                                              1     0
    d) Tìm giá trị cực đại của tỉ lệ entropy của xích Markov ở câu c. Ta mong muốn
       rằng giá trị cực đại của p nên nhỏ hơn , vì trạng thái 0 cho phép nhiều thông
       tin được sinh ra hơn trạng thái 1.
    e) Giả sử N(t) là số lượng chuỗi trạng thái có thể có với độ dài t của xích
       Markov ở câu c. Tìm N(t) và tính
                                          1
                                   𝐻 = lim log 𝑁(𝑡)
                                        → 𝑡

      Gợi ý: Tìm một phép truy toán tuyến tính mà biểu diễn N(t) theo N(t-1) và
      N(t-2). Tại sao H0 là cận trên của tỉ lệ entropy của xích Markov đó? So sánh H0
      với giá trị entropy cực đại tìm được ở câu d.
    Bài 5.6. Định luật thứ hai của nhiệt động lực học
     Giả sử 𝑋 , 𝑋 , … là xích Markov bậc nhất dừng. Trong chương này đã chỉ ra rằng
𝐻(𝑋 |𝑋 ) ≥ 𝐻(𝑋 |𝑋 ) với n = 2, 3, … Do đó, sự không chắc chắn có điều kiện về
tương lai tăng theo thời gian. Điều này là đúng dù sự không chắc chắn có điều kiện
𝐻(𝑋 ) là hằng số. Tuy nhiên, bằng ví dụ hãy chỉ ra rằng 𝐻(𝑋 |𝑋 = 𝑥 ) không nhất
thiết tăng theo n với mọi x1.
    Bài 5.7. Entropy của một cây ngẫu nhiên
    Xét phương pháp sinh cây ngẫu nhiên gồm n nút lá như sau. Trước tiên mở
rộng nút gốc:




    Sau đó mở rộng một trong hai nút lá một cách ngẫu nhiên:


                                                                                  75
    Ở bước k, chọn một trong các nút lá ở bước k-1 theo một phân phối đều và mở
rộng nó. Tiếp tục cho tới khi n nút lá được sinh ra.
    Một dãy thao tác để sinh ra cây 5 nút lá có thể như sau:




   Đáng ngạc nhiên là phương pháp sinh cây ngẫu nhiên sau đây thu được cùng
một phân phối xác suất trên cây với n nút lá. Trước tiên chọn một số nguyên 𝑁
phân phối đều trên {1,2, … , 𝑛 − 1}. Khi đó ta có hình




    Sau đó chọn một số nguyên 𝑁 phân phối đều trên {1,2, … , 𝑁 − 1}, và chọn độc
lập một số nguyên 𝑁 phân phối đều trên {1,2, … , (𝑛 − 𝑁 ) − 1}. Hình vẽ trở thành:




    Tiếp tục quá trình cho tới khi không thể chia được nữa. (Tương đương của hai
lược đồ sinh cây trên là mô hình Polya urn).
    Bây giờ giả sử 𝑇 là cây n nút sinh bởi phương pháp trên. Phân phối xác suất
trên các cây như vậy có vẻ khó mô tả, nhưng ta có thể tìm entropy của phân phối
này theo cách đệ qui.
    Xét một số ví dụ. Với n = 2, ta chỉ có một cây. Do đó H(T2) = 0. Với n = 3, ta có hai
cây cùng khả năng:




                                                                                      76
     Do đó, 𝐻(𝑇 ) = log 2. Với n = 4, ta có năm cây có thể, với xác suất , , , , .

    Bây giờ ta tìm cách định nghĩa đệ qui. Giả sử 𝑁 (𝑇 ) biểu diễn số nút lá của Tn
trong nửa phải của cây. Chứng minh các bước sau:
                                   𝐻(𝑇 ) = 𝐻(𝑁 , 𝑇 )
                                  = 𝐻(𝑁 ) + 𝐻(𝑇 |𝑁 )
                                = log(𝑛 − 1) + 𝐻(𝑇 |𝑁 )

                                          1
                      = log(𝑛 − 1) +             𝐻(𝑇 ) + 𝐻(𝑇    )
                                         𝑛−1

                                                2
                            = log(𝑛 − 1) +             𝐻(𝑇 )
                                               𝑛−1

                                                 2
                               = log(𝑛 − 1) +           𝐻
                                                𝑛−1

    Sau đó sử dụng kết quả trên để chứng minh rằng
               (𝑛 − 1)𝐻 = 𝑛𝐻     + (𝑛 − 1) log(𝑛 − 1) − (𝑛 − 2) log(𝑛 − 2)
    hoặc
                                    𝐻   𝐻
                                      =     +𝑐
                                    𝑛   𝑛−1
   với cn được định nghĩa phù hợp. Vì ∑ 𝑐 = 𝑐 < ∞, bạn đã chứng minh rằng
 𝐻(𝑇 ) hội tụ tới một hằng số. Do đó, số bít kỳ vọng cần để mô tả cây Tn tăng tuyến
tính theo n.
    Bài 5.8. Quá trình entropy cực đại
    Một nguồn rời rạc không nhớ có bảng chữ cái {1, 2}, trong đó ký hiệu 1 có thời
gian 1 và ký hiệu 2 có thời gian 2. Xác suất của 1 và 2 lần lượt là p1 và p2. Tìm giá trị
                                                                 ( )
p1 mà cực đại entropy nguồn mỗi đơn vị thời gian 𝐻(𝒳) =             . Giá trị cực đại của
𝐻(𝒳) là bao nhiêu?
    Bài 5.9. Đường đi ngẫu nhiên trên đồ thị
    Xét một đường đi ngẫu nhiên trên đồ thị sau:




                                                                                      77
   a) Tính phân phối dừng.
   b) Tỉ lệ entropy là bao nhiêu?
   c) Tìm thông tin tương hỗ 𝐼(𝑋        ; 𝑋 ) giả sử rằng quá trình là dừng.
   Bài 5.10. Đường đi ngẫu nhiên trên bàn cờ
   Tìm tỉ lệ entropy của xích Markov ứng với một đường đi ngẫu nhiên của một
quân vua trên bàn cờ 3x3 sau:
                                    1      2      3
                                    4      5      6
                                    7      8      9


   Tỉ lệ entropy của quân cờ tháp, quân giám mục, quân hậu thế nào? Có hai loại
quân giám mục.




                                                                               78
Chương 6
NÉN DỮ LIỆU


     Chúng ta đều biết, nhờ nén dữ liệu mà lượng tiêu thụ các tài nguyên quan trọng
như dung lượng đĩa cứng hay băng thông được giảm đi đáng kể. Trong chương này
ta xét các khía cạnh lý thuyết của nén dữ liệu, trong đó điểm nhấn là giới hạn cơ bản
của nén dữ liệu, trực tiếp liên quan đến khái niệm entropy ta đã học. Nén dữ liệu có
thể đạt được nhờ gán các mô tả ngắn cho các biến cố sơ cấp hay xuất hiện nhất của
nguồn dữ liệu, và mô tả dài hơn cho các biến cố ít xuất hiện hơn. Một ví dụ đơn giản
là mã Morse, ký hiệu hay xuất hiện nhất được biểu diễn bằng một dấu chấm. Trong
chương này ta quan niệm hiệu quả nén là tốt nếu chiều dài mô tả trung bình của
biến ngẫu nhiên là ngắn nhất có thể.


6.1. ĐỊNH NGHĨA VÀ VÍ DỤ VỀ MÃ

     Định nghĩa: Một mã nguồn 𝐶 của biến ngẫu nhiên 𝑋 là một ánh xạ từ 𝒳, miền
xác định của 𝑋, vào 𝒟*, tập các xâu độ dài hữu hạn gồm các ký hiệu thuộc bảng chữ
cái D-phân:
                                     C: 𝒳 → 𝒟 ∗
    Ký hiệu 𝐶(𝑥) là từ mã tương ứng với 𝑥 và 𝑙(𝑥) là độ dài của 𝐶(𝑥).
   Ví dụ: 𝐶(𝑟𝑒𝑑) = 00, 𝐶(𝑏𝑙𝑢𝑒) = 11 là một mã nguồn của 𝒳 = {red, blue} với
bảng chữ cái 𝒟 = {0, 1}.
    Định nghĩa: Độ dài kỳ vọng 𝐿(𝐶) của một mã nguồn 𝐶(𝑥) của biến ngẫu nhiên 𝑋
với hàm mật độ xác suất 𝑝(𝑥) cho bởi:

                                 L(C) =        p(x)l(x)
                                          ∈𝒳

     Không mất tính tổng quát từ đây về sau ta giả sử bảng chữ cái D-phân là: 𝒟 =
{0, 1, … , D − 1}.
    Định nghĩa: Một mã được gọi là không kỳ dị (nonsingular) nếu
                              x ≠ x → C(x ) ≠ C(x )
    Mã không kỳ dị là đủ để mô tả không nhập nhằng các giá trị đơn lẻ của X. Tuy
nhiên ta thường cần gửi dãy giá trị của X. Trong trường hợp đó ta có thể đảm bảo
tính giải mã được bằng cách thêm một ký hiệu đặc biệt (“dấu phảy”) vào giữa hai từ
mã liền nhau. Nhưng cách này là không hiệu quả.
    Định nghĩa: Mở rộng 𝐶 ∗ của một mã 𝐶 là ánh xạ từ tập các xâu độ dài hữu hạn
trên bảng chữ cái 𝒳 vào tập các xâu độ dài hữu hạn trên bảng chữ cái 𝒟:
                         C(x x … x ) = C(x )C(x ) … C(x )

                                                                                  79
    Định nghĩa: Một mã được gọi là tách được (uniquely decodable) nếu mở rộng
của nó là không kỳ dị.
    Nói cách khác, mọi xâu mã tạo bởi một mã tách được chỉ có một xâu nguồn sinh
ra nó. Tuy nhiên sẽ có nhiều mã tách được không cho phép giải mã hiệu quả do ta có
thể phải xem xét toàn bộ xâu mã để xác định một ký hiệu nguồn.
    Định nghĩa: Một mã được gọi là mã tiền tố (prefix code hay instantaneous code)
nếu không từ mã nào là tiền tố của một từ mã khác.
    Mã tiền tố cho phép giải mã hiệu quả mà không cần tham khảo đến các từ mã
tương lai do kết thúc của một từ mã là có thể nhận biết ngay được.




                                Hình 6.1. Minh họa các lớp mã




     Hình 6.1 minh hoạ các lớp mã vừa nêu ở trên và quan hệ giữa chúng. Hình oval
lớn nhất thể hiện lớp tất cả các mã có thể có, hình oval trong cùng thể hiện mã tiền
tố. Bảng 6.1 cho ta các ví dụ về mã nhị phân của biến ngẫu nhiên X nhận giá trị trong
tập {1, 2, 3, 4}. Ở cột thứ hai, mã kỳ dị, hiển nhiên ta sẽ mất thông tin khi dùng mã
này. Ở cột thứ ba, mã không kỳ dị, xét xâu mã 010. Giải mã xâu này ra ta được ba
khả năng 2, 14, và 31, do đó mã này là không tách được. Ở cột thứ tư, mã tách được,
để kiểm tra tính chất này ta có thể lấy bất kỳ xâu mã nào và bắt đầu giải mã từ đầu.
Nếu hai bit đầu là 00 hay 10, chúng có thể được giải mã ngay lập tức. Nếu hai bit
đầu là 11, ta lại phải xem xét các bit đằng sau. Nếu bit kế tiếp là 1, ký hiệu đầu tiên là
3. Nếu độ dài của dãy số 0 theo sau 11 là lẻ, từ mã đầu tiên phải là 110 và ký hiệu
nguồn đầu tiên phải là 4. Nếu độ dài dãy số 0 là chẵn, ký hiệu nguồn đầu tiên là 3.
Lặp lại cách làm này ta có thể kiểm tra mã này là tách được. Sardinas và Patterson đã



                                                                                       80
nghĩ ra một test hữu hạn cho tính tách được. Cách làm này được nêu ra như một bài
tập của chương này.


           X    Kỳ dị    Không kỳ dị nhưng Tách được nhưng            Tiền tố
                         không tách được   không tiền tố

           1        0        0                          10            0
           2        0        010                        00            10
           3        0        01                         11            110

           4        0        10                         110           111

                                 Bảng 6.1. Ví dụ về các loại mã



6.2. BẤT ĐẲNG THỨC KRAFT

     Định lý: Với bất kỳ mã tiền tố trên bảng chữ cái D-phân nào, các độ dài từ mã l1,
l2, …, lm phải thoả mãn:

                                             D    ≤1

     Ngược lại, cho trước một tập độ dài từ mã thỏa mãn bất đẳng thức trên, khi đó
tồn tại một mã tiền tố với các độ dài từ mã này.
     Chứng minh: Xét cây D-phân trong đó mỗi nút có D nút con. Giả sử nhánh cây
biểu diễn ký hiệu của từ mã. Ví dụ, D nhánh xuất phát từ nút gốc biểu diễn D giá trị
có thể có của ký hiệu đầu tiên của từ mã. Mỗi từ mã được biểu diễn bởi một lá trên
cây. Đường đi từ gốc đền lá cho ta các ký hiệu của từ mã. Một ví dụ về cây nhị phân
được cho trong Hình 6.2. Điều kiện tiền tố đối với các từ mã ngụ ý rằng không từ mã
nào là tổ tiên của từ mã khác trên cây.




                                                                                   81
                          Hình 6.2. Cây mã cho bất đẳng thức Kraft

    Giả sử lmax là độ dài của từ mã dài nhất trong tập từ mã. Xét tất cả các nút trên
cây ở mức lmax. Một số trong đó là từ mã, một số là hậu duệ của từ mã, và một số
không thuộc hai trường hợp trên. Một từ mã ở mức li có D                hậu duệ ở mức
lmax. Các tập hậu duệ này là không giao nhau. Và tổng số nút trong những tập này
phải nhỏ hơn hoặc bằng D       . Do đó, lấy tổng theo tất cả các từ mã ta có:

                                       D           ≤D

    hay

                                             D     ≤1

    Ta có bất đẳng thức Kraft.
     Ngược lại, cho trước tập độ dài từ mã l1, l2, …, lm thỏa mãn bất đẳng thức Kraft,
ta luôn có thể xây dựng được cây tương tự như cây trong Hình 6.3. Gán cho nút đầu
tiên ở độ sâu l1 từ mã thứ nhất, rồi xóa hậu duệ của nó khỏi cây. Sau đó gán cho nút
đầu tiên ở độ sâu l2 trong cây hiện thời từ mã thứ hai, v.v. Theo cách này ta xây dựng
được một mã tiền tố với các độ dài từ mã l1, l2, …, lm.
     Định lý: (Bất đẳng thức Kraft mở rộng) Bất đẳng thức trên là đúng với mã tiền
tố có vô hạn đếm được từ mã.
    Chú ý: Bất đẳng thức Kraft (và mở rộng của nó) đã được chứng minh là đúng cả
với mã tách được.


6.3. MÃ TỐI ƯU

     Định lý: Độ dài kỳ vọng L của mã tiền tố D-phân bất kỳ của biến ngẫu nhiên X
là lớn hơn hay bằng entropy HD(X).
                                        L ≥ H (X)
    Dấu bằng xảy ra khi và chỉ khi D         =p
    Chứng minh: Sự khác nhau giữa độ dài kỳ vọng và entropy là
                                                             1
                     L − H (X) =         pl −        p log
                                                             p
                                 =−          p log D     +       p log p

    Đặt r =       và c = ∑ D     , ta có :
              ∑

                                                   p
                          L − H (X) =            p log− log c
                                                    r
                                                        1
                                       = D(p||r) + log    ≥0
                                                        c

                                                                                   82
    Hiệu trên không âm là vì entropy tương đối không âm và c nhỏ hơn hoặc bằng 1
theo bất đẳng thức Kraft. Do đó L ≥ H (X) và dấu bằng xày ra nếu và chỉ nếu p =
D .
     Định nghĩa: Một phân phối xác suất được gọi là D-adic nếu mọi xác suất của nó
đều có dạng D-n với n nào đó. Do đó, ta có dấu bằng của bất đẳng thức trên nếu và
chỉ nếu phân phối của X là D-adic.
    Chứng minh trên cũng gợi ý cho ta một thủ tục để tìm mã tối ưu: Tìm phân phối
D-adic mà gần nhất (theo nghĩa entropy tương đối) với phân phối của X. Phân phối
này cho ta thông tin về tập độ dài từ mã. Sau đó ta xây dựng mã bằng thủ tục chứng
minh phần đảo của định lý Kraft là xong. Mã tìm được sẽ là tối ưu.
    Tuy nhiên, thủ tục tìm phân phối D-adic là không đơn giản. Trong phần tới ta sẽ
học một thủ tục đơn giản (mã Huffman) cho phép tìm ra mã tối ưu thực sự.


6.4. CÁC CẬN CỦA ĐỘ DÀI MÃ TỐI ƯU

    Ta sẽ chứng minh rằng:
                                 H(X) ≤ L < 𝐻(X) + 1
    Theo định lý trong phần 6.3, L = H khi p = D        hay l = log    . Vì log   có thể
không phải là số nguyên, ta làm tròn nó bằng cách sau:
                                                1
                                      l = log
                                                p
   Trong đó ⌈x⌉ là số nguyên nhỏ nhất lớn hơn hay bằng x. Khi đó các li vẫn thỏa
mãn bất đẳng thức Kraft vì:

                            D         ≤    D        =     p =1

    Các li cũng thỏa mãn:
                                      1           1
                                log     ≤ l < log   +1
                                      p           p
    Nhân các vế với pi và lấy tổng theo i ta có:
                                H (X) ≤ L < H (X) + 1


    Định lý: Giả sử l∗ , l∗ , … , l∗ là các độ dài từ mã tối ưu cho một phân phối nguồn p
và một bảng chữ cái D-phân, và giả sử L* là độ dài kỳ vọng tương ứng. Khi đó:
                                H (X) ≤ L∗ < H (X) + 1
    Chứng minh: Dựa vào chứng minh trên.




                                                                                      83
    Định lý: (mã sai) Giả sử biến ngẫu nhiên X có phân phối p(x) được mã bằng mã
có độ dài xác định bởi (x) = log       ( )
                                             . Khi đó:

                      H(p) + D(p||q) ≤ E l(X) < 𝐻(p) + D(p||q) + 1
    Chứng minh: Dành cho sinh viên.


6.5. MÃ HUFFMAN

    Huffman đã đề xuất một thuật toán đơn giản cho phép tìm ra mã tiền tố tối ưu
cho một phân phối. Mã là tối ưu theo nghĩa độ dài kỳ vọng của nó nhỏ hơn độ dài
kỳ vọng của mã bất kỳ trên cùng bảng chữ cái. Sau đây ta sẽ xem xét một số ví dụ
trước khi đi vào chứng minh hình thức.
    Ví dụ 1: Xét một biến ngẫu nhiên 𝑋 nhận giá trị trong tập 𝑋 = {1, 2, 3, 4, 5} với
xác suất lần lượt là 0.25, 0.25, 0.2, 0.15, 0.15. Ta thấy rằng mã nhị phân tối ưu cho 𝑋
phải có các từ mã dài nhất ứng với các ký hiệu 4 và 5. Thêm vào đó các từ mã này
phải có cùng độ dài, nếu không ta có thể xóa đi một bit thuộc từ mã dài hơn để được
mã tiền tố có độ dài kỳ vọng ngắn hơn.

        Độ dài
               Từ mã      X            Xác suất và cây mã
        từ mã

          2      01       1     0.25                 0.3                  0.45                  0.55   0    0.55
                                                                                        0               1
          2      10       2     0.25                  0.25                0.3                   0.45
                                                             1 0




                                                                                        1
                                         10




          2      11       3     0.2                   0.25                0.25

          3     000       4     0.15                  0.2

          3     001       5     0.15



    Độ dài trung bình là 2.3 bit.
    Ví dụ 2: Xét mã tam phân cho biến ngẫu nhiên 𝑋 trong ví dụ 1. Khi đó độ dài
trung bình của mã sẽ là 1.5 chữ số tam phân.
                        Từ mã     X                 Xác suất và cây mã
                          1       1          0.25              0.5              0           1
                                                                                    1
                          2       2          0.25                  0.25
                                                      21 0




                                                                           2




                          00      3           0.2                  0.25

                          01      4          0.15

                          02      5          0.15




                                                                                                                   84
    Chú ý: Nếu D ≥ 3, ta có thể không có đủ số ký hiệu để kết hợp chúng một lần.
Khi đó ta thêm các ký hiệu giả (dummy) vào cuối tập ký hiệu. Các ký hiệu giả này có
xác suất bằng 0 và được chèn để làm đầy cây.


6.6. SỰ TỐI ƯU CỦA MÃ HUFFMAN

Chúng ta sẽ chứng minh rằng mã Huffman nhị phân là tối ưu dựa trên phương
pháp quy nạp. Một chú ý quan trọng là có rất nhiều mã tối ưu, chẳng hạn như đảo
ngược các bit hoặc tráo đổi hai từ mã cùng độ dài sẽ cho ra một mã tối ưu khác. Cách
làm của Huffman tạo ra một mã tối ưu như vậy. Để chứng minh sự tối ưu của mã
Huffman, chúng ta sẽ chứng minh một vài tính chất của một mã tối ưu bất kỳ.

Không mất tính tổng quát, chúng ta giả sử rằng các xác suất được sắp xếp theo thứ
tự nhất định, cụ thể là p1 ≥ p2 ≥ … ≥ pm. Cần nhớ lại rằng một mã được gọi là tối ưu
nếu như ∑pili là nhỏ nhất.

Bổ đề 6.6.1    Với bất kỳ phân phối nào, đều tồn tại một mã tiền tố tối ưu (với độ dài
kỳ vọng nhỏ nhất) thỏa mãn các tính chất sau:

   1. Độ dài được sắp xếp ngược với xác suất (nghĩa là nếu 𝑝 > 𝑝 thì 𝑙 < 𝑙 )
   2. Hai từ mã dài nhất có cùng độ dài.
   3. Hai trong số những từ mã dài nhất chỉ khác nhau ở bit cuối cùng và tương
       ứng với hai ký hiệu ít khả năng nhất.

Chứng minh:

Để chứng minh, ta sử dụng các thao tác hoán chuyển mã, cắt mã và sắp xếp lại thứ
tự như ví dụ trong Hình 6.3. Chúng ta giả sử rằng 𝑝 ≥ 𝑝 ≥ ⋯ ≥ 𝑝          . Phần (a) là
một mã tức thời cho trước. Bằng cách cắt các nhánh không có anh chị em, chúng ta
cải tiến mã thành (b). Chúng ta tiếp tục sắp xếp lại cây như hình (c), do dó độ dài từ
được sắp xếp theo thứ tự tăng dần từ đỉnh xuống dưới đáy. Cuối cùng, chúng ta đổi
chỗ các xác suất để cải tiến độ sâu kỳ vọng của cây, được minh họa ở hình (d). Mọi
mã tối ưu có thể được sắp xếp lại và hoán đổi thành dạng chuẩn như trong (d), ở
đây l1 ≤l2 ≤…≤ lm-1 = lm và 2 từ mã chỉ khác nhau ở bit cuối cùng

Sau đây ta sẽ lần lượt chứng minh ba tính chất trong bổ đề. Ta xét mã tối ưu Cm.

Nếu pj > pk thì lj ≤ lk. Chúng ta hoán chuyển hai từ mã j và k của Cm được mã mới là
C’m, khi đó:

                       𝐿 𝐶′   − 𝐿 (𝐶 ) =     𝑝 𝑙′ −    𝑝𝑙


                                                                                   85
                                          =𝑝 𝑙 +𝑝 𝑙 −𝑝 𝑙 −𝑝 𝑙
                                          = (𝑝 − 𝑝 )(𝑙 − 𝑙 )




                       Hình 6.3: Minh họa các phép biến đổi mã



Nhưng 𝑝 – 𝑝 > 0, và bởi vì Cm là tối ưu, 𝐿 𝐶 ′   − 𝐿 (𝐶   )   ≥ 0. Do đó chúng ta phải có
lk ≥lj. Do vậy Cm thỏa mãn tính chất 1.

Hai từ dài nhất có cùng độ dài: Ở đây, chúng ta cắt các từ mã. Nếu hai từ mã dài
nhất không có cùng độ dài, ta có thể cắt bit cuối cùng của từ mã dài hơn trong khi
vẫn đảm bảo tính chất tiền tố và đạt được độ dài kỳ vọng ngắn hơn. Do đó, hai từ
mã dài nhất phải có cùng độ dài. Áp dụng tính chất 1, từ mã dài nhất phải thuộc về
ký hiệu nguồn ít khả năng nhất.

Hai từ mã dài nhất chỉ khác nhau ở bit cuối cùng và tương ứng với hai ký hiệu ít
khả năng nhất: Không phải tất cả các mã tối ưu thỏa mãn tính chất này, nhưng bằng
cách sắp xếp lại, chúng ta có thể tìm ra mã tối ưu thỏa mãn. Nếu như có một từ mã
với độ dài lớn nhất mà không có anh em, chúng ta có thể xóa đi bit cuối cùng của từ
mã và vẫn thỏa mãn được tính chất tiền tố. Điều này làm giảm độ dài trung bình của
từ mã và mâu thuẫn với sự tối ưu của mã. Do vậy, mỗi từ mã có độ dài lớn nhất
trong bất cứ mã tối ưu nào đều phải có anh em. Bây giờ, chúng ta có thể hoán đổi các
từ mã dài nhất sao cho hai ký hiệu nguồn xác suất thấp nhất được gắn với hai anh
em trên cây. Cách làm này không thay đổi độ dài kỳ vọng ∑𝑝 𝑙 . Do đó, các từ mã


                                                                                      86
cho hai ký hiệu nguồn xác suất thấp nhất sẽ có độ dài lớn nhất và giống nhau toàn
bộ ngoại trừ bit cuối.

Tóm lại, chúng ta vừa chỉ ra rằng nếu p1 ≥ p2 ≥ … ≥ pm , thì tồn tại một mã tối ưu với l1
≤l2 ≤…≤ lm-1 = lm , và từ mã 𝐶(𝑥 – 1) và 𝐶(𝑥 ) chỉ khác nhau duy nhất ở bit cuối cùng.

Theo cách trên, chúng ta vừa chỉ ra rằng tồn tại một mã tối ưu thoả mãn các tính chất
ở trong bổ đề 6.6.1. Chúng ta gọi những mã như thế là mã tiêu chuẩn. Với bất kỳ
hàm phân phối xác suất cho bảng chữ cái có cỡ là m, p = (p1, p2,…,pm) với p1 ≥ p2 ≥ …
≥ pm, chúng ta định nghĩa phép rút gọn Huffman p’ = (p1, p2,…,pm-2, pm-1+pm) trên
bảng chữ cái với kích thước m-1 (Hình 6.4). Gọi 𝐶 ∗     (𝑝′ ) là mã tối ưu cho p’, và coi
𝐶 ∗ (𝑝) là mã tối ưu tiêu chuẩn cho p.

Định lý 6.6.1: (Mã Huffman là tối ưu) Nếu 𝐶 ∗ là một mã Huffman và 𝐶’ là một mã tách
được bất kỳ, ta có 𝐿(𝐶 ∗ ) ≤ 𝐿(𝐶’).

Chứng minh: Việc chứng minh tính chất tối ưu sẽ dẫn theo hai xây dựng: Trước hết,
chúng ta mở rộng mã tối ưu cho p’ để tạo nên một mã cho p và sau đó




 Hình 6.4. Các bước quy nạp cho mã hóa Huffman. Cho p1 ≥ p2 ≥ … ≥ p5. Một mã tối
 ưu tiêu chuẩn được minh họa trong (a). Kết hợp 2 xác suất thấp nhất, chúng ta thu
  được mã trong (b). Sắp xếp lại các giá trị xác suất theo thứ tự giảm dần, chúng ta
                     được mã tiêu chuẩn trong (c) cho m-1 ký hiệu.




                                                                                      87
chúng ta làm giảm (condense) mã tối ưu cho p để tạo thành một mã cho rút gọn mã
Huffman p’. Sự so sánh độ dài từ trung bình cho 2 mã tạo nên việc một mã tối ưu
cho p có thể được tạo ra bằng cách mở rộng mã tối ưu cho p’.

Từ mã tối ưu cho p’, chúng ta hình thành mã mở rộng cho m thành phần như sau:
Lấy từ mã trong C*m tương ứng với trọng số pm-1+pm mà mở rộng nó bằng cách thêm
0 vào công thức (form) hình thành từ mã cho ký hiệu m-1 và thêm 1 vào công thức
hình thành từ mã cho ký hiệu m. Cách thức hình thành được minh họa như sau:

                       𝑪∗ (𝒑 )                            𝑪(𝒑)
          𝑝              𝑤                     𝑙         𝑤 =𝑤                 𝑙 =𝑙
          𝑝             𝑤                      𝑙         𝑤 =𝑤                 𝑙 =𝑙
          …              …                     …           …                    …
      𝑝                𝑤                   𝑙           𝑤   =𝑤               𝑙   =𝑙
  𝑝       +𝑝           𝑤                   𝑙           𝑤   =𝑤   0        𝑙     =𝑙  +1
                                                        𝑤 =𝑤   1           𝑙 =𝑙    +1


Tính toán độ dài trung bình ∑I p’il’I chỉ ra:

                                 𝐿(𝑝) = 𝐿∗ (𝑝’) + 𝑝     +𝑝

Tương tự như vậy, từ mã tiêu chuẩn cho p, chúng ta tạo ra mã cho p’ bằng cách kết
hợp các từ mã cho 2 ký hiệu có xác suất thấp nhất m-1 và m với xác suất tương ứng
là pm-1 và pm, 2 mã này là đoạn anh em bởi các tính chất của mã tiêu chuẩn. Mã mới
cho p’ có độ dài trung bình


                   𝐿 𝑝′ =          𝑝𝑙 +𝑝        (𝑙    − 1) + 𝑝 (𝑙 − 1)


                          =      𝑝𝑙 −𝑝         −𝑝

                          = 𝐿∗ (𝑝) − 𝑝         −𝑝

Cộng L(p) và L(p’), chúng ta có:

                              𝐿(𝑝’) + 𝐿(𝑝) = 𝐿∗ (𝑝’) + 𝐿∗ (𝑝)

Hoặc

                         (𝐿(𝑝’) – 𝐿∗ (𝑝’)) + (𝐿(𝑝) − 𝐿∗ (𝑝)) = 0




                                                                                    88
Bây giờ, xem xét hai số hạng trong đẳng thức trên. Bằng giả định, bởi vì 𝐿∗ (𝑝’) là độ
dài mã tối ưu cho 𝑝’, chúng ta có 𝐿(𝑝’) – 𝐿∗ (𝑝’) ≥ 0. Tương tự, độ dài của mở rộng
mã tối ưu cho 𝑝’ có độ dài trung bình tối thiểu như độ lớn của mã tối ưu cho 𝑝 [ví
dụ: 𝐿(𝑝)– 𝐿∗ (𝑝) ≥ 0]. Nhưng tổng của hai điều kiện không phủ định có thể duy nhất
là 0 nếu cả hai đều là 0, điều này chỉ ra rằng 𝐿(𝑝) = 𝐿∗ (𝑝) (ví dụ, phần mở rộng mã
tối ưu cho 𝑝 là tối ưu cho 𝑝).

Bởi thế, nếu chúng ta bắt đầu với một mã tối ưu cho 𝑝’ với 𝑚 − 1 ký hiệu và tạo ra
mã cho 𝑚 ký hiệu bằng cách mở rộng từ mã tương ứng với 𝑝          + 𝑝 , mã mới cũng
sẽ là tối ưu. Bắt đầu với mã cho 2 thành phần, trong đó trường hợp mã tối ưu là rất
rõ ràng, chúng ta có thể mở rộng quy nạp kết quả này để chứng minh định lý sau.

    Mặc dù chúng ta vừa chứng minh định lý cho bảng chữ cái nhị phân, chứng
minh có thể được mở rộng để thiết lập sự tối ưu của thuật toán mã hóa Huffman cho
bảng chữ cái D-ary. Một cách tình cờ, chúng ta nên để ý rằng mã Huffman là một
thuật toán tham lam mà trong đó nó kết hợp hai ký hiệu ít khả năng nhất ở mỗi
bước. Chứng mình ở trên chỉ tra rằng tối ưu cục bộ này lại đảm bảo tối ưu toàn cục
của mã kết quả.
    6.7 Mã Shannon-Fano-Elias

    Trong phần trên, ta đã thấy rằng các độ dài từ mã 𝑙(𝑥) = log           thỏa mã bất
                                                                     ( )
đẳng thức Kraft và do đó có thể được dùng để xây dựng một mã tách được. Trong
phần này ta sẽ tìm hiểu một thủ tục đơn giản sử dụng hàm phân phối tích lũy để xác
định từ mã.
   Không mất tính tổng quát, giả sử 𝒳 = {1, 2, … , 𝑚}, 𝑝(𝑥) > 0 với mọi x. Hàm
phân phối tích lũy được định nghĩa như sau:

                                   𝐹(𝑥) =     𝑝(𝑎)




                                                                                   89
                                   Hình 6.5. Hàm phân phối tích lũy

    Hàm này được minh họa trong Hình 6.5. Xét hàm phân phối tích lũy được sửa
đổi như sau:
                                                         1
                                       𝐹 (𝑥) =     𝑝(𝑎) + 𝑝(𝑥)
                                                         2

    Trong đó 𝐹 (𝑥) biểu diễn tổng xác suất của tất cả các ký hiệu nhỏ hơn x cộng với
một nửa xác suất của x. Vì biến ngẫu nhiên rời rạc, hàm phân phối tích lũy được
biểu diễn bởi các bước dài p(x). Giá trị của hàm 𝐹 (𝑥) là điểm giữa của bước tương
ứng với x.
    Vì tất cả các giá trị xác suất là dương, 𝐹 (𝑎) ≠ 𝐹 (𝑏) nếu 𝑎 ≠ 𝑏, và do đó ta có thể
xác định x nếu biết 𝐹 (𝑥). Do đó, giá trị của 𝐹 (𝑥) có thể được dùng làm mã cho x.
     Tuy nhiên, vì 𝐹 (𝑥) là một giá trị thực có thể cần một số vô hạn bit để biểu diễn,
sẽ không hiệu quả nếu dùng đúng giá trị 𝐹 (𝑥) làm mã. Nếu chúng ta dùng một giá
trị xấp xỉ, độ chính xác cần thiết là bao nhiêu?
    Giả sử ta giới hạn biểu diễn 𝐹 (𝑥) sử dụng l(x) bit (mô tả bởi ⌊𝐹 (𝑥)⌋ ( ) ). Cụ thể
hơn, ta sử dụng l(x) bit đầu tiên của 𝐹 (𝑥) để biểu diễn x. Ta có:
                                                                    1
                                       𝐹 (𝑥) − ⌊𝐹 (𝑥)⌋ (   )   <
                                                                   2(   )

      Nếu 𝑙(𝑥) = log     ( )
                               + 1 thì

                                   1         𝑃(𝑥)
                                   ( )
                                         <        = 𝐹 (𝑥) − 𝐹(𝑥 − 1)
                               2              2
    và do đó ⌊𝐹 (𝑥)⌋ (   )   nằm trong khoảng tương ứng với x. Như vậy, l(x) bit là đủ
để mô tả x.
    Bây giờ ta sẽ kiểm tra xem mã này có phải là mã tiền tố hay không. Để kiểm tra
tính chất tiền tố, ta coi mỗi từ mã 𝑧 𝑧 … 𝑧 tương ứng với không phải một điểm mà

                                                                                     90
cả khoảng [0. 𝑧 𝑧 … 𝑧 , 0. 𝑧 𝑧 … 𝑧 + ). Mã là tiền tố nếu và chỉ nếu các khoảng là
không giao nhau.
    Với mỗi từ mã, khoảng tương ứng của nó có độ dài 2 ( ) , nhỏ hơn một nửa
chiều cao của bước tương ứng với x. Đầu dưới của khoảng nằm trong nửa dưới của
bước. Do đó đầu trên của khoảng nằm dưới đỉnh của bước, và do vậy khoảng sẽ
nằm trọn trong bước. Do đó, khoảng tương ứng với các từ mã khác nhau là không
giao nhau và mã của chúng ta là có tính chất tiền tố. Chú ý rằng thuật toán xây dựng
mã này không yêu cầu các ký hiệu được sắp theo xác suất.

    Vì ta sử dụng 𝑙(𝑥) = log          ( )
                                            + 1 bit để biểu diễn x, độ dài kỳ vọng của mã sẽ là
                                                             1
                    𝐿=      𝑝(𝑥)𝑙(𝑥) =          𝑝(𝑥)( log        + 1) < 𝐻(𝑋) + 2
                                                            𝑝(𝑥)

    Như vậy, mã này đạt được độ dài từ mã trung bình không vượt quá 2 bit so với
entropy.
    Ví dụ:
    x        p(x)    F(x)       𝑭(𝒙)          𝑭(𝒙) nhị phân                     𝟏          Từ mã
                                                                  𝒍(𝒙) = 𝒍𝒐𝒈        +𝟏
                                                                               𝒑(𝒙)
    1        0.25    0.25     0.125           0.001               3                        001
    2        0.5     0.75     0.5             0.10                2                        10
    3        0.125   0.875    0.8125          0.1101              4                        1101

    4        0.125   1.0      0.9375          0.1111              4                        1111



     Xét ví dụ biến ngẫu nhiên có hàm phân phối mà các giá trị xác suất đều là
dyadic (bảng trên). Trong trường hợp này, độ dài từ mã trung bình là 2.75 bit, so với
entropy là 1.75 bit. Bạn có thể dễ dàng kiểm tra rằng, mã Huffman sẽ cho độ dài kỳ
vọng bằng entropy. Nhìn vào mã ta có thể thấy một vài điểm chưa tối ưu, ví dụ hai
bít cuối cùng của hai từ mã dài nhất có thể bỏ đi.
    Xét một ví dụ khác, hàm phân phối không phải là dyadic, trong đó một số giá trị
xác suất có thể cần được biểu diễn bằng một chuỗi vô hạn bit. Ta thể hiện 0.010101…
bằng 0. 01. Mã này có độ dài kỳ vọng lớn hơn 1.2 bit so với mã Huffman cho cùng
một nguồn.


        x    p(x)    F(x)     𝑭(𝒙)          𝑭(𝒙) nhị phân                   𝟏            Từ mã
                                                              𝒍(𝒙) = 𝒍𝒐𝒈        +𝟏
                                                                           𝒑(𝒙)
        1    0.25    0.25     0.125         0.001             3                          001
        2    0.25    0.5      0.375         0.011             3                          011



                                                                                                   91
       3   0.2    0.7    0.6      0.10011        4                                1001
       4   0.15   0.85   0.775    0.1100011      4                                1100

       5   0.15   1      0.925    0.1110110      4                                1110



     Thủ tục xây dựng mã Shannon-Fano-Elias cũng có thể được dùng cho dãy biến
ngẫu nhiên. Ý tưởng lả dùng hàm phân phối tích lũy của dãy, với độ chính xác phù
hợp, làm mã cho nó. Độ dài khối là n sẽ yêu cầu tính toán xác suất và hàm phân phối
tích lũy cho tất cả các chuỗi dài n. Khối lượng tính toán tăng theo hàm mũ theo n.
Tuy nhiên có một mẹo đơn giản đảm bảo rằng ta có thể tính cả xác suất và hàm mật
độ tích lũy khi ta nhìn thấy mỗi ký hiệu trong khối, do đó đảm bảo rằng độ phức tạp
tính toán chỉ tăng tuyến tính theo độ dài khối. Trong chương sau, ta sẽ tìm hiểu một
phương pháp mã hóa số học, là một mở rộng của mã Shannon-Fano-Elias, mà đảm
bảo sự hiệu quả khi mã hóa chuỗi biến. Phương pháp này là cơ sở của nhiều phương
pháp nén dữ liệu trong thực tế ví dụ như các chuẩn nén JPEG và FAX.
    6.8 Tính chất tối ưu cạnh tranh của mã Shannon
     Ta đã thấy rằng mã Huffman là tối ưu theo nghĩa độ dài kỳ vọng đạt giá trị cực
tiểu. Tuy nhiên tính tối ưu đó có đảm bảo rằng với mọi chuỗi dữ liệu vào, kết quả
nén đều đạt hiệu quả như nhau? Cụ thể hơn, mã này có luôn tốt hơn bất kỳ mã nào
khác trên bất kỳ chuỗi vào nào? Hiển nhiên là không, vì sẽ có các mã khác gán từ mã
ngắn cho các ký hiệu nguồn tần suất thấp. Các mã đó sẽ tốt hơn mã Huffman trên
các ký hiệu nguồn này.
     Trong thực tế, ví dụ khi đến các sân bay, ta có thể thấy các bảng hiệu cả tiếng
Anh và tiếng Việt, khi thì tiếng Anh dài hơn (ví dụ waiting room – phòng chờ) khi
thì tiếng Việt dài hơn (không hút thuốc – no smoking). Như vậy trong ví dụ này
tiếng Anh và tiếng Việt là tương đương “cạnh tranh” theo nghĩa mỗi ngôn ngữ ngắn
hơn trong một nửa số trường hợp.
    Để hình thức hóa câu hỏi về tối ưu cạnh tranh, xét trò chơi tổng bằng không hai
người chơi như sau: Cho trước một phân phối xác suất, người chơi cần thiết kế một
mã tức thời cho phân phối này. Với mỗi ký hiệu do phân phối này sinh ra, nếu từ mã
do người chơi A (hay B) đưa ra ngắn hơn của người chơi B (hay A) thì A (hay B)
được 1 điểm, dài hơn -1 điểm và bằng nhau 0 điểm.
    Vì ta không tính được độ dài từ mã của mã Huffman bằng công thức toán học,
ta sẽ xem xét mã Shannon với độ dài từ mã 𝑙(𝑥) = log           ( )
                                                                     . Ta có định lý sau:

    Định lý: Giả sử l(x) là độ dài từ mã của mã Shannon và l’(x) là độ dài từ mã của
một mã tách được bất kỳ khác, khi đó ta có:
                                                           1
                               𝑃(𝑙(𝑋) ≥ 𝑙 (𝑋) + 𝑐) ≤
                                                       2
    Ví dụ, xác suất để l’(X) ngắn hơn l(X) 5 bit là nhỏ hơn           .

                                                                                            92
    Chứng minh:
                                                    1
                     𝑃(𝑙(𝑋) ≥ 𝑙 (𝑋) + 𝑐) = 𝑃       log  ≥ 𝑙 (𝑋) + 𝑐
                                                  𝑝(𝑥)
                                                  1
                                         ≤ 𝑃(log      ≥ 𝑙 (𝑋) + 𝑐 − 1)
                                                 𝑝(𝑋)
                                         = 𝑃(𝑝(𝑋) ≤ 2 ( )       )
                                         =                               𝑝(𝑥)
                                             : ( )           ( )

                                                                             ( ) (   )
                                         ≤                               2
                                             : ( )           ( )

                                                           ( )       (   )
                                         ≤         2             2
                                               (       )
                                         ≤2
    vì ∑ 2   ( )
                   ≤ 1 theo bất đẳng thức Kraft.
     Như vậy, không mã nào có thể tốt hơn đáng kể so với mã Shannon trong mọi
trường hợp. Bây giờ ta sẽ tìm cách cải thiện kết quả này. Dưới quan điểm lý thuyết
trò chơi, ta muốn đảm bảo rằng l(x)<l’(x) thường xuyên hơn l(x)>l’(x). Việc 𝑙(𝑥) ≤
𝑙 (𝑥) + 1 với xác suất là chưa đảm bảo điều này.

    Định lý: Giả sử p(x) là hàm phân phối dyadic. Giả sử 𝑙(𝑥) = log                      ( )
                                                                                               là độ dài từ
mã Shannon nhị phân, l’(x) là độ dài từ mã của mã tách được bất kỳ cho nguồn này.
Khi đó:
                             𝑃 𝑙(𝑋) < 𝑙 (𝑋) ≥ 𝑃(𝑙(𝑋) > 𝑙 (𝑋))
    Dấu bằng xảy ra nếu và chỉ nếu l’(x)=l(x) với mọi x. Do đó, độ dài từ mã 𝑙(𝑥) =
log ( ) là tối ưu cạnh tranh duy nhất.

    Chứng minh: Ta định nghĩa hàm sgn(t) như sau:
                                                   1: 𝑡 > 0
                                    𝑠𝑔𝑛(𝑡) =       0: 𝑡 = 0
                                                   −1: 𝑡 < 0




                                                                                                        93
                         Hình 6.6 Đồ thị hai hàm 𝒔𝒈𝒏(𝒕) và 𝟐𝒕 − 𝟏




    Xem Hình 6.6 ta dễ thấy rằng
                         𝑠𝑔𝑛(𝑡) ≤ 2 − 1, 𝑡 = 0, ±1, ±2, …
     Chú ý là bất đẳng thức này chỉ đúng với t nguyên chứ không đúng với mọi giá
trị thực. Ta có:

        𝑃 𝑙 (𝑋) < 𝑙(𝑋) − 𝑃 𝑙 (𝑋) > 𝑙(𝑋) =                       𝑝(𝑥) −                            𝑝(𝑥)
                                                  : ( )   ( )                      : ( )    ( )

                                             =      𝑝(𝑥)𝑠𝑔𝑛(𝑙(𝑥) − 𝑙 (𝑥))

                                             = 𝐸 𝑠𝑔𝑛(𝑙(𝑋) − 𝑙 (𝑋))
                                             ≤      𝑝(𝑥)(2 (           )       ( )
                                                                                     − 1)

                                                          ( )
                                             =      2           (2 (       )    ( )
                                                                                      − 1)

                                                          ( )                        ( )
                                             =      2            −             2

                                                          ( )
                                             =      2            −1

                                             ≤1−1=0
   ở các biến đổi trên ta đã áp dụng bất đẳng thức về cận trên của 𝑠𝑔𝑛(𝑥) và bất
đẳng thức Kraft với 𝑙’(𝑥).
    Dấu bằng xảy ra khi và chỉ khi 𝑙’(𝑥) = 𝑙(𝑥) với mọi 𝑥. Bạn tự kiểm tra sự đúng
đắn điều kiện này bằng cách kiểm tra điều kiện dấu bằng xảy ra của các bất đẳng
thức đã áp dụng.
    Hệ quả: Với hàm phân phối không có tính chất dyadic, ta có:

                                                                                                         94
                                 𝐸 𝑠𝑔𝑛(𝑙(𝑋) − 𝑙 (𝑋) − 1) ≤ 0
    Trong đó 𝑙(𝑥) = log    ( )
                                  và 𝑙’(𝑥) là độ dài từ mã của mã bất kỳ khác.

    Chứng minh: tương tự như trên.


    ĐỌC THÊM
     Mã Huffman là tối ưu nếu chúng ta biết trước hàm phân phối. Vấn đề là trong
thực tế thường ta không biết trước hàm này và với mỗi loại dữ liệu sẽ có một phân
phối tương ứng. Cho đến thời điểm này, ta vẫn thường giả sử là biết trước hàm
phân phối, việc học ra phân phối từ dữ liệu là một vấn đề lớn và quan trọng mà ta sẽ
tìm hiểu một phần trong chương 10. Nếu ta giả sử là phân phối không đổi và chỉ
dùng một mã Huffman thì mã đó sẽ không tối ưu nữa, như đã phân tích trong phần
6.4. Còn nếu như mỗi khi phân phối thay đổi (giả sử ta biết được điều đó) mà ta lại
tính lại mã và gửi mã đó cùng với dữ liệu đã mã hóa thì cũng sẽ là một kiểu dư thừa
thông tin.
     Một vấn đề nữa với mã Huffman là cận trên 𝐻(𝑋) + 1 của nó. Một bit dôi ra
trông có vẻ vô hại nhưng thực tế lại không hề nhỏ vì 𝐿(𝐶) là độ dài trung bình cần
để biểu diễn mỗi ký hiệu. Cụ thể hơn, nếu 𝐻(𝑋) là lớn, thì một bit này có thể không
phải là dư thừa nhiều, tuy nhiên trong nhiều trường hợp, entropy chỉ cỡ khoảng một
bit hay thậm chí nhỏ hơn, khi đó ảnh hưởng sẽ là lớn. Lấy văn bản tiếng Việt làm ví
dụ, trong nhiều trường hợp, khi đã biết một phần xâu ký tự, phần còn lại là dễ dự
đoán. Ví dụ với xâu “lập trình hướng đ”, ta có thể đoán tám ký tự kế tiếp là “ối
tượng” với xác suất 0.99 mỗi ký tự. Tiếp cận Huffman bắt buộc sử dụng ít nhất một
bit cho mỗi ký tự, dẫn đến để mã xâu đó cần tám bit trong khi thực sự chỉ nên dùng
chính xác 0.13 bit để biểu diễn cả xâu con gồm tám ký tự. Như đã chỉ ra trong bài
báo của Shannon năm 1948, nếu dùng mô hình thống kê đủ tốt thì với tiếng Anh,
entropy chỉ khoảng một bit mỗi ký tự, do đó mã Huffman là không hiệu quả nếu
dùng nó để mã hóa từng ký tự riêng lẻ trong trường hợp này.
     Một giải pháp kỹ thuật cho vấn đề trên là dùng mã Huffman để mã hóa theo
khối n ký hiệu. Khi đó độ vượt quá mỗi khối là không quá 1 bit, do đó độ vượt quá
mỗi ký hiệu sẽ không quá 1/𝑛 bit. Với kích thước khối đủ lớn thì vấn đề 1 bit vượt
quá coi như không tồn tại. Tuy nhiên sẽ có hai khía cạnh phát sinh: thứ nhất là mất
đi tính đơn giản và đẹp đẽ của mã hóa và giải mã (tức thời) của mã Huffman; thứ
hai là ta cần tính xác suất tất cả các xâu liên quan và xây dựng cây Huffman tương
ứng, trong khi thực tế nhiều xâu trong đó sẽ rất ít xuất hiện.


    BÀI TẬP
    Bài 6.1. Xét mã {0, 10, 01}
    a) Mã này có phải là mã tiền tố không?

                                                                                 95
    b) Mã này có phải là mã không kỳ dị không?
    c) Mã này có phải là mã có một cách giải không?
    d) Liệu có tồn tại mã tiền tố cùng độ dài từ mã với mã này không? Nếu có hãy
       chỉ ra một mã như vậy.
    Bài 6.2. Mã Huffman
    Cho biến ngẫu nhiên:
                      𝑥    𝑥    𝑥             𝑥      𝑥       𝑥    𝑥
                𝑋=
                     0.49 0.26 0.12          0.04   0.04    0.03 0.02
    a) Tìm mã Huffman nhị phân cho X.
    b) Tính độ dài kỳ vọng của mã này.
    c) Tìm mã Huffman tam phân cho X.
    Bài 6.3. Mã tồi
    Mã nào dưới đây không thể là mã Huffman với bất kỳ phân phối xác suất nào?
    a) {0, 10, 11}
    b) {00, 01, 10, 110}
    c) {01, 10}
    Bài 6.4. Entropy tương đối là giá của việc chọn mã không phù hợp
    Giả sử X là biến ngẫu nhiên có giá trị thuộc {1, 2, 3, 4, 5}. p(x) và q(x) là hai phân
phối có thể có của X:




                           Ký hiệu   p(x)   q(x)    C1(x)     C2(x)

                              1       1      1        0         0
                                      2      2
                              2       1      1       10        100
                                      4      8
                              3       1      1       110       101
                                      8      8
                              4       1      1      1110       110
                                      16     8
                              5       1      1      1111       111
                                      16     8


    a) Tính H(p), H(q), D(p||q) và D(q||p).
    b) Kiểm tra rằng C1 là tối ưu cho p và C2 là tối ưu cho q.
    c) Giả sử dùng C2 cho p, khi đó độ dài từ mã trung bình là bao nhiêu? Nó lớn
       hơn entropy của p bao nhiêu?

                                                                                       96
    d) Tương tự câu c nhưng dùng C1 cho q.
    Bài 6.5. Hai mươi câu hỏi Huffman
    Xét tập n đối tượng. Giả sử Xi bằng 1 hay 0 tùy thuộc vào đối tượng thứ i là tốt
hay có khiếm khuyết. Giả sử dãy 𝑋 , 𝑋 , … , 𝑋 là độc lập với 𝑃(𝑋 = 1) = 𝑝 và 𝑝 >
𝑝 > ⋯ > 𝑝 > . Ta được yêu cầu xác định tập tất cả các đối tượng bị khiếm khuyết.
Bạn có thể dùng bất cứ loại câu hỏi có-không nào.
    a) Đưa ra một cận dưới tốt của số câu hỏi trung bình tối thiểu cần thiết để đạt
       mục đích trên.
    b) Nếu dãy câu hỏi dài nhất được yêu cầu bởi các câu trả lời của tự nhiên, câu
       hỏi cuối cùng ta nên đưa ra là gì? Hai tập mà ta đang phân biệt với câu hỏi
       này là gì? Giả sử một dãy câu hỏi ngắn gọn (độ dài trung bình cực tiểu).
    c) Đưa ra một cận trên về số câu hỏi trung bình tối thiểu cần thiết.
    Bài 6.6. Bất đẳng thức Kraft
    Một mã tức thời có các độ dài từ mã 𝑙 , 𝑙 , … , 𝑙 mà thỏa mãn bất đẳng thức chặt

                                        𝐷       <1

    Bảng chữ cái của mã là 𝒟 = {0,1,2, … , 𝐷 − 1}. Chứng minh rằng tồn tại các chuỗi
ký hiệu dài tùy ý trong 𝒟 ∗ mà không thể giải mã thành dãy từ mã.
    Bài 6.7. Nén tối ưu đơn giản của một nguồn Markov
    Xét quá trình Markov ba trạng thái 𝑈 , 𝑈 , … với ma trận xác suất chuyển sau:
                                   Un
                           Un-1           S1         S2   S3

                                   S1       1        1    1
                                            2        4    4
                                   S2       1        1    1
                                            4        2    4
                                   S3       0        1    1
                                                     2    2


     Theo ma trận trên, xác suất mà S1 theo sau S3 là bằng không. Thiết kế ba mã C1,
C2, C3, mỗi mã cho một trạng thái 1, 2, và 3. Mỗi mã ánh xạ các phần tử của tập các Si
thành các dãy gồm 0 và 1 sao cho quá trình Markov này có thể được gửi với nén cực
đại bởi lược đồ sau.
    a) Ghi ký hiệu hiện tại 𝑋 = 𝑖.
    b) Chọn mã Ci
    c) Ghi ký hiệu kế tiếp 𝑋   = 𝑗 và gửi từ mã trong Ci ứng với j.



                                                                                    97
    d) Lặp lại với ký hiệu kế tiếp. Độ dài thông điệp trung bình của ký hiệu kế tiếp
       với điều kiện trạng thái trước đó 𝑋 = 𝑖 sử dụng cách mã hóa này là bao
       nhiêu? Số bít trung bình không điều kiện mỗi ký hiệu nguồn là bao nhiêu?
       Liên hệ đại lượng này với tỉ lệ entropy 𝐻(𝒰) của xích Markov.
    Bài 6.8. Mã Shannon và mã Huffman

    Xét một biến ngẫu nhiên X mà nhận bốn giá trị với xác suất    , , ,   .

    a) Xây dựng mã Huffman cho biến này.
    b) Chứng minh rằng tồn tại hai tập độ dài từ mã tối ưu khác nhau. Cụ thể hơn
       chứng minh rằng các tập độ dài (1, 2, 3, 3) và (2, 2, 2, 2) đều là tối ưu.
    c) Kết luận rằng có các mã tối ưu với độ dài từ mã của một số ký hiệu vượt quá
       độ dài mã Shannon log    ( )
                                      .

    Bài 6.9. Mã Huffman
   Cho biến ngẫu nhiên X nhận 6 giá trị {A, B, C, D, E, F} với các xác suất tương
ứng là 0.5, 0.25, 0.1, 0.05, 0.05, 0.05.
    a) Hãy xây dựng một mã Huffman nhị phân cho biến ngẫu nhiên này. Tính độ
       dài kỳ vọng của mã vừa xây dựng được.
    b) Hãy xây dựng mã Huffman tứ phân cho biến ngẫu nhiên trên (sử dụng 4 ký
       tự a, b, c, d để biểu diễn mã). Tính độ dài trung bình của mã vừa xây dựng.
    c) Một cách khác để xây dựng mã nhị phân cho biến ngẫu nhiên X là bắt đầu
       bằng mã tứ phân và chuyển đổi chúng sang mã nhị phân (chuyển đổi các ký
       tự) bằng cách sử dụng các chuyển đổi tương ứng a -> 00, b-> 01, c-> 10, d->11.
       Tính độ dài trung bình của mã nhị phân được tạo ra từ quá trình chuyển đổi
       này cho biến ngẫu nhiên ban đầu.
    d) Với biến ngẫu nhiên bất kỳ X, gọi LH là độ dài trung bình của mã nhị phân
       Huffman cho biến ngẫu nhiên X, và gọi LQB là độ dài mã trình bình của mã
       nhị phân được tạo ra bằng quá trình chuyển đổi từ mã tứ phân như đề cập ở
       câu trên. Chứng minh rằng:
                                𝐿 ≤ 𝐿      <𝐿 +2
    e) Cận dưới ở ví dụ trên là chặt chẽ. Hãy đưa ra một ví dụ trong đó mã được
       thiết lập bằng cách chuyển đổi mã tứ phân tối ưu sang mã nhị phân và mã
       nhị phân nhận được cũng là mã tối ưu.
    f) Cận trên chưa thực sự chặt. Thực ra, cận trên tốt hơn là 𝐿 ≤ 𝐿 + 1. Hãy
       chứng minh cận trên này và đưa ra một ví dụ trong đó cận này thực sự chặt.
    Bài 6.10. Rượu hỏng
     Một người được tặng sáu chai rượu. Biết rằng có đúng một chai bị hỏng (mất
mùi, vị). Bằng cách kiểm tra, ta biết được thêm rằng xác suất hỏng của các chai rượu
là (𝑝 , 𝑝 , … , 𝑝 ) = ( , , , , , ). Thử sẽ giúp xác định chai rượu hỏng. Giả sử
mỗi lần bạn thử đúng một chai. Chọn thứ tự thử để cực tiểu hóa số lượng phép thử

                                                                                  98
trung bình cần để xác định chai hỏng. Chú ý là nếu thử đến chai thứ năm mà vẫn
chưa thấy chai hỏng thì không cần thử chai cuối cùng nữa.
    a) Số lượng lần thử kỳ vọng là bao nhiêu?
    b) Chai nào nên được thử trước?
    Bây giờ giả sử bạn trở nên thông minh hơn. Bạn trộn rượu lấy từ một số chai
trong một cốc sạch và thử hỗn hợp đó. Bạn cứ lặp lại như vậy, trộn và thử, dừng lại
khi đã xác định được chai hỏng.
   a) Số lượng lần thử kỳ vọng nhỏ nhất là bao nhiêu?
   b) Hỗn hợp nào nên được thử trước?
    Bài 6.11. Phép thử Sardinas-Patterson để kiểm tra tính tách được
   Một mã là không tách được nếu và chỉ nếu tồn tại một dãy hữu hạn các ký hiệu
mã mà có thể được phân tách thành dãy từ mã theo hai cách khác nhau. Chẳng hạn
như:



    Trong đó Ai, Bi là các từ mã. Chú ý là B1 là tiền tố của A1 và phần còn lại của A1
là một hậu tố. Mỗi hậu tố đến lượt nó lại là tiền tố của một từ mã hay có một từ mã
khác làm tiền tố của nó, dẫn đến một hậu tố khác. Cứ như vậy, hậu tố cuối cùng
phải là một từ mã. Do đó, ta có thể thiết lập một phép thử tính chất tách được như
sau: Xây dựng một tập S gồm tất cả các hậu tố có thể có. Mã là tách được nếu và chỉ
nếu S không chứa từ mã nào.
    a) Đưa ra các qui tắc chính xác (thuật toán) để xây dựng tập S.
    b) Giả sử các độ dài từ mã là li, i = 1, 2, …, m. Tìm một cận trên tốt của số lượng
       phần tử trong S.
    c) Xác định xem các mã nào sau đây là tách được:
      (i)    {0, 10, 11}
      (ii)   {0, 01, 11}
      (iii) {0, 01, 10}
      (iv) {0, 01}
      (v)    {00, 01, 10, 11}
      (vi) {110, 11, 10}
      (vii) {110, 11, 100, 00, 10}
    d) Với mỗi mã tách được trong phần c, xây dựng (nếu có thể) một dãy mã vô
       hạn với một điểm bắt đầu xác định sao cho nó có thể tách thành các từ mã
       theo hai cách khác nhau. Điều này minh họa rằng tách được không bao hàm
       có thể giải mã hữu hạn. Chứng minh rằng dãy như vậy không thể xuất hiện
       với mã tiền tố.
    Bài 6.12. Trò chơi Hi-Lo



                                                                                    99
    a) Một máy tính sinh số X theo một hàm phân phối p(x) đã biết, 𝑥 ∈
       {1,2, … ,100}. Người chơi có thể đặt câu hỏi “X = i hay không?”, và câu trả lời
       có thể là “Có”, “Số lớn quá”, hay “Số nhỏ quá”. Việc hỏi đáp được lặp lại sáu
       lần. Nếu người chơi đoán đúng trong khi chơi, anh ta sẽ nhận được giải
       thưởng giá trị v(X). Người chơi nên chơi thế nào để cực đại hóa kết quả kỳ
       vọng?
    b) Phần a không có nhiều cái để làm với lý thuyết thông tin. Xét biến thể sau:
       X~p(x), giải thưởng = v(x), p(x) là biết trước. Tuy nhiên các câu hỏi có-không
       tùy ý được đưa ra tuần tự cho tới khi xác định được X. (“được xác định”
       không có nghĩa nhận được câu trả lời “Có”). Mỗi lần hỏi có giá là 1. Người
       chơi nên chơi như thế nào? Kết quả kỳ vọng là bao nhiêu?
    c) Tiếp tục phần b, sẽ thế nao nếu v(x) là cố định nhưng p(x) có thể được chọn
       bởi máy tính (và sau đó nói cho người chơi biết)? Máy tính muốn cực tiểu
       hóa kết quả kỳ vọng của người chơi. Khi đó p(x) nên như thế nào? Kết quả
       kỳ vọng của người chơi là bao nhiêu?
    Bài 6.13. Mã tối ưu cho phân phối đều
   Xét một biến ngẫu nhiên có thể nhận m giá trị với cùng khả năng. Entropy của
nguồn thông tin này hiển nhiên là logm bit.
    a) Mô tả mã tiền tố nhị phân tối ưu cho nguồn này và tính độ dài từ mã trung
       bình Lm.
    b) Với giá trị nào của m độ dài từ mã trung bình Lm bằng với entropy H = logm?
    Ta biết rằng L < H + 1 với bất kỳ phân phối nào. Lượng dư thừa của một mã độ
dài biến đổi được định nghĩa là 𝜌 = 𝐿 − 𝐻. Với (những) giá trị nào của m, 2 ≤ 𝑚 ≤
2 , lượng dư thừa của mã là cực đại. Giá trị giới hạn của lượng dư thừa tồi nhất
này khi m tiến ra vô cùng là bao nhiêu?
    Bài 6.14. Mã tối ưu cho phân phối dyadic
    Với một cây mã Huffman, định nghĩa xác suất của một nút bằng tổng xác suất
của các nút lá bên dưới nút đó. Giả sử biến ngẫu nhiên X được sinh ra bởi một phân
phối dyadic (𝑝(𝑥) = 2 với mọi x thuộc 𝒳). Bây giờ xét một mã Huffman nhị phân
cho phân phối này:
    a) Lập luận rằng với bất kỳ nút nào trên cây, xác suất của con trái bằng với xác
       suất của con phải.
    b) Giả sử 𝑋 , 𝑋 , … , 𝑋 được sinh ra độc lập cùng phân phối p(x). Sử dụng mã
       Huffman cho p(x), ta ánh xạ 𝑋 , 𝑋 , … , 𝑋 thành dãy bit 𝑌 , 𝑌 , … 𝑌 trong đó k
       phụ thuộc 𝑋 , 𝑋 , … , 𝑋 . Sử dụng phần a để lập luận rằng 𝑌 , 𝑌 , … tạo thành
       một dãy phép gieo đồng xu (𝑃(𝑌 = 0) = 𝑃(𝑌 = 1) = , độc lập với
       𝑌 , 𝑌 , … , 𝑌 ). Do đó tỉ lệ entropy của dãy mã này là 1 bit mỗi ký hiệu.
    c) Bạn hãy đưa ra một lập luận heuristic rằng tại sao dãy bit mã sử dụng bất kỳ
       mã nào đạt cận dưới entropy không thể nén và do đó nên có tỉ lệ entropy 1
       bit mỗi ký hiệu.

                                                                                  100
    Bài 6.15. Mã Huffman chọi mã Shannon
    Một biến ngẫu nhiên X có thể nhận ba giá trị với xác suất 0.6, 0.3, và 0.1.
    a) Các độ dài từ mã của mã Huffman nhị phân của X là bao nhiêu? Các độ dài
       từ mã của mã Shannon nhị phân là bao nhiêu? (𝑙(𝑥) = log          ( )
                                                                              )
    b) Tìm số nguyên D nhỏ nhất sao cho độ dài từ mã Shannon (với bảng chữ cái
       D-phân) kỳ vọng bằng với độ dài từ mã Huffman (cũng với với bảng chữ cái
       D-phân) kỳ vọng.
    Bài 6.16. Mã tối ưu
    Giả sử 𝑙 , 𝑙 , … , 𝑙 là các độ dài từ mã Huffman nhị phân cho các xác suất 𝑝 ≥
𝑝 ≥ ⋯ ≥ 𝑝 . Giả sử rằng ta có một phân phối mới bằng cách phân chia xác suất
cuối cùng. Ta có thể nói gì về các độ dài từ mã nhị phân tối ưu 𝑙 , 𝑙 , … , 𝑙 cho các
xác suất 𝑝 , 𝑝 , … , 𝛼𝑝 , (1 − 𝛼)𝑝 , trong đó 0 ≤ 𝛼 ≤ 1.
    Bài 6.17. Sinh biến ngẫu nhiên
     Một người muốn sinh biến ngẫu nhiên X trong đó X = 1 với xác suất p và X = 0
với xác suất 1-p. Người đó được cung cấp một dãy kết quả phép gieo đồng xu
𝑍 , 𝑍 , … để phục vụ việc sinh X. Tìm một cách tốt để sử dụng 𝑍 , 𝑍 , … để sinh X.
Chứng minh rằng 𝐸𝑁 ≤ 2.
    Bài 6.18. Mã Huffman có tính giá
     Trong tiếng Anh, các từ như “Run!”, “Help!”, “Fire!” có độ dài ngắn không phải
vì chúng được dùng nhiều mà có lẽ do thời gian là quí báu trong những tình huống
mà các từ này được sử dụng. Giả sử 𝑋 = 𝑖 với xác suất 𝑝 , 𝑖 = 1,2, … , 𝑚. Đặt 𝑙 là số
lượng ký hiệu nhị phân của từ mã ứng với 𝑋 = 𝑖, và đặt 𝑐 là giá mỗi ký tự của từ mã
khi 𝑋 = 𝑖. Do đó, giá trung bình 𝐶 của mô tả của X là 𝐶 = ∑ 𝑝 𝑐 𝑙 .
    a) Cực tiểu hóa C theo 𝑙 , 𝑙 , … , 𝑙 thỏa mãn ∑ 2 ≤ 1. Bỏ qua ràng buộc 𝑙 là số
       nguyên. Tìm các 𝑙 ∗ , 𝑙 ∗ , … , 𝑙 ∗ và giá trị cực tiểu 𝐶 ∗ tương ứng.
    b) Làm cách nào ta có thể sử dụng thủ tục mã hóa Huffman để cực tiểu hóa 𝐶
       trên tất cả các mã tách được có thể? Đặt 𝐶                   là giá trị cực tiểu này.
    c) Hãy chỉ ra rằng

                               𝐶∗ ≤ 𝐶           ≤ 𝐶∗ +      𝑝𝑐




                                                                                        101
Chương 7
DUNG LƯỢNG KÊNH




The fundamental problem of communication is that of reproducing at one point either exactly or
approximately a message selected at another point.

                                                                               Claude Shannon, 1948




     Câu hỏi cơ bản đầu tiên, A giao tiếp với B nghĩa là gì? Nghĩa là hành động vật lý
của A gây ra một trạng thái vật lý mong muốn của B. Việc truyền tin này là một quá
trình vật lý và do đó phụ thuộc vào nhiễu môi trường và cả quá trình phát tín hiệu
vật lý. Giao tiếp là thành công nếu B và A đồng ý về cái được gửi. Một số ví dụ về
kênh truyền thông nhiễu là:
    -   Trong một mạng không dây, các thiết bị như máy tính xách tay, điện thoại,
        máy tính bảng, v.v. giao tiếp thông tin số với nhau (Hình 7.1 (a)).
    -   Liên kết truyền thông vô tuyến từ phi thuyền Galileo, có quĩ đạo quanh sao
        Mộc, tới trái đất.
    -   Sao chép tế bào, trong đó DNA trong tế bào của con chứa thông tin từ tế bào
        của cha mẹ (Hình 7.1 (b)).
    -   Việc đọc và ghi file lên đĩa (cùng vị trí nhưng vào các thời điểm khác nhau,
        Hình 7.1 (c)).


                                         Mẹ             Cha




                                       Con gái         Con trai

              (a)                                (b)                                (c)
                          Hình 7.1. Một vài ví dụ về kênh truyền thông nhiễu




                                                                                               102
    Trong chương này ta sẽ tìm số lượng tín hiệu phân biệt cực đại trong n lần sử
dụng kênh truyền thông. Số này tăng theo hàm mũ theo n, và số mũ chính là dung
lượng kênh. Việc mô hình hóa và chứng minh được rằng dung lượng kênh (logarit
của số lượng tín hiệu phân biệt) chính là thông tin tương hỗ là thành công quan
trọng và tiêu biểu nhất của lý thuyết thông tin.
    Mô hình toán học của một hệ thống phát tín hiệu vật lý được thể hiện trong
Hình 7.1. Các ký hiệu nguồn thuộc một bảng chữ cái hữu hạn được ánh xạ thành
chuỗi tương ứng của các ký hiệu kênh, sau đó tạo ra chuỗi đầu ra của kênh. Chuỗi
đầu ra là ngẫu nhiên nhưng tuân theo một phân phối phụ thuộc chuỗi đầu vào. Từ
chuỗi đầu ra, ta cố gắng khôi phục lại thông điệp đã được truyền.
    Mỗi chuỗi vào ứng với nhiều chuỗi ra có thể có và giữa chúng tồn tại một phân
phối xác suất có điều kiện. Với hai chuỗi vào khác nhau có thể có chuỗi ra giống
nhau. Các chuỗi vào như vậy gọi là dễ gây nhầm lẫn. Trong chương này, ta sẽ chỉ ra
rằng có thể chọn một tập con “không gây nhầm lẫn” của các chuỗi vào. Do đó ta có
thể xây dựng lại các chuỗi vào ở đầu ra với một xác suất lỗi nhỏ đến mức có thể bỏ
qua.




7.1. ĐỊNH NGHĨA KÊNH RỜI RẠC VÀ VÍ DỤ

7.1.1. Định nghĩa

                                                                                       Ŵ



 Hình 7.1. Hệ thống truyền thông bao gồm kênh truyền (hình chữ nhật ở giữa) và bộ mã hóa kênh (hình
                                     chữ nhật thứ nhất và thứ ba)

    Kênh rời rạc là một hệ (𝒳, 𝑝(𝑦|𝑥), 𝒴) trong đó 𝒳 là bảng chữ cái vào, 𝒴 là bảng
chữ cái ra, 𝑝(𝑦|𝑥) là ma trận xác suất chuyển cho biết xác suất nhận được ký hiệu y
với điều kiện ký hiệu x đã được truyền. Kênh được gọi là không nhớ (memoryless)
nếu phân phối xác suất của đầu ra chỉ phụ thuộc vào đầu vào tại thời điểm đó và
độc lập có điều kiện với các đầu vào và đầu ra trước đó.

7.1.2. Dung lượng kênh
    Định nghĩa: Ta định nghĩa dung lượng “thông tin” của một kênh rời rạc không
nhớ như sau
                                        𝐶 = max 𝐼(𝑋; 𝑌)
                                               ( )

    Trong định lý thứ hai của mình, Shannon đã chứng minh rằng dung lượng kênh
theo định nghĩa trên chính là số bit lớn nhất có thể truyền đi trong mỗi lần sử dụng
kênh sao cho xác suất lỗi nhỏ tùy ý.

                                                                                                103
     Nén dữ liệu và truyền dữ liệu là hai vấn đề đối ngẫu. Trong khi nén, ta loại bỏ
tất cả các dư thừa trong dữ liệu để tiết kiệm không gian lưu trữ nhất có thể. Trái lại,
trong khi truyền dữ liệu, ta thêm dư thừa một cách có chủ đích để đối phó với lỗi
trên kênh truyền. Cũng trong chương này, ta sẽ tìm hiểu một định lý nói rằng việc
nén và truyền dữ liệu có thể được tách biệt mà vẫn đảm bảo hệ thống là tối ưu.

7.1.3. Các ví dụ
    a) Kênh nhị phân không nhiễu




                        Hình 7.2. Kênh nhị phân không nhiễu, C = 1 bit

     Cả 𝑋 và 𝑌 đều có bảng chữ cái nhị phân. Với mỗi giá trị của 𝑋 thì chỉ có một giá
trị tương ứng của 𝑌. Trong trường hợp này, dữ liệu được truyền và nhận chính xác,
không có lỗi. Dung lượng kênh
                                 𝐶 = max 𝐼(𝑋; 𝑌) = 1 𝑏𝑖𝑡
                                        ( )

    đạt được khi 𝑝(𝑥) = (1/2, 1/2).
    b) Kênh nhiễu với đầu ra không giao nhau




                   Hình 7.3. Kênh nhiễu với đầu ra không giao nhau, C = 1 bit

   Với kênh này, mỗi giá trị vào có hai giá trị ra tương ứng. Kênh có vẻ nhiễu
nhưng thực ra không phải vậy. Lý do là biết giá trị ra ta có thể xác định chính xác giá

                                                                                   104
trị vào duy nhất, do đó không có lỗi. Ta dễ dàng tính được dung lượng kênh 𝐶 =
 max 𝐼(𝑋; 𝑌) = 1 𝑏𝑖𝑡 đạt được khi 𝑝(𝑥) = (1/2, 1/2).
 ( )

       c) Máy đánh chữ nhiễu
     Giả sử ta có một máy đánh chữ với bàn phím tiếng Anh (26 chữ cái). Tuy nhiên
máy này bị lỗi, khi ta đánh một phím thì máy có thể in ra ký tự tương ứng hoặc cũng
có thể in ra ký tự kế tiếp trong bảng chữ cái với xác suất như nhau là 1/2 (Hình 7.4).
Nếu ta sử dụng tất cả lựa chọn ký hiệu vào, ta có thể truyền một trong 13 ký hiệu
chính xác mỗi lần truyền. Dễ tính được
   𝐶 = max 𝐼(𝑋; 𝑌) = max(𝐻(𝑌) − 𝐻(𝑌|𝑋)) = max 𝐻(𝑌) − 1 = log 26 − 1 = log 13
       Dung lượng này đạt được khi 𝑝(𝑥) là phân phối đều.




                       Hình 7.4. Kênh máy đánh chữ nhiễu, 𝑪 = 𝒍𝒐𝒈 𝟏𝟑 bit




       d) Kênh đối xứng nhị phân
   Xét kênh nhị phân đối xứng (Hình 7.5). Đây là mô hình đơn giản nhất của một
kênh có lỗi, tuy nhiên nó lại thể hiện được sự phức tạp của bài toán tổng quát.

                                                                                  105
                            Hình 7.5. Kênh đối xứng nhị phân




     Khi có lỗi, truyền 0 đi ta nhận được 1 và ngược lại. Bit nhận được không cho ta
biết có lỗi hay không. Người đọc dễ có cảm nhận, kênh truyền này không hề đáng
tin cậy. Ở phần sau của chương, ta sẽ thấy rằng kênh này vẫn có thể được dùng với
tốc độ truyền dương và xác suất lỗi nhỏ tùy ý.
                       𝐼(𝑋; 𝑌) = 𝐻(𝑌) − 𝐻(𝑌|𝑋)
                               = 𝐻(𝑌) −       𝑝(𝑥)𝐻(𝑌|𝑋 = 𝑥)

                               = 𝐻(𝑌) −       𝑝(𝑥)𝐻(𝑝)
                               ≤ 1 − 𝐻(𝑝)
     Bất đẳng thức trên đúng vì 𝑌 là biến ngẫu nhiên nhị phân. Dấu bằng đạt được
khi phân phối vào là phân phối đều. Do đó dung lượng của kênh đối xứng nhị phân
với tham số 𝑝 là:
                                    𝐶 = 1 − 𝐻(𝑝)
    e) Kênh xóa nhị phân
    Trong kênh này (Hình 7.6), một phần 𝛼 của bit vào sẽ bị xóa. Bên nhận biết bit
nào đã bị xóa. Kênh xóa nhị phân có hai đầu vào và ba đầu ra.




                                                                                106
                                 Hình 7.6. Kênh nhị phân xóa




    Dung lượng kênh xóa nhị phân như sau:
                             𝐶 = max 𝐼(𝑋; 𝑌)
                                      ( )
                                 = max(𝐻(𝑌) − 𝐻(𝑌|𝑋))
                                      ( )
                                 = max 𝐻(𝑌) − 𝐻(𝛼)
                                      ( )

    Mới nhìn ta có thể đoán giá trị cực đại của 𝐻(𝑌) là log 3, tuy nhiên ta không thể
đạt giá trị đó với bất kỳ lựa chọn 𝑝(𝑥) nào. Giả sử E là biến cố {Y=e}, ta có
                         𝐻(𝑌) = 𝐻(𝑌, 𝐸) = 𝐻(𝐸) + 𝐻(𝑌|𝐸)
    Và đặt 𝑃(𝑋 = 1) = 𝜋, ta có
                       𝐻(𝑌) = 𝐻 (1 − 𝜋)(1 − 𝛼), 𝛼, 𝜋(1 − 𝛼)
                            = 𝐻(𝛼) + (1 − 𝛼)𝐻(𝜋)
    Do đó
                        𝐶 = max 𝐻(𝑌) − 𝐻(𝛼)
                              ( )
                          = max(1 − 𝛼)𝐻(𝜋) + 𝐻(𝛼) − 𝐻(𝛼)
                          = max(1 − 𝛼)𝐻(𝜋)
                          =1−𝛼
    Dung lượng đạt được khi 𝜋 = .

     Biểu thức trên có một số ý nghĩa. Vì một phần 𝛼 của bit vào bị mất trên kênh, ta
có thể nhận được (tối đa) phần 1- 𝛼 bit. Do đó dung lượng không quá 1- 𝛼. Chưa rõ
ta có đạt được tốc độ đó không, định lý thứ hai của Shannon sẽ làm rõ.
    Trong nhiều kênh thực tế, đầu gửi có phản hồi nào đó từ đầu nhận. Nếu kênh
xóa nhị phân là có phản hồi, dùng nó thế nào là rõ: nếu mất đi 1 bit, truyền lại nó

                                                                                 107
đến khi thành công thì thôi. Vì khả năng truyền thành công là 1- 𝛼, ta có thể đạt
được dung lượng 1- 𝛼 khi có phản hồi.
    Trong phần sau của chương ta sẽ được xem chứng minh rằng tốc độ 1- 𝛼 là tối
đa trong cả hai trường hợp có và không có phản hồi. Đây là một trong các hệ quả
của thực tế đáng ngạc nhiên là phản hồi không làm tăng dung lượng kênh truyền
không nhớ rời rạc.


7.2. KÊNH ĐỐI XỨNG

   Định nghĩa: Một kênh là đối xứng nếu các hàng của ma trận chuyển p(y|x) là
hoán vị của nhau và các cột cũng là hoán vị của nhau. Trong trường hợp chỉ các
hàng là hoán vị của nhau còn các cột có tổng bằng nhau thì kênh gọi là đối xứng yếu.
       Lần lượt các ma trận chuyển dưới đây là của kênh đối xứng và kênh đối xứng
yếu:
                                            0.3 0.2 0.5
                                   𝑝(𝑦|𝑥) = 0.5 0.3 0.2
                                            0.2 0.5 0.3
                                               1 1 1
                                     𝑝(𝑦|𝑥) = 3 6 2
                                               1 1 1
                                               3 2 6


       Định lý: Kênh đối xứng yếu có dung lượng cho bởi
                                       𝐶 = log |𝒴| − 𝐻(r)
    trong đó r là một hàng của ma trận chuyển. Dung lượng này đạt được bởi phân
phối đều trên bảng chữ cái vào.
       Chứng minh : Ta có 𝐼(𝑋; 𝑌) = 𝐻(𝑌) − 𝐻(𝑌|𝑋) = 𝐻(𝑌) − ∑ 𝑝(𝑥)𝐻(𝑌|𝑋 = 𝑥)
    Vì các hàng là hoán vị của nhau nên H(Y|X=x) là như nhau với mọi giá trị x của
X. Do đó :
                      𝐼(𝑋; 𝑌) = 𝐻(𝑌) − 𝐻(𝑌|𝑋 = 𝑥 ) ≤ log|𝒴| + 𝐻(𝑟)
       Trong đó 𝑥 ∈ 𝒳 và 𝐻(𝑟) = 𝐻(𝑌|𝑋 = 𝑥 ). Ta có đpcm.
       Ví dụ: Kênh đối xứng cho bởi ma trận chuyển ở trên có dung lượng là:
                          𝐶 = max 𝐼(𝑋; 𝑌) = log 3 − 𝐻(0.5, 0.3, 0.2)
                                 ( )



7.3. CÁC TÍNH CHẤT CỦA DUNG LƯỢNG KÊNH

       1. 𝐶 ≥ 0 vì 𝐼(𝑋; 𝑌) ≥ 0


                                                                                108
       2. 𝐶 ≤ log|𝒳| (vì 𝐶 = max 𝐼(𝑋; 𝑌) ≤ max 𝐻(𝑋) = log|𝒳|
       3. 𝐶 ≤ log |𝒴| với cùng lý do
       4. 𝐼(𝑋; 𝑌) là hàm liên tục theo p(x)
       5. 𝐼(𝑋; 𝑌) là hàm lõm theo p(x)


7.4. CÁC ĐỊNH NGHĨA CẦN CHO ĐỊNH LÝ MÃ HÓA KÊNH

    Một thông điệp W, thuộc tập chỉ số {1, 2, …, M}, được biểu diễn bằng tín hiệu
X (W) rồi truyền qua kênh. Ở đầu ra, bộ giải mã sẽ nhận được một chuỗi ngẫu nhiên
 n

Yn~p(yn|xn). Bộ giải mã sẽ đoán chỉ số W bằng luật giải mã 𝑊 = 𝑔(𝑌 ). Bộ giải mã sẽ
gây ra lỗi nếu 𝑊 khác với chỉ số W đã được truyền đi.

                                                                         Ŵ



                                    Hình 7.7. Kênh truyền thông


7.4.1. Kênh rời rạc
    Một kênh rời rạc (Hình 7.7), ký hiệu (𝒳, 𝑝(𝑦|𝑥), 𝒴), bao gồm hai tập hữu hạn 𝒳
và 𝒴 và một tập hợp (collection) các hàm mật độ xác suất p(y|x) ứng với mỗi x
thuộc 𝒳, sao cho 𝑝(𝑦|𝑥) ≥ 0và ∑ 𝑝(𝑦|𝑥) = 1, trong đó 𝑋 là đầu vào và 𝑌 là đầu ra
của kênh.

7.4.2. Mở rộng bậc n của kênh rời rạc không nhớ (DMC)
       Là kênh (𝒳 , 𝑝(𝑦 |𝑥 ), 𝒴 ) trong đó :
                         𝑝(𝑦 |𝑥 , 𝑦      ) = 𝑝(𝑦 |𝑥 ), 𝑘 = 1, 2, … , 𝑛
     Chú ý : Nếu kênh được sử dụng không có phản hồi, mở rộng bậc n của kênh đó
sẽ có hàm chuyển kênh là :

                                    𝑝(𝑦 |𝑥 ) =        𝑝(𝑦 |𝑥 )

       Khi ta nói kênh rời rạc không nhớ, ta đã ngầm định đó là kênh không có phản
hồi.

7.4.3. Mã (M, n)
       Một mã (M, n) cho kênh (𝒳, 𝑝(𝑦|𝑥), 𝒴) bao gồm :
       1. Tập chỉ số {1, 2, …, M}
       2. Hàm mã hóa 𝑋 : {1, 2, … , 𝑀} → 𝒳



                                                                               109
    Hàm này xác định các từ mã xn(1), xn(2), …, xn(M). Tập các từ mã tạo thành bảng
mã (codebook).
    3. Hàm giải mã
                                         𝑔 : 𝒴 → {1, 2, … , 𝑀}

7.4.4. Xác suất lỗi có điều kiện
    Giả sử i là chỉ số đã được gửi, khi đó xác suất lỗi có điều kiện sẽ là

            𝜆 = 𝑃(𝑔(𝑌 ) ≠ 𝑖) 𝑋 = 𝑥 (𝑖) =                            𝑝 𝑦 𝑥 (𝑖) 𝐼( 𝑔(𝑦 ) ≠ 𝑖)

    trong đó 𝐼(. ) là hàm chỉ tiêu (indicator function).

7.4.5. Xác suất lỗi cực đại
    Xác suất lỗi cực đại 𝜆(   )
                                  của mã (M, n) được định nghĩa như sau :
                                          𝜆(    )
                                                    =         max       𝜆
                                                          ∈{ , ,…, }

    Xác suất lỗi trung bình
                                                    ( )
    Xác suất lỗi trung bình (số học) 𝑃                    của mã (M, n) là

                                                ( )           1
                                            𝑃             =         𝜆
                                                              M

   Chú ý là nếu chỉ số W được chọn theo phân phối đều trên tập {1, 2, …, M}, và
𝑋 = 𝑥 (𝑊), thì
                                          ( )
                                     𝑃          ≜ P(W ≠ g(Y ))
                                   ( )
    Tương tự, hiển nhiên là 𝑃            ≤ λ( ) .
    Ta thường cho rằng xác suất lỗi cực đại có đặc điểm khá khác với xác suất trung
bình. Nhưng trong phần kế tiếp ta sẽ chỉ ra rằng một xác suất lỗi trung bình nhỏ bao
hàm một xác suất lỗi cực đại nhỏ ở cùng tốc độ.
     Trong chứng minh định lý mã hóa kênh (cả thuận và nghịch), ta sẽ chọn một
phân phối đều trên W để chặn xác suất lỗi. Lựa chọn này cho phép ta thiết lập hành
        ( )
vi của 𝑃 và xác suất lỗi cực đại 𝜆( ) và do đó thiết lập hành vi của kênh bất kể nó
được dùng thế nào (không phụ thuộc phân phối của W).

7.4.6. Tốc độ R

    𝑅=        bit mỗi lần truyền (bits per transmission)




                                                                                              110
7.4.7. Tốc độ có thể đạt được
    Tốc độ R có thể đạt được nếu tồn tại chuỗi (⌈2 ⌉, 𝑛) mã sao cho xác suất lỗi cực
đại 𝜆( ) tiến tới 0 khi n tiến ra vô cùng.

7.4.8. Dung lượng kênh
   Dung lượng kênh là cận trên đúng (supremum) của tất cả các tốc độ có thể đạt
được.


7.5. CÁC CHUỖI ĐIỂN HÌNH ĐỒNG THỜI

     Đại thể, ta giải mã một đầu ra kênh 𝑌 là chỉ số thứ i nếu từ mã 𝑋 (𝑖) là điển
hình đồng thời với tín hiệu 𝑌 nhận được. Trong phần này ta định nghĩa ý tưởng
quan trọng về tính điển hình đồng thời và tìm xác suất điển hình đồng thời khi 𝑋 (𝑖)
là và không là đầu vào ứng với 𝑌 .
              ( )
    Tập 𝐴 các chuỗi điển hình đồng thời {(xn,yn)} với phân phối xác suất p(x,y) là
tập các chuỗi độ dài n với entropy thực nghiệm gần-ε với entropy thực:
      ( )                          1                      1
    𝐴       = {(𝑥 , 𝑦 ) ∈ X × Y : − 𝑙𝑜𝑔𝑝(𝑥 ) − 𝐻(𝑋) < 𝜀, − 𝑙𝑜𝑔𝑝(𝑦 ) − 𝐻(𝑌)
                                   𝑛                      𝑛
                            1
                     < 𝜀, − 𝑙𝑜𝑔𝑝(𝑥 , 𝑦 ) − 𝐻(𝑋, 𝑌) < 𝜀}
                            𝑛
    Trong đó 𝑝(𝑥 , 𝑦 ) = ∏                   𝑝(𝑥 , 𝑦 )
    Định lý (AEP đồng thời): Giả sử (Xn,Yn) là các chuỗi độ dài n được sinh ra độc
lập và cùng phân phối 𝑝(𝑥 , 𝑦 ) = ∏ 𝑝(𝑥 , 𝑦 ). Khi đó:
                            ( )
    1. 𝑃 (𝑋 , 𝑌 ) ∈ 𝐴                 → 1khi 𝑛 → ∞
            ( )
    2. 𝐴          ≤2   ( ( , )    )


    3. Nếu (𝑋 , 𝑌 )~𝑝(𝑥 )𝑝(𝑦 ) thì :
                                                          ( )         ( ( ; )   )
                                      𝑃((𝑋 , 𝑌 ) ∈ 𝐴            )≤2
    và với n đủ lớn:
                                                    ( )                    ( ( ; )   )
                            𝑃         𝑋 ,𝑌      ∈𝐴         ≥ (1 − 𝜀)2

    Tập điển hình được minh họa trong Hình 7.8. Có khoảng 2 ( ) chuỗi X điển
hình và khoảng 2 ( ) chuỗi Y điển hình. Tuy nhiên, vì chỉ có 2 ( , ) chuỗi điển
hình đồng thời, không phải mọi cặp 𝑋 điển hình và 𝑌 điển hình là điển hình đồng
thời. Xác suất mà cặp được chọn ngẫu nhiên là điển hình đồng thời là khoảng
2 ( ; ) . Do đó, ta có thể phải xem xét khoảng 2 ( ; ) cặp như vậy trước khi ta có
thể gặp một cặp điển hình đồng thời. Lập luận này gợi ý rằng có khoảng 2 ( ; ) tín
hiệu phân biệt 𝑋 .



                                                                                         111
                             Hình 7.8. Các chuỗi điển hình đồng thời



7.6. ĐỊNH LÝ MÃ HÓA KÊNH




    Hình 7.9. Phương pháp chứng minh tồn tại em bé với trọng lượng nhỏ hơn 10kg của Shannon




     Tưởng tượng rằng ta muốn chứng minh trong một lớp học gồm 100 đứa trẻ, có
một em bé với trọng lượng nhỏ hơn 10 kg. Tuy nhiên, khó mà yêu cầu từng em bé
đứng lên cân và cân vì chúng rất nghịch ngợm. Phương pháp của Shannon (Hình
7.9) là đưa tất cả các em bé lên một cái cân thật lớn, và cân đúng một lần thôi. Nếu
cân chỉ trọng lượng nhỏ hơn 1000, tức là trọng lượng trung bình của các em bé nhỏ
hơn 10, ta có thể suy ra rằng có ít nhất một em bé có trọng lượng nhỏ hơn 10 kg. Tất
nhiên phương pháp này không chỉ ra được em bé cụ thể nào có trọng lượng nhỏ hơn
10 kg, nhưng cũng đủ để giải quyết bài toán.
    Áp dụng ý tưởng cân em bé ở trên vào bài toán mã hóa này. Ta muốn chứng
minh rằng tồn tại một mã và một bộ giải mã có xác suất lỗi nhỏ. Tuy nhiên thực tế là
việc đánh giá xác suất lỗi của bất kỳ hệ thống mã hóa và giải mã nào là không đơn
giản. Ý tưởng thông minh của Shannon là: thay vì xây dựng một hệ thống mã hóa và

                                                                                              112
giải mã tốt và sau đó đánh giá xác suất lỗi của nó, ông ta tính xác suất lỗi khối trung
bình của tất cả các mã, và chứng minh giá trị trung bình này là nhỏ. Khi đó – tương
tự như trường hợp cân em bé – phải tồn tại ít nhất một mã có xác suất lỗi khối là
nhỏ.
    Shannon đã sử dụng một số ý tưởng mới để chứng minh rằng thông tin có thể
được truyền tin cậy qua một kênh ở mọi tốc độ không lớn hơn dung lượng kênh.
Các ý tưởng đó là:
    - Cho phép một xác suất lỗi nhỏ tùy ý nhưng khác không.
    - Sử dụng kênh truyền nhiều lần thành công, do đó luật số lớn thể hiện tác
dụng.
    - Tính trung bình xác suất lỗi theo sự lựa chọn bảng mã (codebook) ngẫu nhiên,
mà đối xứng hóa xác suất, và có thể được sử dụng để chỉ ra sự tồn tại của ít nhất một
mã tốt.
    Định lý: Với một kênh rời rạc không nhớ, tất cả các tốc độ nhỏ hơn dung lượng
C là có thể đạt được. Cụ thể hơn, với mọi tốc độ R<C, tồn tại một chuỗi các mã (2nR,
n) với xác suất lỗi cực đại 𝜆 → 0. Ngược lại, bất kỳ chuỗi mã (2nR, n) nào với 𝜆 → 0
phải có 𝑅 ≤ 𝐶.




                              Hình 7.10. Minh họa kênh nhiễu

    Trước hết ta cần có ý tưởng trực quan về lý do tại sao ta có thể truyền C bit
thông tin qua một kênh. Ý tưởng cơ bản là mỗi kênh có một tập con các input mà
ứng với nó các chuỗi output là khác nhau. Cụ thể hơn, với mỗi chuỗi input (điển
hình), có xấp xỉ 2 ( | ) chuỗi Y có thể có, tất cả đều là đồng khả năng. Chúng ta
mong muốn là không có hai chuỗi X nào sinh ra cùng chuỗi Y. Nếu không, chúng ta
không thể xác định được chuỗi X nào đã được gửi đi. Tổng số chuỗi Y (điển hình) có
thể có là 2 ( ) . Tập này phải được chia thành các tập con có kích thước 2 ( | )
tương ứng với các chuỗi X vào khác nhau. Tổng số tập con không giao nhau nhỏ
hơn hay bằng 2 ( ( ) 𝑌 𝑋 ) = 2 ( ; ) . Do đó ta có thể truyền tối đa 2 ( ; ) chuỗi
độ dài n khác nhau.
    Chứng minh:
    Tính có thể đạt được:

                                                                                   113
    Cố định p(x), sinh một mã (2 , 𝑛) ngẫu nhiên theo phân phối p(x). Cụ thể, ta
sinh 2 từ mã độc lập theo phân phối:

                                    𝑝(𝑥 ) =      𝑝(𝑥 )

       Ta biểu diễn 2   từ mã như các hàng của ma trận
                                 𝑥 (1)
                                    𝑥 (1) ⋯  𝑥 (1)
                         𝐶=           ⋮   ⋱    ⋮
                            𝑥 (2 ) 𝑥 (2 ) ⋯ 𝑥 (2 )


    Vì mỗi phần tử của ma trận được sinh ra độc lập theo phân phối p(x), xác suất
mà ta sinh ra một mã C cụ thể là:


                                 𝑃(𝐶) =         𝑝(𝑥 (𝑤))

       Xét dãy biến cố sau:
   -     Một mã ngẫu nhiên C được sinh ra như mô tả ở trên.
   -     Cả người gửi và người nhận đều biết C. Hai người này cũng biết ma trận
         chuyển p(y|x) của kênh truyền.
   -     Thông điệp W được chọn theo phân phối đều
                              𝑃(𝑊 = 𝑤) = 2    , 𝑤 = 1,2, … , 2
   -     Từ mã thứ w 𝑋 (𝑤) tương ứng với hàng thứ w của C, được gửi qua kênh
         truyền.
   -     Người nhận nhận được chuỗi 𝑌 theo phân phối

                               𝑃 𝑦 𝑥 (𝑤) =       𝑝(𝑦 |𝑥 (𝑤))

   -     Người nhận đoán thông điệp nào đã được gửi. (Thủ tục tối ưu để cực tiểu hóa
         xác suất lỗi là giải mã cực đại hóa likelihood. Tuy nhiên thủ tục này là rất khó
         phân tích. Thay vào đó, ta sẽ sử dụng giải mã điển hình đồng thời, như mô tả
         dưới đây. Giải mã điển hình đồng thời dễ tính toán hơn và tối ưu tiệm cận.)
         Trong giải mã điển hình đồng thời, người nhận thông báo rằng chỉ số 𝑊 đã
         được gửi nếu điều kiện sau được thỏa mãn:
            o (𝑋 𝑊 , 𝑌 ) là điển hình đồng thời.
                                                                   ( )
            o Không tồn tại chỉ số 𝑊 ≠ 𝑊 mà (𝑋 (𝑊′), 𝑌 ) ∈ 𝐴 .
         Nếu không tồn tại 𝑊 như vậy hoặc nếu có nhiều hơn một, thì thông báo lỗi.
         (Có thể giả sử rằng người nhận đưa ra một chỉ số giả (dummy) như là 0 chẳng
         hạn).
   -     Có một lỗi giải mã nếu 𝑊 ≠ 𝑊. Giả sử ℰ là sự kiện {𝑊 ≠ 𝑊}.

                                                                                     114
    Phân tích xác suất lỗi
     Phác thảo: Thay vì tính xác suất lỗi cho một mã, ta tính trung bình với tất cả các
mã được sinh ngẫu nhiên theo phân phối P(C) như nêu trên. Vì tính đối xứng của
việc xây dựng mã, xác suất lỗi trung bình không phụ thuộc vào chỉ số cụ thể đã
được gửi. Với một từ mã điển hình, có hai nguồn lỗi khác nhau khi ta sử dụng cách
giải mã điển hình đồng thời: Hoặc đầu ra 𝑌 không điển hình đồng thời với từ mã
được gửi đi hoặc có có từ mã nào đó khác điển hình đồng thời với 𝑌 . Xác suất mà
từ mã được truyền và chuỗi nhận được là điển hình đồng thời tiến tới 1, như chỉ ra
trong tính chất AEP đồng thời. Với từ mã cạnh tranh (rival) bất kỳ, xác suất mà nó
điển hình đồng thời với chuỗi nhận được xấp xỉ 2 , và do đó ta có thể sử dụng
khoảng 2 từ mã và vẫn có một xác suất lỗi thấp. Sau đây ta sẽ mở rộng lập luận
này để tìm một mã có xác suất lỗi cực đại là thấp.
     Chi tiết tính toán xác suất lỗi: Giả sử W được sinh ra theo phân phối đều trên miền
{1,2, … , 2 } và sử dụng giải mã điển hình đồng thời 𝑊 (𝑦 ) như mô tả ở bước 6 ở
trên. Đặt ℰ = {𝑊 (𝑌 ) ≠ 𝑊} thể hiện sự kiện lỗi. Ta sẽ tính xác suất lỗi trung bình,
trung bình theo tất cả các từ mã trong bảng mã, và trung bình theo tất cả các bảng
mã; cụ thể, ta tính
                                                   ( )
                             𝑃(ℰ) =        𝑃(𝐶)𝑃         (𝐶)

                                                   1
                                  =        𝑃(𝐶)                𝜆 (𝐶)
                                                  2

                                       1
                                  =                 𝑃(𝐶)𝜆 (𝐶)
                                      2
             ( )
    ở đây 𝑃 được định nghĩa cho giải mã điển hình đồng thời. Do tính chất đối
xứng của việc xây dựng mã, trung bình xác suất lỗi theo tất cả các mã không phụ
thuộc vào chỉ số cụ thể đã gửi đi. Do đó, không mất tính tổng quát ta có thể giả sử
thông điệp 𝑊 = 1 đã được gửi đi, vì

                                       1
                             𝑃(ℰ) =                    𝑃(𝐶)𝜆 (𝐶)
                                      2

                                  =        𝑃(𝐶)𝜆 (𝐶)

                                  = 𝑃(ℰ|𝑊 = 1)
    Định nghĩa các sự kiện sau:
                                              ( )
                   𝐸 = (𝑋 (𝑖), 𝑌 )𝑡ℎ𝑢ộ𝑐 𝐴           ,          𝑖 ∈ {1,2, … , 2 }

    ở đây 𝐸 là sự kiện từ mã thứ i và 𝑌 là điển hình đồng thời. Nhắc lại là 𝑌 là kết
quả của việcg gửi từ mã đầu tiên 𝑋 (1) qua kênh.



                                                                                    115
    Khi đó một lỗi xuất hiện trong lược đồ giải mã nếu hoặc 𝐸 xuất hiện (khi từ mã
được truyền đi và chuỗi nhận được không điển hình đồng thời) hoặc 𝐸 ∪ 𝐸 ∪ … ∪
𝐸    xuất hiện (khi một từ mã sai là điển hình đồng thời với chuỗi nhận được). Do
đó đặt 𝑃(ℰ) là 𝑃(ℰ|𝑊 = 1), ta có:
                     𝑃(ℰ|𝑊 = 1) = 𝑃(𝐸 ⋃𝐸 ⋃ … ⋃𝐸                 |𝑊 = 1)

                                     ≤ 𝑃(𝐸 |𝑊 = 1) +            𝑃(𝐸 |𝑊 = 1)



       Bây giờ, theo AEP hợp, 𝑃(𝐸 |𝑊 = 1) → 0, và do đó
                               𝑃(𝐸 |𝑊 = 1) ≤ 𝜖 với n đủ lớn.
    Theo quá trình sinh mã, 𝑋 (1) và 𝑋 (𝑖) là độc lập khi 𝑖 ≠ 1, và 𝑌 và 𝑋 (𝑖) cũng
vậy. Do đó, xác suất mà 𝑌 và 𝑋 (𝑖) là điển hình đồng thời ≤ 2 ( ( ; ) ) theo AEP
hợp. Hệ quả là


                  𝑃(ℰ) = P(ℰ|W = 1) ≤ P(E |𝑊 = 1) +                  𝑃(𝐸 |𝑊 = 1)


                                      ( ( ; )        )
                       ≤𝜖+       2

                                                ( ( ; )   )
                       = 𝜖 + (2 − 1)2
                       ≤𝜖+2 2 ( ( ;             )    )

                       ≤ 2𝜖


    nếu n đủ lớn và 𝑅 < 𝐼(𝑋; 𝑌) − 3𝜖. Do đó, nếu 𝑅 < 𝐼(𝑋; 𝑌), ta có thể chọn 𝜖 và n
sao cho xác suất lỗi trung bình (theo cả bảng mã và từ mã) là nhỏ hơn 2𝜖.
    Để kết thúc chứng minh này, ta sẽ củng cố kết luận này bằng một chuỗi lựa
chọn mã:
   -     Chọn p(x) trong chứng minh là p*(x), phân phối mà đạt dung lượng kênh. Khi
         đó điều kiện 𝑅 < 𝐼(𝑋; 𝑌) có thể được thay bằng điều kiện có thể đạt 𝑅 < 𝐶.
   -     Thoát khỏi trung bình theo bảng mã. Vì xác suất lỗi trung bình theo bảng mã
         là nhỏ (≤ 2𝜖), tồn tại ít nhất một bảng mã 𝒞 ∗ với xác suất lỗi trung bình nhỏ.
         Do đó 𝑃(ℰ|𝒞 ∗ ≤ 2𝜖. Để xác định 𝒞 ∗ ta có thể dựa vào thuật toán xét tất cả các
         mã (2 , 𝑛) có thể có. Chú ý là

                                                     1
                                𝑃(ℰ|𝐶 ∗ ) =               𝜆 (𝐶 ∗ )
                                                    2



         vì ta đã chọn 𝑊 theo phân phối đều như mô tả ở phần trên.


                                                                                    116
   -     Bỏ đi một nửa của bảng mã tốt nhất 𝒞 ∗ , phần mà chứa những từ mã tồi nhất.
                                                ( )
         Vì trung bình số học của xác suất lỗi 𝑃 (𝒞 ∗ ) của mã này nhỏ hơn 2𝜖, ta có
                                             1
                              𝑃(ℰ|𝐶 ∗ ) ≤        𝜆 (𝐶 ∗ ) ≤ 2𝜖
                                            2


         ngụ ý rằng ít nhất một nửa các chỉ số i và từ mã tương ứng của chúng 𝑋 (𝑖)
         phải có xác suất lỗi có điều kiện 𝜆 nhỏ hơn 4𝜖 (trái lại, các từ mã này sẽ đóng
         góp nhiều hơn 2𝜖 vào tổng). Do đó nửa tốt của bảng mã có xác suất lỗi cực
         đại nhỏ hơn 4𝜖. Nếu ta đánh số lại các từ mã đó, ta có 2        từ mã. Bỏ đi một
         nửa số từ mã đã thay đổi tốc độ từ R thành 𝑅 − , có thể bỏ qua khi n lớn.

       Kết hợp tất cả các cải tiến đó, ta đã xây dựng một mã với tốc độ 𝑅 = 𝑅 − , với
xác suất lỗi cực đại 𝜆( ) ≤ 4𝜖. Do đó chứng minh được tính có thể đạt được bất kỳ
tốc độ nào không quá dung lượng.
    Mặc dù định lý chứng minh rằng tồn tại mã tốt với xác suất lỗi nhỏ tùy ý khi độ
dài khối dài, định lý này không chỉ ra làm thế nào để xây dựng mã như vậy. Nếu ta
sử dụng lược đồ được đưa ra trong chứng minh và sinh một mã ngẫu nhiên với
phân phối phù hợp, mã đó có thể sẽ tốt với độ dài khối dài. Tuy nhiên, do thiếu tính
có cấu trúc, sẽ rất khó để giải mã (lược đồ tra bảng đơn giản nhất sẽ yêu cầu một
bảng có kích thước mũ). Do đó định lý không cho ta một lược đồ mã thực tế. Sau khi
bài báo của Shannon được công bố, các nhà khoa học đã dành nhiều nỗ lực nghiên
cứu các mã có cấu trúc, dễ mã hóa và giải mã. Trong phần dưới đây ta sẽ tìm hiểu
mã Hamming, mã đơn giản nhất trong nhóm mã sửa lỗi đại số. Mã này chỉ có khả
năng sửa một lỗi.


7.7. MÃ SỬA LỖI

    Định lý mã hóa kênh chỉ ra sự tồn tại của mã khối, cho phép chúng ta truyền
thông tin với tốc độ không vượt quá dung lượng với một xác suất lỗi nhỏ tùy ý nếu
như độ dài khối đủ lớn. Từ khi bài báo của Shannon được xuất bản, người ta đã bắt
đầu tìm kiếm những mã như vậy. Bên cạnh tiêu chí xác suất lỗi nhỏ, mã nên “đơn
giản” theo nghĩa việc mã hóa và giải mã hiệu quả. Từ đó đến nay, người ta đã có
bước tiến khá xa, thể hiện ở sự phát triển của lĩnh vực nghiên cứu về lý thuyết mã. Ở
đây, do giới hạn của thời lượng môn học, ta không ta không đi sâu vào tìm hiểu
nhiều lược đồ mã hóa phức tạp mà cũng hết sức tao nhã. Thay vào đó ta sẽ tìm hiểu
một ví dụ đơn giản là mã Hamming để minh họa các ý tưởng cơ bản nhất trong lĩnh
vực này.
    Mục tiêu của mã hóa là sử dụng sự dư thừa sao cho nếu một phần thông tin bị
mất hay phá hủy, ta vẫn có thể khôi phục thông điệp gốc ở bộ giải mã. Cách mã hóa
dễ thấy nhất là lặp thông tin. Ví dụ, để gửi 1, ta gửi 11111, và để gửi 0, ta gửi 00000.
Cách này sử dụng khối 5 ký hiệu để gửi 1 bit, và do đó có tốc độ 1/5 bit mỗi ký hiệu.

                                                                                     117
Sẽ là tối ưu hơn nếu ta giải mã khối là 1 nếu có ba bit trở lên là 1, trái lại ta giải mã nó
là 0. Lỗi xuất hiện nếu và chỉ nếu có hơn 3 bit bị thay đổi. Bằng cách sử dụng các mã
lặp dài hơn, ta có thể thu được xác suất lỗi thấp tùy ý. Tuy nhiên tốc độ của mã cũng
tiến tới không khi độ dài khối tăng, cho nên tuy mã là “đơn giản”, nó không hữu ích
cho lắm.
    7.7.1 Mã Hamming
     Thay vì đơn giản lặp lại các bit, ta có thể kết hợp các bit theo cách thông minh
hơn sao cho mỗi bit thêm vào kiểm tra xem có lỗi hay không. Một ví dụ đơn giản của
loại mã này là mã kiểm tra chẵn lẻ. Bắt đầu với khối gồm n-1 bit thông tin, ta chọn
bit thứ n và gán cho nó giá trị 0 nếu trong khối có chẵn bit 1 và 1 nếu ngược lại. Do
đó nếu có một số lẻ lỗi trong khi truyền, bộ giải mã sẽ thông báo rằng tính chẵn lẽ đã
thay đổi và phát hiện lỗi. Đây là ví dụ đơn giản nhất của mã phát hiện lỗi. Mã này
không phát hiện số chẵn lỗi và không cho thông tin nào về cách sửa lỗi.
    Ta có thể mở rộng ý tưởng về kiểm tra chẵn lẻ này để cho phép sử dụng nhiều
hơn một bit kiểm tra chẵn lẻ và cho phép bit chẵn lẻ phụ thuộc vào các tập con khác
nhau của các bit thông tin. Mã Hamming mà ta sẽ tìm hiểu sau đây là một ví dụ của
mã kiểm tra chẵn lẻ. Ta sẽ mô tả nó sử dụng các ý tưởng đơn giản từ đại số tuyến
tính.
    Để minh họa nguyên lý của mã Hamming, ta xét một mã nhị phân có độ dài
khối là 7. Tất cả các phép toán là theo modulo 2. Xét tập các vector nhị phân khác
không độ dài 3. Sắp xếp chúng vào các cột để tạo thành một ma trận:
                                 0 0 0         1 1     1   1
                              𝐻= 0 1 1         0 0     1   1
                                 1 0 1         0 1     0   1


    Xét tập các vector độ dài 7 trong nhân (null space) của H (các vector mà khi
nhân với H cho kết quả 000). Theo lý thuyết về các không gian tuyến tính, vì hạng
của H là 3, ta kỳ vọng rằng không gian rỗng của H có 4 chiều. Các từ mã 24 này là:
                       0000000     0100101     1000011     1100110
                       0001111     0101010     1001100     1101001
                       0010110     0110011     1010101     1110000
                       0011001     0111100     1011010     1111111


    Vì tập từ mã là không gian rỗng của một ma trận, nó là tuyến tính theo nghĩa
tổng của bất kỳ cặp từ mã nào cũng là một từ mã. Tập từ mã do đó tạo thành một
không gian con tuyến tính 4 chiều trong không gian vector 7 chiều.
    Quan sát các từ mã ta thấy trừ từ mã gồm toàn số 0, số lượng số 1 tối thiểu là 3.
Giá trị này gọi là trọng số nhỏ nhất của mã. Dễ thấy rằng trọng số nhỏ nhất của mã
phải ít nhất là 3 vì tất cả các cột của H là khác nhau, vì vậy không có hai cột nào có



                                                                                        118
tổng bằng 0. Việc khoảng cách nhỏ nhất là 3 có thể được thấy từ thực tế là tổng của
hai cột bất kỳ phải là một trong các cột của ma trận.
     Vì mã là tuyến tính, sự khác biệt giữa hai từ mã bất kỳ cũng là một từ mã, và do
đó hai từ mã bất kỳ khác nhau tại ít nhất ba vị trí. Số vị trí khác nhau tối thiểu của
hai từ mã gọi là khoảng cách tối thiểu của mã. Khoảng cách tối thiểu của mã là một
độ đo cho biết các từ mã khác nhau như thế nào và nó cũng xác định các từ mã phân
biệt thế nào ở đầu ra của kênh. Với mã tuyến tính, khoảng cách tối thiểu bằng với
trọng số tối thiểu. Ta muốn phát triển các mã mà có khoảng cách tối thiểu lớn.
     Với mã được lấy làm ví dụ ở trên, khoảng cách tối thiểu là 3. Do đó nếu một từ
mã c bị lỗi ở một vị trí nào đó, nó sẽ khác với bất kỳ từ mã nào khác tại ít nhất hai vị
trí và do đó gần với c hơn bất kỳ từ mã nào khác. Nhưng liệu ta có thể tìm ra từ mã
nào là gần nhất mà không cần kiểm tra tất cả từ mã hay không?
    Câu trả lời là có. Ta có thể sử dụng cấu trúc của ma trận H để giải mã. Ma trận H
– ma trận kiểm tra chẵn lẻ - có tính chất là với mọi từ mã c, Hc = 0. Giả sử ei là vector
mà tại vị trí i giá trị bit bằng 1 và 0 tại các vị trí khác. Nếu từ mã bị lỗi ở vị trí i, vector
nhận được r = c + ei. Nếu ta nhân vector này với ma trận H, ta được:
                             𝐻𝑟 = 𝐻(𝑐 + 𝑒 ) = 𝐻𝑐 + 𝐻𝑒 = 𝐻𝑒
    là vector ứng với cột thứ i của H. Do đó nhìn vào Hr, ta có thể tìm vị trí lỗi trong
vector. Đảo ngược bit này cho ta một từ mã. Như vậy ta có một thủ tục đơn giản để
sửa một lỗi trong chuỗi nhận được. Ta đã xây dựng một bảng mã với 16 từ mã với
độ dài khối là 7, có thể sửa một lỗi. Mã này được gọi là mã Hamming.
    Ta vẫn chưa định rõ một thủ tục mã hóa đơn giản; ta có thể dùng bất kỳ ánh xạ
nào từ một tập 16 thông điệp vào các từ mã. Nhưng nếu ta xét 4 bit đầu tiên của các
từ mã trong bảng, ta thấy rằng nó bao gồm tất cả 24 tổ hợp của 4 bit. Do đó ta có thể
sử dụng 4 bit này làm 4 bit của thông điệp ta muốn truyền đi; 3 bit còn lại khi đó
được xác định bởi mã. Nói chung, mã tuyến tính có thể được điều chỉnh để ánh xạ là
hiện, do đó k bit đầu tiên trong mỗi từ mã biểu diễn thông điệp, và n-k bit còn lại
đóng vai trò kiểm tra chẵn lẻ. Mã như vậy gọi là mã hệ thống (systematic code). Mã
này thường được xác định bởi độ dài khối n, số bit thông tin k và khoảng cách tối
thiểu d. Ví dụ, mã trên được gọi là mã Hamming (7, 4, 3), trong đó n=7, k=4, và d=3.
     Để dễ hiểu cách hoạt động của mã Hamming, ta có thể dùng biểu đồ Venn. Xét
biểu đồ Venn có ba vòng tròn và bốn vùng giao nhau (Hình 7.11). Để gửi đi thông
tin biểu diễn bởi 1101, ta đặt 4 bit thông tin đó trong các vùng giao nhau như trong
hình vẽ. Sau đó ta đặt một bit chẵn lẻ trong mỗi vùng còn lại do vậy mà có một số
chẵn số 1 trong mỗi vòng tròn. Do đó, các bit chẵn lẻ được chỉ ra trong Hình 7.12.




                                                                                            119
                          Hình 7.11. Biểu đồ Venn với các bit thông tin




                     Hình 7.12. Biểu đồ Venn với bit thông tin và bit chẵn lẻ

     Bây giờ giả sử rằng một trong các bit bị thay đổi; ví dụ một bit thông tin bị thay
đổi từ 1 thành 0 như trong Hình 7.13. Khi đó ràng buộc chẵn lẻ bị vi phạm trong hai
hình tròn (tô đậm trong hình), và không khó để thấy rằng trong trường hợp này, bit
lỗi phải nằm trong giao của hai hình tròn. Tương tự với các trường hợp lỗi khác,
không khó để thấy rằng mã này có thể phát hiện và sửa bất kỳ lỗi đơn nào trong từ
mã nhận được.
     Ta có thể dễ dàng tổng quát hóa thủ tục này để xây dựng các ma trận H lớn hơn.
Nếu ta sử dụng l hàng trong H, mã thu được sẽ có độ dài khối 𝑛 = 2 − 1, 𝑘 = 2 −
𝑙 − 1, và khoảng cách cực tiểu 3. Các mã này được gọi là mã Hamming và có thể sửa
một lỗi.
    7.7.2 Các mã sửa lỗi khác
    Mã Hamming là ví dụ đơn giản nhất về mã kiểm tra chẵn lẻ tuyến tính. Nó
minh họa nguyên lý ẩn dưới cấu tạo của các mã tuyến tính khác. Tuy nhiên khi độ
dài khối lớn, khả năng sẽ có nhiều hơn một lỗi trong khối. Đầu những năm 1950,

                                                                                   120
Reed và Solomon đã tìm ra một lớp mã sửa nhiều lỗi cho các kênh không phải nhị
phân. Trong những năm cuối của thập niên đó, Bose và Ray-Chaudhuri và
Hocquenghem đã tổng quát hóa ý tưởng của mã Hamming, sử dụng lý thuyết
trường Galois để xây dựng mã sửa t lỗi (gọi là mã BCH) với t tùy ý. Từ đó, nhiều
nhà khoa học đã phát triển các mã khác nữa và cũng phát triển các thuật toán giải
mã hiệu quả đi kèm. Với sự ra đời của mạch tích hợp, việc cài đặt các mã khá phức
tạp trong phần cứng trở nên khả thi hơn và góp phần hiện thực hóa hiệu quả sửa lỗi
đã được chỉ ra bởi định lý dung lượng kênh của Shannon. Ví dụ, tất cả các máy chơi
đĩa CD (compact disc) có mạch sửa lỗi dựa trên hai mã Reed-Solomon (32, 28, 5) và
(28, 24, 5). Các mã này cho phép bộ giải mã sửa các burst tới 4000 lỗi.
    Tất cả các mã nói trên là mã khối – chúng ánh xạ một khối bit thông tin thành từ
mã kênh và không có sự phụ thuộc nào với các bit thông tin trong quá khứ. Một lựa
chọn khác là thiết kế các mã mà mỗi khối ra phụ thuộc không chỉ vào khối vào hiện
thời mà còn một số thông tin trong quá khứ nữa. Một dạng của mã đó là mã chập.
Lý thuyết về mã chập đã được phát triển đáng kể trong 40 năm qua.
    Trong nhiều năm, không thuật toán mã nào tiệm cận tới được giới hạn tối ưu
nêu ra trong định lý của Shannon. Với một kênh đối xứng nhị phân với xác suất
chéo p, ta sẽ cần một mã mà có thể sửa tới np lỗi trong một khối độ dài n và có n(1-
H(p)) bit thông tin. Ví dụ, mã lặp đã đề cập ở trên có thể sửa tới n/2 lỗi trong một
khối dài n, nhưng tốc độ của nó tiến tới 0 theo n. Cho tới năm 1972, tất cả các mã
được biết mà có thể sửa 𝑛𝛼 lỗi trong khối dài n có tốc độ tiệm cận 0. Vào năm 1972,
Justesen đã mô tả một lớp mã với tốc độ tiệm cận dương và khoảng cách nhỏ nhất
tiệm cận dương như một phần của độ dài khối.
     Vào năm 1993, một bài báo của Berrou và cộng sự đã công bố rằng kết hợp của
hai mã chập đan nhau với một bộ giải mã cộng tác song song đạt được kết quả cao
hơn nhiều so với bất kỳ mã nào đã có trước đây. Mỗi bộ giải mã đưa ra “ý kiến” của
nó về giá trị của mỗi bit cho bộ giải mã còn lại và sử dụng ý kiến của bộ giải mã kia
để xác định giá trị bit. Quá trình này được lặp lại cho tới khi cả hai bộ giải mã đồng
thuận về giá trị bit. Điều ngạc nhiên là thủ tục lặp này cho phép giải mã hiệu quả với
tốc độ tiệm cận tới dung lượng của nhiều loại kênh. Luận án của Robert Gallager đã
khơi lại sự hứng thú nghiên cứu lý thuyết về mã kiểm tra chẵn lẻ mật độ thấp
(LDPC). Vào năm 1997, MacKay và Neal chỉ ra rằng với mã LDPC, thuật toán truyền
thông điệp lặp tương tự với thuật toán được dùng để giải mã mã turbo có thể đạt tốc
độ gần tới dung lượng với xác suất cao. Cả hai lĩnh vực mã turbo và mã LDPC vẫn là
các lĩnh vực nghiên cứu sôi động và đã được ứng dụng vào truyền thông vệ tinh và
không dây.




                                                                                  121
               Hình 7.13. Biểu đồ Venn trong đó một trong các bit thông tin bị thay đổi



7.8. DUNG LƯỢNG PHẢN HỒI (FEEDBACK CAPACITY)

     Một kênh có phản hồi được minh họa trong Hình 7.14. Ta giả sử các ký hiệu mà
bộ giải mã nhận được được truyền ngược lại ngay lập tức và không nhiễu tới bộ mã
hóa, và sau đó ký hiệu này có thể được dùng để xác định ký hiệu được truyền kế
tiếp. Liệu khi có phản hồi thì việc truyền tin có tốt hơn không? Thật ngạc nhiên, câu
trả là không.

           W                        Xt(W,Yt-1)                     Yt                     Ŵ
                                                     Kênh
                    Bộ mã hóa                                              Bộ giải mã
                                                     p(y|x)



                           Hình 7.14. Kênh rời rạc không nhớ có phản hồi

    Định nghĩa: Dung lượng với phản hồi (CFB) của một kênh rời rạc không nhớ là
cận trên đúng của tất cả các tốc độ có thể đạt được bởi các mã phản hồi.
    Định lý: 𝐶     = 𝐶 = max 𝐼(𝑋; 𝑌)
                             ( )

    Chứng minh:
    Vì mã không phản hồi là một trường hợp riêng của mã phản hồi, bất kỳ tốc độ
nào có thể đạt không cần phản hồi là có thể đạt với phản hồi và do đó
                                                 𝐶   ≥𝐶
    Chứng minh bất đẳng thức chiều ngược lại hơi lắt léo một chút. Ta không thể sử
dụng cùng chứng minh như ở phần ngược của định lý mã hóa không phản hồi. Bổ
đề 𝐼(𝑋 ; 𝑌 ) ≤ 𝑛𝐶 không đúng nữa do Xi phụ thuộc vào các ký hiệu nhận được trong
quá khứ, và việc 𝑌 chỉ phụ thuộc vào 𝑋 và độc lập có điều kiện với các X trong
tương lai cũng không còn đúng.


                                                                                               122
    Một thay đổi nhỏ giúp ta xử lý vấn đề trong chứng minh. Thay vì dùng 𝑋 , ta sẽ
sử dụng chỉ số W và chứng minh các bất đẳng thức tương tự. Giả sử W có phân phối
                                            ( )
đều trên {1,2, … , 2 }. Khi đó 𝑃 𝑊 ≠ 𝑊 = 𝑃 và
                           𝑛𝑅 = 𝐻(𝑊) = 𝐻 𝑊 𝑊 + 𝐼(𝑊; 𝑊 )
                                        ( )
                              ≤ 1 + 𝑃 𝑛𝑅 + 𝐼(𝑊; 𝑊 )
                                     ( )
                              ≤ 1 + 𝑃 𝑛𝑅 + 𝐼(𝑊; 𝑌 )


   bởi bất đẳng thức Fano và bất đẳng thức xử lý dữ liệu. Bây giờ ta có thể chặn
𝐼(𝑊; 𝑌 ) như sau:
                     𝐼(𝑊; 𝑌 ) = 𝐻(𝑌 ) − 𝐻(𝑌 |𝑊)

                               = 𝐻(𝑌 ) −          𝐻(𝑌 |𝑌 , … , 𝑌     , 𝑊)


                               = 𝐻(𝑌 ) −          𝐻(𝑌 |𝑌 , … , 𝑌     , 𝑊, 𝑋 )


                               = 𝐻(𝑌 ) −          𝐻(𝑌 |𝑋 )



    vì 𝑋 là một hàm của 𝑌 , 𝑌 , … , 𝑌 và W; và với điều kiện 𝑋 , 𝑌 là độc lập với W
và các giá trị của Y trong quá khứ. Tiếp tục, ta có:

                           𝐼(𝑊; 𝑌 ) = 𝐻(𝑌 ) −             𝐻(𝑌 |𝑋 )


                                    ≤         𝐻(𝑌 ) −       𝐻(𝑌 |𝑋 )


                                    =         𝐼(𝑋 ; 𝑌 )

                                    ≤ 𝑛𝐶


      từ định nghĩa dung lượng kênh rời rạc không nhớ. Kết hợp lại ta có:
                                          ( )
                                 𝑛𝑅 ≤ 𝑃         𝑛𝑅 + 1 + 𝑛𝐶


      và chia cho n và cho 𝑛 → ∞, ta kết luận:
                                              𝑅≤𝐶
      Do đó, với phản hồi ta không thể đạt tốc độ nào cao hơn khi không có phản hồi,
và:


                                                                                123
                                       𝐶    =𝐶
    Như đã thấy trong ví dụ kênh xóa nhị phân, phản hồi có thể giúp nhiều trong
việc đơn giản hóa mã hóa và giải mã. Tuy nhiên, nó không thể làm tăng dung lượng
kênh.


7.9. ĐỊNH LÝ PHÂN TÁCH KÊNH-NGUỒN

     Bây giờ ta xét vấn đề kết hợp hai kết quả cơ bản mà ta đã nghiên cứu đến giờ:
nén dữ liệu (R>H) và truyền dữ liệu (R<C). Liệu điều kiện H<C có phải là điều kiện
cần và đủ cho việc gửi một nguồn qua một kênh? Ví dụ, xét việc gửi tiếng nói hay
âm nhạc đã được số hóa qua một kênh rời rạc không nhớ. Ta có thể thiết kế mã ánh
xạ trực tiếp chuỗi các mẫu tiếng nói thành input của kênh, hay chúng ta cũng có thể
nén tiếng nói theo dạng hiệu quả nhất, rồi chọn mã hóa kênh phù hợp để gửi nó qua
kênh. Cách nào hiệu quả hơn?
     Trong phần này ta sẽ xem xét định lý nói rằng phương pháp hai bước là tốt
bằng bất cứ phương pháp truyền tin qua kênh nhiễu nào khác. Kết quả này là quan
trọng với ứng dụng thực tế. Nó ngụ ý rằng ta có thể cân nhắc việc thiết kế hệ truyền
thông như là kết hợp của hai phần, mã hóa nguồn và mã hóa kênh. Ta có thể thiết kế
các mã nguồn sao cho việc biểu diễn dữ liệu là hiệu quả nhất. Bên cạnh đó, ta thiết
kế một cách riêng biệt và độc lập các mã hóa kênh phù hợp với kênh truyền. Sự kết
hợp sẽ hiệu quả không kém gì các thiết kế mà giải quyết đồng thời hai vấn đề mã
hóa.
    Mọi loại dữ liệu đều được biểu diễn sử dụng bảng chữ cái nhị phân. Hầu hết các
hệ thống truyền thông hiện đại là truyền thông số và dữ liệu được truyền là dữ liệu
dạng nhị phân. Điều này mang lại tiện ích rất lớn. Các máy ATM hay Internet sử
dụng biểu diễn nhị phân chung cho phép tiếng nói, video và các loại dữ liệu khác
(đã được số hóa) sử dụng chung kênh truyền thông.


                                                                         ^

                                                                        Vn


                        Hình 7.15. Mã hóa kênh và nguồn đồng thời



                                                                                   ^

                                                                                  Vn




                        Hình 7.16. Mã hóa kênh và nguồn tách nhau



                                                                                124
    Định lý: Nếu 𝑉 , 𝑉 , … , 𝑉 là một quá trình ngẫu nhiên với bảng chữ cái hữu
hạn thỏa mãn AEP và H(V)<C, khi đó tồn tại một mã kênh-nguồn với xác suất lỗi
𝑃(𝑉 ≠ 𝑉 ) → 0. Ngược lại, với bất kỳ quá trình ngẫu nhiên dừng nào, nếu H(V)>C,
xác suất lỗi bị chặn bởi giá trị lớn hơn 0, và không thể truyền quá trình này qua kênh
với xác suất lỗi thấp tùy ý.
    Chứng minh:
      Tính có thể đạt. Phần quan trọng nhất của chứng minh xuôi là mã hóa hai giai
đoạn đã mô tả ở trên. Vì ta giả sử rằng quá trình ngẫu nhiên thỏa mã AEP, tồn tại
                       ( )
một tập điển hình 𝐴 với kích thước ≤ 2 ( (𝒱 ) và chứa hầu hết xác suất. Ta sẽ chỉ
mã hóa các chuỗi nguồn thuộc vào tập điển hình; tất cả các chuỗi khác được coi như
lỗi, chúng đóng góp không quá 𝜖 vào xác suất lỗi.
                                                 ( )
    Ta đánh chỉ số tất cả các chuỗi thuộc 𝐴 . Vì có không quá 2 ( ) chuỗi như
vậy, 𝑛(𝐻 + 𝜖) bit là đủ đánh chỉ số tập này. Ta có thể truyền chỉ số mong muốn tới
người nhận với xác suất lỗi nhỏ hơn 𝜖 nếu:
                                   𝐻(𝒱) + 𝜖 = 𝑅 < 𝐶
                                                                                ( )
    Người nhận có thể xây dựng lại 𝑉 bằng cách đánh số tập điển hình 𝐴 và
chọn chuỗi tương ứng với chỉ số ước lượng được. Chuỗi này sẽ giống với chuỗi đã
được truyền với xác suất cao. Ta có:
                                          ( )                       ( )
               𝑃 𝑉 ≠𝑉       ≤𝑃 𝑉 ∉𝐴             + 𝑃(𝑔(𝑌 ) ≠ 𝑉 |𝑉 ∈ 𝐴      )
                            ≤ 𝜖 + 𝜖 = 2𝜖


    với n đủ lớn. Do đó ta có thể xây dựng lại chuỗi với xác suất lỗi thấp với n đủ
lớn nếu:
                                        𝐻(𝒱) < 𝐶
    Phần ngược: Ta muốn chỉ ra rằng 𝑃 𝑉 ≠ 𝑉            → 0 bao hàm rằng 𝐻(𝒱) ≤ 𝐶 cho
bất kỳ chuỗi mã kênh-nguồn nào.
                                   𝑋 (𝑉 ): 𝒱 → 𝒳
                                    𝑔 (𝑌 ): 𝒴 → 𝒱


     Do đó 𝑋 (. ) cho phép gán ngẫu nhiên từ mã cho các chuỗi dữ liệu 𝑉 , và 𝑔 (. )
là hàm giải mã bất kỳ. Theo bất đẳng thức Fano, ta có:
            𝐻 𝑉 𝑉    ≤1+𝑃 𝑉 ≠𝑉             log|𝒱 | = 1 + 𝑃 𝑉 ≠ 𝑉   𝑛 log |𝒱|


    Do đó
                           𝐻(𝑉 , 𝑉 , … , 𝑉 )
                  𝐻(𝒱) ≤
                                  𝑛

                                                                                  125
                         𝐻(𝑉 )
                        =
                           𝑛
                         1         1
                        = 𝐻 𝑉 𝑉 + 𝐼(𝑉 ; 𝑉 )
                         𝑛         𝑛
                         1                      1
                        ≤ 1 + 𝑃 𝑉 ≠ 𝑉 𝑛 log|𝒱| + 𝐼(𝑉 ; 𝑉 )
                         𝑛                      𝑛
                         1                      1
                        ≤ 1 + 𝑃 𝑉 ≠ 𝑉 𝑛 log|𝒱| + 𝐼(𝑋 ; 𝑌 )
                         𝑛                      𝑛
                         1
                        ≤ + 𝑃 𝑉 ≠ 𝑉 log|𝒱| + 𝐶
                         𝑛


    trong đó (a) đúng theo định nghĩa tỉ lệ entropy của quá trình dừng, (b) đúng
theo bất đẳng thức Fano, (c) đúng do bất đẳng thức xử lý dữ liệu, và (d) đúng do
tính không nhớ của kênh. Bây giờ cho 𝑛 → ∞, ta có 𝑃 𝑉 ≠ 𝑉 → 0 và do đó
                                         𝐻(𝒱) ≤ 𝐶
      Do vậy, ta có thể truyền một nguồn ergodic dừng qua một kênh nếu và chỉ nếu
tỉ lệ entropy của nó nhỏ hơn dung lượng kênh. Định lý phân tách kênh-nguồn cho
phép ta xét vấn đề mã hóa nguồn tách biệt với vấn đề mã hóa kênh.


    ĐỌC THÊM




                Hình 7.17. Mô hình kênh nhiễu cho bài toán nhận dạng tiếng nói




    Nhiều bài toán có thể được mô hình hóa theo kiểu mô hình kênh nhiễu, chẳng
hạn như bài toán nhận dạng tiếng nói. Ý tưởng chính là coi tín hiệu âm thanh như
một phiên bản câu vào (dãy từ) bị nhiễu mà thành, và nếu ta biết được đầu vào bị
gây nhiễu như thế nào thì ta có thể khôi phục lại được nó. Công thức toán học là:
                𝑊 = 𝑎𝑟𝑔𝑚𝑎𝑥       ∈𝒮 𝑃(𝑊|𝐴)   = 𝑎𝑟𝑔𝑚𝑎𝑥       ∈𝒮 𝑃(𝐴|𝑊)𝑃(𝑊)

     trong đó 𝑊 biểu diễn một xâu gồm các từ, 𝐴 biểu diễn tín hiệu âm thanh quan
sát được bởi bộ nhận dạng, và 𝒮 là tập các câu có thể có. Kênh nhiễu được đặc trưng
bởi 𝑃(𝐴|𝑊). Nếu có cách nào đó biết được 𝑃(𝐴|𝑊) và 𝑃(𝑊), 𝑊 được xác định là câu
với xác suất lớn nhất có thể. Trong chương 10 ta sẽ tìm hiểu cách ước lượng các phân
phối xác suất trên. Do trong quá trình biến đổi công thức trên có sử dụng luật Bayes,
việc tính toán ra 𝑊 còn được gọi là suy diễn Bayes.

                                                                                 126
    BÀI TẬP
    Bài 7.1. Hậu xử lý đầu ra
    Giả sử ta đang có một kênh truyền thông với xác suất chuyển là p(y|x) và dung
lượng kênh 𝐶 = max 𝐼(𝑋; 𝑌). Một nhà thống kê hậu xử lý output bằng cách đưa vào
                  ( )
hàm 𝑌 = 𝑔(𝑌), nhận được kênh 𝑝(𝑦|𝑥). Anh ta khẳng định rằng phương pháp này
cải tiến dung lượng kênh.
    a) Hãy chỉ ra rằng anh ta sai.
    b) Trong những điều kiện nào phương pháp của anh ta không làm giảm dung
lượng kênh?


    Bài 7.2. Máy chữ nhiễu
    Xét một máy chữ 26 phím.
     a) Nếu ấn một phím thì chữ cái tương ứng được in ra, dung lượng C tính theo
bit là bao nhiêu?
     b) Giả sử rằng ấn một phím không chỉ có thể in ra ký tự tương ứng mà còn cả ký
tự kế tiếp với xác suất như nhau (xem hình vẽ). Ví dụ ấn A thì có thể in ra A hoặc B,
ấn Z thì có thể sinh ra Z hoặc A. Tính dung lượng kênh.




                                                                                 127
    c) Với kênh được mô tả trong phần b, với độ dài khối là 1 và để đảm bảo xác
suất lỗi bằng 0 thì tốc độ truyền cao nhất có thể là bao nhiêu?


       Bài 7.3. Kênh Z
       Kênh Z có các bảng chữ cái vào và ra nhị phân và xác suất chuyển p(y|x) cho
bởi:
                                            1        0
                                   𝑄=                   𝑥, 𝑦 ∈ {0,1}
                                           1/2      1/2
       Tìm dung lượng của kênh Z và phân phối xác suất vào cực đại.


       Bài 7.4. Kênh có nhớ có dung lượng cao hơn
     Xét một kênh đối xứng nhị phân với 𝑌 = 𝑋 ⊕ 𝑍 trong đó ⊕ là cộng mod 2 và
𝑋 , 𝑌 ∈ {0,1}. Giả sử rằng {Zi} có xác suất biên duyên (marginal) không đổi 𝑃(𝑍 =
1) = 𝑝 = 1 − 𝑃(𝑍 = 0), nhưng 𝑍 , 𝑍 , … , 𝑍 không nhất thiết độc lập. Giả sử 𝑍 là
độc lập với đầu vào 𝑋 . Đặt C = 1 – H(p, 1-p). Chứng minh
                         𝑚𝑎𝑥   (   ,…,   ) 𝐼(𝑋   , 𝑋 , … , 𝑋 ; 𝑌 , 𝑌 , … , 𝑌 ) ≥ 𝑛𝐶


       Bài 7.5. Sử dụng đồng thời hai kênh
    Xét hai kênh rời rạc không nhớ (𝒳 , 𝑝(𝑦 |𝑥 ), 𝒴 ) và (𝒳 , 𝑝(𝑦 |𝑥 ), 𝒴 ) với dung
lượng kênh lần lượt là C1 và C2. Một kênh mới (𝒳 × 𝒳 , 𝑝(𝑦 |𝑥 ) × 𝑝(𝑦 |𝑥 ), 𝒴 × 𝒴 )
được tạo ra trong đó 𝑥 ∈ 𝒳 và 𝑥 ∈ 𝒳 được gửi đồng thời, cho kết quả là 𝑦 , 𝑦 ở
đầu ra. Tìm dung lượng của kênh mới này.


       Bài 7.6. Kênh thay đổi theo thời gian
    Xét một kênh rời rạc không nhớ thay đổi theo thời gian. Giả sử 𝑌 , … , 𝑌 là độc
lập với điều kiện 𝑋 , … , 𝑋 , trong đó phân phối có điều kiện xác định bởi 𝑝(𝑦|𝑥) =
∏ 𝑝 (𝑦 |𝑥 ). Đặt 𝑋 = (𝑋 , … , 𝑋 ), 𝑌 = (𝑌 , … , 𝑌 ). Tìm:
                                                 max 𝐼(𝑋; 𝑌)
                                                  ( )




                                                                                      128
    Bài 7.7. Ký hiệu không được sử dụng
    Chứng minh rằng dung lượng của kênh có ma trận xác suất chuyển
                                              2    1
                                            ⎡          0⎤
                                            ⎢3     3     ⎥
                                              1    1   1
                                   𝑃   |   =⎢            ⎥
                                            ⎢3     3   3⎥
                                            ⎢      1   2⎥
                                            ⎣0     3   3⎦


    đạt được với một phân phối mà gán xác suất bằng không cho một trong các ký
hiệu vào. Dung lượng của kênh là bao nhiêu? Giải thích trực quan tại sao ký hiệu đó
không được dùng.


    Bài 7.8. Kênh có sự phụ thuộc giữa các ký tự
     Xét kênh có bảng chữ cái vào và ra đều là nhị phân. Kênh này nhận vào các ký
hiệu 2 bit và sinh ra ở đầu ra 2 bit, xác định bởi ánh xạ sau: 00 → 01, 01 → 10, 10 →
11, và 11 → 00. Do đó nếu đầu vào của kênh nhận dãy 2 bit 01, đầu ra sẽ là 10 với
xác suất bằng 1. Giả sử 𝑋 , 𝑋 biểu diễn hai ký hiệu vào và 𝑌 , 𝑌 biểu diễn hai ký hiệu
ra tương ứng.
    a) Tính thông tin tương hỗ 𝐼(𝑋 , 𝑋 ; 𝑌 , 𝑌 ) như một hàm của phân phối vào trên
       bốn cặp ký hiệu có thể có.
    b) Chứng minh rằng dung lượng của một cặp chuyển (pair of transmissions)
       trên kênh này là 2 bit.
    c) Chứng minh rằng với phân phối vào cực đại, 𝐼(𝑋 ; 𝑌 ) = 0. Do đó phân phối
       trên các chuỗi vào mà đạt dung lượng kênh không cần thiết phải cực đại hóa
       thông tin tương hỗ giữa các ký hiệu riêng lẻ và đầu ra tương ứng của chúng.


    Bài 7.9. Bộ mã hóa và bộ giải mã như một phần của kênh


                                                                                  129
     Xét một kênh đối xứng nhị phân với xác suất giao nhau 0.1. Một lược đồ mã hóa
có thể dùng cho kênh này gồm hai từ mã độ dài 3, trong đó 000 dùng để mã a1 và 111
dùng để mã a2. Với lược đồ mã hóa này, ta có thể xét sự kết hợp của bộ mã hóa,
kênh, bộ giải mã để tạo thành một kênh BSC mới, với hai ký hiệu vào a1 và a2 và hai
ký hiệu ra a1 và a2.
    a) Tính xác suất giao nhau (crossover) của kênh mới này.
    b) Dung lượng kênh mới là bao nhiêu tính theo số bit mỗi lần truyền của kênh
       ban đầu.
    c) Dung lượng của kênh BSC ban đầu là bao nhiêu (xác suất giao nhau là 0.1)?
    d) Chứng minh một kết quả tổng quát là với bất kỳ kênh nào, xét bộ mã hóa,
       kênh, bộ giải mã cùng nhau tạo thành một kênh mới sẽ không cải thiện dung
       lượng tính theo số bit mỗi lần truyền của kênh ban đầu.


    Bài 7.10. Dung lượng của kênh bồ câu đưa thư
    Giả sử một vị chỉ huy quân đội bị vây hãm trong một pháo đài mà cách liên lạc
duy nhất của ông ta với đồng minh là bồ câu đưa thư. Giả sử mỗi con bồ câu chỉ có
thể mang một ký tự (8 bit), cứ mỗi năm phút lại thả đi một con, và mất đúng 3 phút
để chú bồ câu mang thư đến đích.
    a) Giả sử tất cả bồ câu đều đến đích an toàn, dung lượng của kênh truyền này
       là bao nhiêu tính theo số bit/giờ?
    b) Bây giờ giả sử rằng kẻ thù phát hiện ra cách liên lạc này và tìm cách bắn hạ
       chim bồ câu. Chúng có thể hạ một tỉ lệ 𝛼 chim được thả đi. Vì chim được thả
       với một tỉ lệ (tốc độ) không đổi, bên nhận biết khi nào bồ câu bị mất. Dung
       lượng kênh trong trường hợp này là bao nhiêu?
    c) Bây giờ lại giả sử rằng kẻ thù trở nên khôn ngoan hơn, mỗi khi bắn hạ được
       một con chim bồ câu, chúng lại gửi một con chim giả mang theo một lá thư
       ngẫu nhiên (chọn ngẫu nhiên theo phân phối đều từ tất cả các ký tự 8 bit có
       thể có). Dung lượng kênh tính theo bit/giờ là bao nhiêu?
     Thiết lập một mô hình phù hợp cho kênh trong mỗi trường hợp kể trên, và chỉ
ra làm thế nào để tìm được dung lượng.


    Bài 7.11. Bảng chữ cái nhiễu
    Xét kênh:




                                                                               130
   Trong đó 𝒳 = {0,1,2,3}, Y = X + Z và Z được phân phối đều trên tập ba giá trị
nguyên khác nhau 𝒵 = {𝑧 , 𝑧 , 𝑧 }.
    a) Tính dung lượng cực đại theo tất cả các khả năng chọn bảng chữ cái 𝒵. Đưa
       ra các giá trị nguyên phân biệt và hàm phân phối tương ứng.
    b) Dung lượng cực tiểu theo tất cả các khả năng chọn bảng chữ cái 𝒵 là bao
       nhiêu? Đưa ra các giá trị nguyên phân biệt và hàm phân phối tương ứng.


    Bài 7.12. Kênh thắt cổ chai
     Giả sử một tín hiệu 𝑋 ∈ 𝒳 = {1,2, … , 𝑚} đi qua một chuyển có sự can thiệp
(intervening transition) 𝑋 → 𝑉 → 𝑌:




     trong đó 𝑥 = {1,2, … , 𝑚}, 𝑦 = {1,2, … , 𝑚} và 𝑣 = {1,2, … , 𝑘}. Ở đây p(v|x) và p(y|v)
là tùy ý và kênh có xác suất chuyển 𝑝(𝑦|𝑥) = ∑ 𝑝(𝑣|𝑥)𝑝(𝑦|𝑣). Chứng minh 𝐶 ≤
log 𝑘.


    Bài 7.13. Máy chữ nhiễu
    Xét kênh với 𝑥, 𝑦 ∈ {0,1,2,3} và xác suất chuyển p(y|x) cho bởi ma trận sau:
                                          1   1
                                        ⎡       0    0⎤
                                        ⎢2    2       ⎥
                                              1 1
                                        ⎢0           0⎥
                                        ⎢     2 2     ⎥
                                        ⎢0      1    1⎥
                                              0
                                        ⎢       2    2⎥
                                        ⎢1           1⎥
                                              0 0
                                        ⎣2           2⎦


    a) Tìm dung lượng kênh.
    b) Định nghĩa biến ngẫu nhiên z = g(y) trong đó
                                              𝐴 𝑛ế𝑢 𝑦 ∈ {0,1}
                                    𝑔(𝑦) =
                                              𝐵 𝑛ế𝑢 𝑦 ∈ {2,3}
    Tính I(X;Z) theo hai trường hợp sau
                                                     𝑛ế𝑢 𝑥 ∈ {1,3}
                                  (i)   𝑝(𝑥) =
                                                   0 𝑛ế𝑢 𝑥 ∈ {0,2}



                                                                                        131
                                                      0 𝑛ế𝑢 𝑥 ∈ {1,3}
                               (ii)      𝑝(𝑥) =
                                                       𝑛ế𝑢 𝑥 ∈ {0,2}
    c) Tìm dung lượng của kênh giữa x và z, đặc biệt khi 𝑥 ∈ {0,1,2,3}, 𝑧 ∈ {𝐴, 𝐵}, và
       xác suất chuyển p(z|x) cho bởi

                         𝑝(𝑍 = 𝑧|𝑋 = 𝑥) =               𝑃(𝑌 = 𝑦 |𝑋 = 𝑥)
                                             (    )

    d) Ứng với phân phối của X trong phần (i) của câu b, X, Y, Z có tạo thành một
       xích Markov hay không?


    Bài 7.14. Kênh xóa
    Giả sử {𝒳, 𝑝(𝑦|𝑥), 𝒴} là một kênh rời rạc không nhớ với dung lượng C. Giả sử
kênh này được phân tầng (cascaded) tức thời với một kênh xóa {𝒴, 𝑝(𝑠|𝑦), 𝒮} mà xóa
𝛼 số ký hiệu của nó.




    Cụ thể, 𝒮 = {𝑦 , 𝑦 , … , 𝑦 , 𝑒} và
                            𝑃(𝑆 = 𝑦|𝑋 = 𝑥) = 𝛼 𝑝(𝑦|𝑥), 𝑦 ∈ 𝒴
                                      𝑃(𝑆 = 𝑒|𝑋 = 𝑥) = 𝛼
    Xác định dung lượng của kênh này.


    Bài 7.15. Lựa chọn kênh
    Tìm dung lượng C của hợp của hai kênh (𝒳 , 𝑝 (𝑦 |𝑥 ), 𝒴 ) và
(𝒳 , 𝑝 (𝑦 |𝑥 ), 𝒴 ), trong đó tại mỗi thời điểm, ta có thể gửi một ký hiệu qua kênh 1
hay kênh 2 nhưng không sử dụng đồng thời cả hai. Giả sử các bảng chữ cái ra là
phân biệt, không giao nhau.
    a) Chứng minh 2 = 2 + 2 . Do đó 2 là kích thước bảng chữ cái hiệu quả
       của một kênh với dung lượng C.
    b) So sánh với một bài tập trong Chương 3 trong đó 2 = 2 + 2 , và giải
       thích phần a theo số lượng hiệu quả các ký hiệu không nhiễu.
    c) Sử dụng kết quả trên để tính dung lượng kênh sau:




                                                                                  132
133
Chương 8
TRÒ CHƠI CÁ CƯỢC


    Mới nhìn qua, lý thuyết thông tin và trò chơi cá cược có vẻ không liên quan gì
đến nhau. Tuy nhiên, như chúng ta sẽ thấy, tính đối ngẫu mạnh mẽ giữa tốc độ tăng
trưởng đầu tư trong một cuộc đua ngựa và tỉ lệ entropy của cuộc đua đó. Thực vậy,
tổng của tỉ lệ tăng trưởng và tỉ lệ entropy là một hằng số. Trong quá trình chứng
minh điều này, chúng ta sẽ chứng minh rằng giá trị tài chính của thông tin bên lề là
bằng với thông tin tương hỗ giữa cuộc đua ngựa và thông tin bên lề đó. Trò đua
ngựa là trường hợp đặc biệt của đầu tư vào thị trường chứng khoán, một chủ đề ứng
dụng thú vị trong lý thuyết thông tin.


8.1. TRÒ CHƠI CÁ CƯỢC ĐUA NGỰA




                              Hình 8.1. Một trường đua ngựa




     Giả sử có 𝑚 con ngựa chạy thi với nhau trong một cuộc đua (Hình 8.1). Con
ngựa thứ 𝑖 có thể thắng với xác xuất là 𝑝 . Nếu con ngựa 𝑖 thắng thì ai đầu tư 1 đô la
cho nó sẽ thu về 𝑜 đô la. Còn nếu con ngựa đó thua thì người đầu tư sẽ không nhận
lại được đồng nào.
    Có hai cách để mô tả tỉ lệ đặt cược (odds): đặt-1-ăn-a và 1-ăn-b. Cách đầu tiên
đòi hỏi việc thanh toán diễn ra trước cuộc đua. Người cá cược đặt 1 đô la trước cuộc
đua và với tỉ lệ đặt cược đặt-1-ăn-a sẽ nhận được a đô la sau cuộc đua nếu như con
ngựa của anh ta thắng và không được gì nếu con ngựa đấy thua. Cách còn lại thì

                                                                                  134
thanh toán sau cuộc đua. Với tỉ lệ 1-ăn-b, người cá độ sẽ trả 1 đô la sau cuộc đua nếu
như con ngựa của anh ta thua và lấy được b đô la nếu con ngựa của anh ta chiến
thắng. Do vậy, kiểu đặt cược 1-ăn-b tương ứng với kiểu đặt đặt-1-ăn-a nếu 𝑏 = 𝑎– 1.
Ví dụ trong trò tung đồng xu, hai tỉ lệ đặt-1-ăn-2 và 1-ăn-1 là như nhau. Tỉ lệ này còn
gọi là tỉ lệ đặt cược công bằng hay tỉ lệ đều.
     Chúng ta giả sử rằng người đặt cược rải tất cả tiền của mình cho các con ngựa.
Đặt 𝑏 là phần tiền mà người chơi đầu tư vào con ngựa 𝑖, 𝑏 ≥ 0 và tổng ∑ 𝑏 = 1. Sau
cuộc đua, nếu con ngựa 𝑖 chiến thắng, người chơi sẽ nhận được 𝑜 lần số của số tiền
đã đặt cho con ngựa 𝑖. Tất cả các phần tiền đặt cho các con ngựa khác sẽ mất. Do
vậy, khi kết thúc cuộc đua, người chơi sẽ nhân số tiền của mình với hệ số 𝑏 𝑜 nếu
như con ngựa 𝑖 thắng và điều này sẽ xảy ra với xác suất 𝑝 . Để thuận tiện trong việc
trình bày, chúng ta sử dụng 𝑏(𝑖) và 𝑏 thay thế lẫn nhau trong suốt chương này.
     Số tiền ở cuối cuộc đua là một biến ngẫu nhiên, và người chơi mong muốn giá
trị của biến ngẫu nhiên này lớn nhất. Việc đặt tất cả vào con ngựa có giá trị mang lại
lớn nhất (có nghĩa là con ngựa với giá trị 𝑝 𝑜 lớn nhất) là đầy cám dỗ. Nhưng làm
như vậy rõ ràng là mạo hiểm vì toàn bộ số tiền có thể mất do con ngựa tốt nhất cũng
có thể thua cuộc.
    Cần phải xem xét nhiều cuộc cá cược lặp đi lặp lại để tìm hiểu qui luật của trò
chơi. Bởi vì người chơi có thể tái đầu tư tiền của mình, tài sản của họ là tích của kết
quả đạt được sau mỗi lần đua. Gọi 𝑆 là tài sản của người chơi sau 𝑛 cuộc đua. Khi
đó:

                                   𝑆 =       𝑆(𝑋 )

    Trong đó 𝑆(𝑋) = 𝑏(𝑋)𝑜(𝑋) là hệ số mà tài sản của người chơi sẽ được nhân lên
khi con ngựa 𝑋 thắng.


     Định nghĩa: Tài sản tương đối (wealth relative) 𝑆(𝑋) = 𝑏(𝑋)𝑜(𝑋) là hệ số tăng
tài sản của người chơi nếu như con ngựa 𝑋 thắng cuộc đua.


    Định nghĩa: Tốc độ nhân đôi của một cuộc đua ngựa là

                     𝑊(𝑏, 𝑝) = 𝐸 (𝑙𝑜𝑔 𝑆(𝑋)) =        𝑝 𝑙𝑜𝑔 𝑏 𝑜

    Định nghĩa tốc độ nhân đôi được giải thích bởi định lý sau.


     Định lý 8.1.1: Giả sử 𝑋 , 𝑋 , … là dãy kết quả đua độc lập và cùng phân phối
𝑝(𝑥). Khi đó tài sản của người chơi sử dụng chiến lược đặt cược 𝑏 tăng theo hàm mũ
với tốc độ (rate) 𝑊(𝑏, 𝑝) là:

                                                                                   135
                                                 ( , )
                                     𝑆 =2


    Chứng minh: Các hàm của các biến ngẫu nhiên độc lập cũng là độc lập và bởi
vậy chúng ta có log 𝑆(𝑋 ) , log 𝑆(𝑋 ) , … là độc lập và cùng phân phối. Áp dụng luật số
lớn yếu ta có:
     log 𝑆 =     ∑   log 𝑆(𝑋 ) → 𝐸 𝑙𝑜𝑔𝑆(𝑋)          theo xác suất

    Do vậy
                                                 ( , )
                                     𝑆 =2
    Bây giờ, vì tài sản của người chơi tăng lên theo 2 ( , ) , chúng ta sẽ đi tìm cách
làm cực đại số mũ 𝑊(𝑏, 𝑝) theo tất cả các cách đầu tư (portfolio) 𝑏.


     Định nghĩa: tốc độ gấp đôi tối ưu 𝑊 ∗ (𝑝) là tốc độ gấp đôi lớn nhất trong tất cả
các lựa chọn đầu tư 𝑏 có thể có:

                 𝑊 ∗ (𝑝) = 𝑚𝑎𝑥 𝑊(𝑏, 𝑝) =           𝑚𝑎𝑥          𝑝 𝑙𝑜𝑔 𝑏 𝑜
                                             :       ,∑




    Chúng ta cực đại hóa đại lượng 𝑊(𝑏, 𝑝) như một hàm của 𝑏 và với ràng buộc
∑ 𝑏 = 1. Chúng ta viết lại hàm trên với một nhân tử Lagrange và đổi cơ số của
logarit (không ảnh hưởng tới kết quả), ta có:

                            𝐽(𝑏) =     𝑝 𝑙𝑛 𝑏 𝑜 + 𝜆         𝑏

    Lấy đạo hàm theo 𝑏 ta được:
                              𝜕𝐽   𝑝
                                 =   + 𝜆, 𝑖 = 1,2, … , 𝑚
                              𝜕𝑏   𝑏
    Đặt đạo hàm riêng bằng 0 để tìm giá trị cực đại, chúng ta có:
                                             𝑝
                                   𝑏 = −
                                             𝜆
     Thay thế 𝑏 vào ràng buộc ∑𝑏 = 1, ta được 𝜆 = − 1 và 𝑏 = 𝑝 . Do vậy, chúng ta
có thể kết luận rằng 𝑏 = 𝑝 là một điểm dừng của hàm 𝐽(𝑏). Để chứng minh đây thực
sự là giá trị cực đại sẽ rất nhàm chán nếu chúng ta tiếp tục lấy đạo hàm bậc hai của
nó. Thay vì thế, chúng ta sử dụng một cách mà áp dụng được cho nhiều vấn đề:
Đoán và kiểm tra. Trong định lý kế tiếp chúng ta sẽ kiểm tra xem chiến lược đặt
cược tỉ lệ 𝑏 = 𝑝 có phải là tối ưu hay không. Đặt cược tỉ lệ được biết đến với tên là
chiến lược cá cược Kelly.
    Định lý 8.1.2 (Chiến lược đánh cược tỉ lệ là tối ưu logarit). Tốc độ gấp đôi tối ưu
cho bởi công thức:


                                                                                   136
                              𝑊 ∗ (𝑝) =       𝑝 log 𝑜 – 𝐻(𝑝)

    và đạt được nhờ lược đồ đánh cược tỉ lệ 𝑏 ∗ = 𝑝.




                   Hình 8.2. Đừng đặt tất cả trứng của bạn vào cùng một giỏ




    Chứng minh: Chúng ta viết lại hàm 𝑊(𝑏, 𝑝) theo dạng mà cực đại có thể thấy rõ
ràng:

                       𝑊(𝑏, 𝑝) =        𝑝 log 𝑏 𝑜
                                                    𝑏
                                 =      𝑝 log         𝑝𝑜
                                                    𝑝
                                 =      𝑝 log 𝑜 − 𝐻(𝑝) − 𝐷(𝑝||𝑏)

                                 ≤      𝑝 log 𝑜 − 𝐻(𝑝)

      Với dấu bằng xẩy ra khi và chỉ khi 𝑝 = 𝑏 (nghĩa là, người chơi đặt cược vào
mỗi con ngựa theo tỉ lệ ứng với xác suất thắng của nó).


    Ví dụ: Xét trường hợp chỉ có 2 con ngựa đua, trong đó con thứ nhất có thể chiến
thắng với xác suất 𝑝 và con thứ hai có thể thắng với xác suất là 𝑝 . Giả sử tỉ lệ đặt
cược là đều (đặt-1-ăn-2 cho mỗi con ngựa). Theo định lý trên, cách đặt cược tối ưu là
đặt cược tỉ lệ (nghĩa là 𝑏 = 𝑝 , 𝑏 = 𝑝 ). Tốc độ nhân đôi tối ưu là 𝑊 ∗ (𝑝) =
∑ 𝑝 log 𝑜 − 𝐻(𝑝) = 1 – 𝐻(𝑝), và tài sản người chơi tăng đến vô hạn ở tỉ lệ:
                                                (     ( ))
                                      𝑆 =2
    Như vậy, chúng ta vừa xem xét bài toán trong trường hợp dãy các cuộc đua là
độc lập và cùng phân phối, người chơi đầu tư toàn bộ tiền sau mỗi cuộc đua mà
không giữ lại tiền mặt. Khi đó, chiến lược đánh cược tỉ lệ là tối ưu.
    Bây giờ ta sẽ xem xét một trường hợp đặc biệt khi tỉ lệ đặt cược là công bằng
theo phân bố nào đó (nghĩa là không có track take và ∑ = 1). Trong trường hợp


                                                                                 137
này, chúng ta viết 𝑟 = , trong đó 𝑟 có thể hiểu là hàm phân phối trên các con ngựa
(Đây là ước lượng của nhà cái về xác suất thắng). Với định nghĩa này, chúng ta có
thể viết tốc độ gấp đôi như sau:

                             𝑊(𝑏, 𝑝) =      𝑝 log 𝑏 𝑜
                                                𝑏 𝑝
                                     =      𝑝 log
                                                𝑝 𝑟
                                     = 𝐷(𝑝||𝑟) – 𝐷(𝑝||𝑏)
    Phương trình trên cho ta cách hiểu khác về khoảng cách entropy tương đối: tốc độ
nhân đôi là sự khác biệt giữa khoảng cách từ ước lượng của nhà cái đến phân phối
thật và khoảng cách từ ước lượng của người chơi đến phân bố thật. Do vậy, người
chơi chỉ có thể kiếm được tiền khi ước lượng của họ (được biểu diễn là b) tốt hơn của
nhà cái.
   Một trường hợp đặc biệt hơn là khi tỉ lệ đặt cược là đặt-1-ăn-m cho mỗi con
ngựa. Trong trường hợp này, tỉ lệ đặt cược là công bằng theo phân bố đều và tốc độ
nhân đôi tối ưu là:
                                            1
                          𝑊 ∗ (𝑝) = 𝐷 𝑝||     = log 𝑚 – 𝐻(𝑝)
                                            𝑚
     Trong trường hợp này chúng ta có thể thấy rõ ràng tính đối ngẫu giữa nén dữ
liệu và tốc độ nhân đôi.
    Định lý 8.1.3 (Định lý bảo toàn) Với tỉ lệ đặt cược công bằng đều:
                               𝑊 ∗ (𝑝) + 𝐻(𝑝) = log 𝑚
    Do đó, tổng của tốc độ nhân đôi và tỉ lệ entropy là một hằng số.
    Mỗi bit của entropy được giảm đi làm tăng gấp đôi tài sản của người chơi. Các
cuộc đua có entropy thấp là sinh lãi nhất.
     Trong các phân tích ở trên, chúng ta giả định rằng người chơi đầu tư toàn bộ
tiền. Trong trường hợp tổng quát, chúng ta nên cho phép người chơi có sự lựa chọn
giữ lại một phần tài sản của họ bằng tiền mặt. Đặt 𝑏(0) là tỉ lệ tài sản được giữ lại
bằng tiền mặt, và 𝑏(1), 𝑏(2), … , 𝑏(𝑚) là tỉ lệ đặt cược vào các con ngựa khác nhau.
Khi đó, khi kết thúc một cuộc đua, tỉ lệ giữa tài sản cuối và tài sản ban đầu (tài sản
tương đối) sẽ là:
                               𝑆(𝑋) = 𝑏(0) + 𝑏(𝑋)𝑜(𝑋)
     Bây giờ, chiến lược tối ưu có thể phụ thuộc vào tỉ lệ đặt cược và sẽ không nhất
thiết còn ở dạng đặt cược tỉ lệ đơn giản nữa. Chúng ta phân biệt ba trường hợp con:
    1. Tỉ lệ đặt cược công bằng theo phân bố nào đó: ∑         = 1. Với tỉ lệ công bằng,
việc lựa chọn giữ tiền lại không thay đổi các phân tích trên. Lý do là vì ta có thể đặt
cược 𝑏 = cho con ngựa thứ 𝑖 (𝑖 = 1, 2, … , 𝑚) để đạt được kết quả như giữ lại tiền
mặt. Do vậy 𝑆(𝑋) = 1 bất kể con ngựa nào chiến thắng. Bất kể người chơi giữ lại bao

                                                                                    138
nhiêu tiền kết quả cũng chỉ tốt bằng với cách phân bố cho các con ngựa, và giả định
rằng người chơi phải đầu tư toàn bộ tiền không làm thay đổi các phân tích trên.
Chiến lược đặt cược tỉ lệ là tối ưu.
    2. Tỉ lệ đặt cược siêu công bằng: ∑        < 1. Trong trường hợp này, tỉ lệ thậm chí
còn tốt hơn cả tỉ lệ công bằng, bởi thế người ta luôn muốn đặt tất cả tài sản vào cuộc
đua ngựa hơn là giữ lại dưới dạng tiền mặt. Trong cuộc đua này, tỉ lệ đặt cược tỉ lệ
cũng là tối ưu. Tuy nhiên, có thể chọn được b để tạo nên Dutch book bằng cách chọn
𝑏 = 𝑐 trong đó 𝑐 = 1/ ∑ , để có 𝑜 𝑏 = 𝑐, bất kể con ngựa nào thắng. Với sự phân
phối trên, người chơi có tài sản là 𝑆(𝑋) = 1/∑          > 1 với xác suất là 1 (nghĩa là
không còn sự rủi ro nữa). Hiển nhiên, khó mà tìm được tỉ lệ đặt cược như trên trong
thực tế. Bất ngờ là Dutch book mặc dù không mạo hiểm nhưng lại không tối ưu
được tốc độ nhân đôi.
    3. Tỉ lệ đặt cược một phần công bằng: ∑         > 1. Tỉ lệ này giống với thực tế hơn.
Các nhà tổ chức đua ngựa chia nhỏ các đặt cược. Trong trường hợp này thì tối ưu
nhất là chỉ đặt một phần tiền và giữ phần còn lại bằng tiền mặt. Chiến lược đánh
cược tỉ lệ sẽ không còn tính tối ưu logarit. Tuy nhiên, người ta đã chỉ ra rằng một
dạng có tham số của chiến lược tối ưu có thể được xác định bằng cách sử dụng điều
kiện Kuhn-Tucker.


8.2. CÁ CƯỢC VÀ THÔNG TIN BÊN LỀ

    Giả sử người chơi có một vài thông tin nào đó liên quan đến kết quả trò chơi, ví
dụ thông tin về thành tích của các con ngựa trong các cuộc đua trước. Vậy giá trị của
thông tin bên lề này là gì?
     Giá trị tài chính của thông tin bên lề có thể được đánh giá bằng mức độ tăng tài
sản có được nhờ thông tin này. Theo cách đặt bài toán ở phần 8.1, độ đo giá trị thông
tin là mức độ tăng tốc độ nhân đôi nhờ những thông tin đó. Bây giờ ta sẽ tìm cách
dẫn ra sự liên hệ giữa thông tin tương hỗ và mức độ tăng của tốc độ nhân đôi.
     Để hình thành công thức từ khái niệm này, giả sử ngựa 𝑋 ∈ {1,2, … , 𝑚} thắng
cuộc đua với xác suất 𝑝(𝑥) và tỉ lệ trả đặt-1-ăn-𝑜(𝑥). Đặt 𝑝(𝑥, 𝑦) là hàm phân phối
phụ thuộc của (𝑋, 𝑌). Đặt 𝑏(𝑥|𝑦) ≥ 0, ∑ 𝑏(𝑥|𝑦) = 1 là chiến lược đặt cược có điều
kiện bất kỳ phụ thuộc vào thông tin bên lề 𝑌, trong đó 𝑏(𝑥|𝑦) là tỉ lệ tài sản đặt cược
vào con ngựa 𝑥 khi quan sát thấy (biết) 𝑦. Như đã nói ở trên, đặt 𝑏(𝑥) ≥ 0, ∑ 𝑏(𝑥) = 1
là chiến lược đặt cược không có điều kiện.
    Tốc độ nhân đôi có điều kiện và không có điều kiện là:

                        𝑊 ∗ (𝑋) = 𝑚𝑎𝑥          𝑝(𝑥) 𝑙𝑜𝑔𝑏(𝑥)𝑜(𝑥)
                                   ( )

                      𝑊 ∗ (𝑋|𝑌) = 𝑚𝑎𝑥          𝑝(𝑥, 𝑦) 𝑙𝑜𝑔𝑏(𝑥|𝑦)𝑜(𝑥)
                                   ( | )
                                           ,

                                                                                     139
    Và đặt
                              ∆𝑊 = 𝑊 ∗ (𝑋|𝑌) − 𝑊 ∗ (𝑋)
     Chúng ta thấy rằng với các cuộc đua ngựa độc lập và cùng phân phối (𝑋 , 𝑌 ), tài
                          ∗( | )                                    ∗( )
sản tăng lên theo hàm 2          với thông tin bên lề và theo hàm 2      khi không
có thông tin bên lề.
    Định lý 8.2.1: Mức độ tăng tốc độ nhân đôi ∆𝑊 nhờ có thông tin bên lề 𝑌 cho
cuộc đua ngựa 𝑋 là
                                      ∆𝑊 = 𝐼(𝑋, 𝑌)
      Chứng minh: Khi có thông tin bên lề, giá trị lớn nhất của 𝑊 ∗ (𝑋|𝑌) với thông tin
bên lề 𝑌 đạt được bằng cách áp dụng chiến lược đặt cược tỉ lệ có điều kiện [nghĩa là
𝑏 ∗ (𝑥|𝑦) = 𝑝(𝑥|𝑦)]. Do vậy
                            𝑊 ∗ (𝑋|𝑌) = 𝑚𝑎𝑥 𝐸[𝑙𝑜𝑔 𝑆]
                                         𝑥𝑦
                                       = 𝑚𝑎𝑥       𝑝(𝑥, 𝑦) 𝑙𝑜𝑔 𝑜(𝑥)𝑏(𝑥|𝑦)
                                           ( | )

                                       =     𝑝(𝑥, 𝑦) log 𝑜(𝑥)𝑝(𝑥|𝑦)

                                       =     𝑝(𝑥) log 𝑜(𝑥) − 𝐻(𝑋|𝑌)



    Khi không có thông tin bên lề, tốc độ nhân đôi tối ưu là:

                          𝑊 ∗ (𝑋) =     𝑝(𝑥) log 𝑜(𝑥) − 𝐻(𝑋)

    Do vậy, độ tăng tốc độ nhân đôi do có thông tin bên lề 𝑌 là:
                ∆𝑊 = 𝑊 ∗ (𝑋|𝑌) − 𝑊 ∗ (𝑋) = 𝐻(𝑋) − 𝐻(𝑋|𝑌) = 𝐼(𝑋; 𝑌)
    Do vậy, độ tăng của tốc độ nhân đôi bằng với thông tin tương hỗ giữa thông tin
bên lề và cuộc đua ngựa. Không ngạc nhiên khi thông tin bên lề độc lập không làm
tăng tốc độ nhân đôi.
     Mối quan hệ này có thể mở rộng cho thị trường chứng khoán. Tuy nhiên, trong
trường hợp này, người ta chỉ có thể đưa ra bất đẳng thức ∆𝑊 ≤ 𝐼, với dấu bằng xảy
ra chỉ khi thị trường chứng khoán là một cuộc đua ngựa.


8.3. CÁC CUỘC ĐUA KHÔNG ĐỘC LẬP VÀ TỈ LỆ ENTROPY

    Ví dụ phổ biến nhất về thông tin bên lề về một cuộc đua ngựa là thành tích
trong quá khứ của các chú ngựa. Nếu như các cuộc đua ngựa là độc lập, thông tin
này sẽ không có giá trị sử dụng. Nếu chúng ta giả định rằng có sự phụ thuộc giữa
các cuộc đua, ta có thể tính toán tốc độ nhân đôi hiệu quả nếu chúng ta được phép
sử dụng các kết quả cuộc đua trước để xác định chiến lược cho cuộc đua tiếp theo.



                                                                                   140
    Giả định rằng chuỗi kết quả đua ngựa {𝑋 } tạo thành một quá trình ngẫu nhiên.
Giả sử chiến lược cho mỗi cuộc đua phụ thuộc vào kết quả của các cuộc đua trước
đó. Trong trường hợp này, tốc độ nhân đôi tối ưu cho tỉ lệ đặt cược công bằng đều
là:
                  𝑊 ∗ (𝑋 |𝑋      ,𝑋         ,…,𝑋 )
                  =𝐸            max              𝐸[log 𝑆(𝑋 )| 𝑋    𝑋   ,…,𝑋 ]
                         (.|          ,…,    )
                  = log 𝑚 − 𝐻(𝑋 |𝑋               ,𝑋    ,…,𝑋 )
    đạt được với 𝑏 ∗ (𝑥 |𝑥     , … , 𝑥 ) = 𝑝(𝑥 |𝑥         , … , 𝑥 ).
    Khi kết thúc cuộc đua thứ 𝑛, tài sản của người chơi là:

                                            𝑆 =        𝑆(𝑋 )

    và số mũ trong tốc độ tăng (giả sử đặt cược đặt-1-ăn-m) là
                             1             1
                               𝐸 log 𝑆 =         𝐸 log 𝑆(𝑋 )
                             𝑛             𝑛
                                1
                             =        (log 𝑚 − 𝐻(𝑋 |𝑋 , … , 𝑋 ))
                                𝑛
                                         𝐻(𝑋 , 𝑋 , … , 𝑋 )
                             = log 𝑚 −
                                                𝑛


    Đại lượng    𝐻(𝑋 , 𝑋 , … , 𝑋 ) là entropy trung bình mỗi cuộc đua. Với một quá
trình dừng với tỉ lệ entropy là 𝐻(𝒳), ta có giới hạn:
                                     1
                               lim     𝐸 log 𝑆 + 𝐻(𝒳) = log 𝑚
                                →    𝑛
   Một lần nữa, chúng ta có kết quả là tỉ lệ entropy cộng với tốc độ nhân đôi là một
hằng số.


    Ví dụ (Đỏ và đen) Trong ví dụ này, quân bài thay thế cho ngựa và càng về sau,
kết quả càng trở nên dễ đoán hơn. Xét trò chơi đặt cược về màu của quân bài kế tiếp
trong bộ bài gồm 26 quân đỏ và 26 quân đen. Việc cá cược được lặp đi lặp lại cho tới
khi hết cả bộ bài. Chúng ta cũng giả định rằng trò chơi có tỉ lệ đặt cược đặt-1-ăn-2, có
nghĩa là người chơi sẽ nhận được gấp đôi số tiền mà anh ta đặt cho quân bài được
đoán đúng màu. Đây là tỉ lệ đặt cược công bằng nếu như số quân đỏ và đen là bằng
nhau.
    Chúng ta xem xét 2 chiến lược đặt cược sau:
    1. Nếu chúng ta đánh cược liên tục, chúng ta có thể tính toán được xác suất có
điều kiện của quân bài tiếp theo và áp dụng chiến lược đặt cược tỉ lệ. Do vậy chúng



                                                                                    141
ta nên đặt (1/2, 1/2) cho (đỏ, đen) cho quân đầu tiên, (26/51, 25/51) cho quân thứ 2
nếu như quân đầu là đen và cứ tiếp tục như thế.
    2. Một cách khác, chúng ta có thể đánh cược cả dãy 52 quân bài chỉ một lần. Có
 52
( ) dãy của 26 quân đỏ và 26 quân đen. Tất cả chúng đều có cùng khả năng. Do
 26
                                                                 52
vậy, nếu áp dụng chiến lược đánh cược tỉ lệ, chúng ta sẽ đặt 1 /( ) lượng tiền chúng
                                                                 26
ta có cho mỗi dãy và mặc cho nó “trôi nổi”.
    Chúng ta sẽ chỉ ra rằng các chiến lược trên là tương đương nhau. Ví dụ, một nửa
số dãy gồm 52 quân bài bắt đầu với đỏ và tỉ lệ tiền đặt cho các dãy bắt đầu bằng
quân đỏ trong cách thứ hai cũng là một nửa, đồng thuận với tỉ lệ được sử dụng ở
                                                                         52
cách thứ nhất. Tổng quát, chúng ta có thể kiểm chứng rằng đặt cược 1/( ) số tiền
                                                                         26
của người chơi vào mỗi kết quả có thể có sẽ (ở mỗi lần chơi) tương đương với việc
                                                                                 52
đặt cược tỉ lệ với xác suất của đỏ và đen ở lần chơi đó. Bởi vì chúng ta đặt 1/( )
                                                                                 26
lượng tài sản cho mỗi dãy kết quả có thể, và mỗi lần đặt cược làm tăng lượng tài sản
theo hệ số 252 với dãy quan sát được và 0 cho những dãy còn lại. Lượng tài sản kết
quả sẽ là:
                                        2
                                 𝑆∗ =      = 9.08
                                        52
                                        26
   Điều khá thú vị là, tiền mà người chơi thu được sau khi kết thúc trò chơi không
phụ thuộc vào dãy quân bài thực tế. Đặc điểm này giống AEP ở chỗ kết quả là như
nhau với mọi dãy. Và do đó tất cả các dãy đều là điển hình theo nghĩa này.


8.4. ENTROPY CỦA TIẾNG ANH

    Một ví dụ quan trọng về nguồn thông tin là văn bản tiếng Anh. Về trực quan, ta
không thấy ngay được rằng Tiếng Anh có phải là một quá trình egordic dừng hay
không. Có thể là không! Tuy nhiên, chúng ta quan tâm đến tỉ lệ entropy của tiếng
Anh. Chúng ta sẽ xem xét nhiều cách xấp xỉ ngẫu nhiên tiếng Anh khác nhau. Khi
chúng ta tăng độ phức tạp của mô hình, chúng ta sẽ tạo ra được văn bản nhìn giống
tiếng Anh thật sự hơn. Phương pháp xấp xỉ ngẫu nhiên càng tốt thì hiệu quả nén
cũng tốt theo.
    Để thuận tiện, chúng ta giả định rằng bảng chữ cái tiếng Anh chỉ bao gồm 26 ký
tự và dấu cách. Chúng ta bỏ qua các dấu câu và sự khác nhau giữa viết hoa hay viết
thường. Chúng ta sẽ xây dựng các mô hình cho tiếng Anh sử dụng các phân bố thực
nghiệm ước lượng từ các mẫu văn bản. Tần suất của các ký tự trong tiếng Anh khác
xa so với phân phối đều. Kí tự phổ biến nhất là E, có tần suất khoảng 13% và ký tự ít




                                                                                 142
phổ biến nhất là Q và Z xuất hiện với tần suất chỉ khoảng 0.1%. Ký tự E phổ biến
đến mức rất khó tìm được một câu với độ dài bất kỳ mà không có ký tự này 4.
     Tần số xuất hiện của các cặp ký tự cũng khác xa so với mức đều nhau. Ví dụ, ký
tự Q luôn luôn đi trước ký tự U. Cặp xuất hiện phổ biến nhất là TH, với tần suất xảy
ra thông thường là khoảng 3.7%. Chúng ta có thể sử dụng tần suất của các cặp này
để ước lượng xác suất mà các ký tự theo sau các ký tự khác. Cũng với cách này,
chúng ta có thể ước lượng được xác suất có điều kiện bậc cao hơn và xây dựng các
mô hình phức tạp hơn cho ngôn ngữ. Tuy nhiên, bậc càng cao chúng ta càng cần
nhiều dữ liệu hơn để có thể ước lượng chính xác. Ví dụ, để xây dựng ước lượng
Markov bậc 4, chúng ta phải ước lượng giá trị của 𝑝(𝑥 |𝑥 , 𝑥 , 𝑥 ). Như vậy sẽ
có 27 = 531441 mục trong bảng và chúng ta phải tiến hành xử lý hàng triệu ký tự
để tạo ra ước lượng chính xác cho các xác suất đấy.
     Các ước lượng xác suất có điều kiện có thể sử dụng để tạo ra các văn bản ngẫu
nhiên thông qua các phân bố trên (sử dụng các bộ sinh ngẫu nhiên). Tuy nhiên có
một phương pháp đơn giản hơn để mô phỏng sự ngẫu nhiên sử dụng mẫu văn bản
(ví dụ sách). Ví dụ, để tạo ra mô hình bậc 2, chúng ta mở quyển sách ngẫu nhiên và
chọn ký tự ngẫu nhiên ở trong trang đó. Đây sẽ là ký tự đầu tiên. Với ký tự tiếp theo,
chúng ta lại mở một trang ngẫu nhiên và bắt đầu bằng một điểm ngẫu nhiên khác,
đọc cho đến khi gặp lại ký tự đầu một lần nữa, sau đó lấy ký tự tiếp theo làm ký tự
thứ hai. Chúng ta lặp lại quá trình này bằng cách lại mở trang sách khác, tìm ký tự
thứ 2 và lấy ký tự xuất hiện sau nó làm ký tự thứ 3. Tiếp tục cách này, chúng ta có
thể tạo ra văn bản mà mô phỏng thống kê bậc 2 của văn bản tiếng Anh.
    Sau đây là một vài ví dụ về ước lượng Markov cho văn bản tiếng Anh lấy từ bài
báo của Shannon năm 1948.
     1. Ước lượng bậc 0 (Các ký tự là độc lập và có xác xuất ngang nhau)
     XFOML RXKHRJFFJUJ ZLPWCFWKCYJ
     FFJEYVKCQSGXYD QPAAMKBZAACIBZLHJQD
    2. Ước lượng bậc 1 (Các ký tự là độc lập và tần suất của ký tự khớp với văn bản
tiếng Anh)
   OCRO HLI RGWR NMIELWIS EU LL NBNESEBYA TH EEI ALHENHTTPA
OOBTTVA NAH BRL
     3. Ước lượng bậc 2 (Tần suất của các cặp ký tự khớp với văn bản tiếng Anh)
   ON IE ANTSOUTINYS ARE T INCTORE ST BE S DEAMY ACHIN D
ILONASIVE TUCOOWE AT TEASONARE FUSO TIZIN ANDY TOBE SEACE
CTISBE
     4. Ước lượng bậc 3 (Tần suất của bộ ba ký tự khớp với văn bản tiếng Anh)

4Một ngoại lệ thú vị là cuốn tiểu thuyết 267 trang Gadsby, tác giả Ernest Vincent Wright (NXB
Lightyear, Boston, 1997; xuất bản lần đầu năm 1939), trong đó tác giả cố ý không sử dụng ký tự E.

                                                                                                    143
   IN NO IST LAT WHEY CRATICT FROURE BERS GROCID PONDENOME OF
DEMONSTURES OF THE REPTAGIN IS REGOACTIONA OF CRE
    5. Ước lượng bậc 4 (Tần suất của bộ 4 ký tự khớp với văn bản tiếng Anh. Mỗi ký
tự đều phụ thuộc vào 3 ký tự phía trước. Các câu lấy từ sách của Lucky, Silicon
Dreams)
    THE GENERATED JOB PROVIDUAL BETTER TRAND THE DISPLAYED
CODE, ABOVERY UPONDULTS WELL THE CODERST IN THESTICAL IT DO
HOCK BOTHE MERG. (INSTATES CONS ERATION. NEVER ANY OF PUBLE
AND TO THEORY. EVENTIAL CALLEGAND TO ELAST BENERATED IN WITH
PIES AS IS WITH THE)
    Thay vì tiếp tục với các mô hình ký tự, chúng ta chuyển sang các mô hình từ
    6. Mô hình từ bậc 1. (Các từ được chọn độc lập nhưng với tần suất như trong
tiếng Anh)
   REPRESENTING AND SPEEDILY IS AN GOOD APT OR COME CAN
DIFFERENT NATURAL HERE HE THE A IN CAME THE TO OF TO EXPERT
GRAY COME TO FURNISHES THE LINE MESSAGE HAD BE THESE
    7. Mô hình từ bậc 2 (Các từ kề nhau là khớp với văn bản tiếng Anh)
   THE HEAD AND FRONTAL ATTACK ON AN ENGLISH WRITER THAT THE
CHARACTER OF THIS POINT IS THEREFORE ANOTHER METHOD FOR THE
LETTERS THAT THE TIME OF WHO EVER TOLD THE PROBLEM FOR AN
UNEXPECTED
     Qua các ví dụ trên, ta có thể thấy các ước lượng ngày càng gần tiếng Anh thật
hơn. Ví dụ, các cụm từ khá dài ở ước lượng cuối có thể dễ dàng bắt gặp trong các
câu tiếng Anh thực tế. Điều này có vẻ chỉ ra rằng chúng ta có thể có một ước lượng
rất tốt bằng cách sử dụng một mô hình phức tạp hơn. Những mô hình như thế có
thể được sử dụng để ước lượng entropy của tiếng Anh. Ví dụ, entropy của mô hình
bậc không là log 27 = 4.76 bit mỗi chữ cái. Khi chúng ta tăng độ phức tạp của mô
hình, cấu trúc tiếng Anh được nắm bắt tốt hơn và sự không chắc chắn có điều kiện
của ký tự tiếp theo được giảm đi. Mô hình bậc một cho ra ước lượng về entropy là
4.03 bit/ký tự trong khi mô hình bậc bốn cho ước lượng là 2.8 bit/ký tự, nhỏ hơn
đáng kể so với mô hình bậc một.
    Các phân phối của tiếng Anh rất hữu ích trong việc giải mã văn bản tiếng Anh
đã được mã hóa. Ví dụ, với cách mã hóa thay thế đơn giản (mỗi ký tự được thay thế
bằng ký tự khác) có thể giải mã bằng cách tìm kiếm các ký tự phổ biến nhất và đoán
nó là kí tự thay thế cho E và tiếp tục như thế. Tính chất dư thừa trong tiếng Anh có
thể được sử dụng để lấp vào một số ký tự còn thiếu sau khi những ký tự khác đã
được giải mã, ví dụ:
    TH_R_ _S _NLY _N_ W_Y T_F_LL _N TH_ V_W_LS _N TH_S S_NT_NC_


                                                                                  144
    Một phần cảm hứng cho các nghiên cứu có tính chất nền móng của Shannon
trong lý thuyết thông tin đến từ công việc trong lĩnh vực mật mã của ông trong
chiến tranh thế giới lần thứ hai. Lý thuyết toán học về mật mã và mối quan hệ của
nó với entropy của ngôn ngữ đã được phát triển trong công trình của Shannon
(1948).
     Các mô hình ngôn ngữ ngẫu nhiên cũng đóng vai trò chủ chốt trong nhiều hệ
thống nhận dạng tiếng nói. Một mô hình được sử dụng phổ biến là mô hình từ
trigram (mô hình Markov bậc hai), mô hình này ước lượng xác suất của từ tiếp theo
dựa vào hai từ đã xuất hiện đằng trước. Thông tin về tín hiệu tiếng nói được kết hợp
với mô hình ngôn ngữ để ước lượng chính xác nhất có thể từ mà đã sinh ra tiếng nói
tương ứng. Các mô hình ngẫu nhiên nhận dạng tiếng nói với độ chính xác cao một
cách đáng ngạc nhiên, ngay cả khi chúng không trực tiếp sử dụng các luật ngữ pháp
phức tạp mà các ngôn ngữ tự nhiên như tiếng Anh tuân theo.
     Chúng ta có thể áp dụng các kỹ thuật được nêu trong phần này để ước lượng tỉ
lệ entropy của các nguồn thông tin khác như âm thanh hay hình ảnh. Những vấn đề
này được giới thiệu một cách thú vị và không nặng về kỹ thuật trong cuốn sách của
Lucky.


    BÀI TẬP
    Bài 8.1. Đua ngựa
     Giả sử rằng một người thích làm cực đại tốc độ nhân đôi cho một cuộc đua
ngựa. Cho p1, p2,… , pm biểu diễn xác suất chiến thắng của m con ngựa. Khi nào thì tỉ
lệ đặt cược (o1, o2,…, om) mang lại giá trị tốc độ nhân đôi cao hơn là tỉ lệ đặt cược (o’1,
o’2,…,o’m) ?
    Bài 8.2. Đua ngựa
    Ba con ngựa tham gia một cuộc đua. Người đặt cược chọn tỉ lệ đặt-1-ăn-3 cho
mỗi con ngựa. Tất cả đều là tỉ lệ đặt cược công bằng dưới giả định rằng tất cả các con
ngựa đều có khả năng chiến thắng cuộc đua như nhau. Xác suất chiến thắng thực sự
được biết là
    𝑝 = (𝑝 , 𝑝 , 𝑝 ) = (1/2 , 1/4, 1/4)    (1)
    Đặt 𝑏 = (𝑏 , 𝑏 , 𝑏 ), 𝑏 ≥ 0, ∑𝑏 = 1, là lượng đầu tư vào mỗi con ngựa.
    Lượng tài sản logarit kỳ vọng là
    W(b) = ∑      𝑝 log 3𝑏          (2)
    a) Làm cực đại giá trị b ở trên để tìm 𝑏∗ và 𝑊 ∗ . Vì thế, giá trị tài sản đạt được
                                                                    ∗
       trong các cuộc đua lặp lại có thể tăng tới vô hạn theo 2       với xác suất bằng
       một.




                                                                                       145
    b) Chỉ ra rằng nếu chúng ta đặt tất cả tài sản hiện có cho con ngựa số 1, con có
       khả năng thắng cao nhất, ở mỗi cuộc đua, chúng ta sẽ mất trắng với xác suất
       cũng bằng một.
    Bài 8.3. Đua ngựa
    Xét một cuộc đua 3 ngựa với xác suất thắng là (p1, p2, p3) =(3/4, 1/8, 1/8)
    Và tỉ lệ đặt cược công bằng với sự chú ý đến phân bố (false)
                                (𝑟 , 𝑟 , 𝑟 ) = (1/4, 1/4, 1/4)
    Do vậy, tỉ lệ đặt cược là
                                   (𝑜 , 𝑜 , 𝑜 ) = (4, 4, 2)
    a) Giá trị entropy của cuộc đua là bao nhiêu?
    b) Tìm tập tất cả các đặt cược (𝑏 , 𝑏 , 𝑏 ) mà giá trị tài sản kết hợp
       (compounded) trong các cuộc đua liên tục sẽ tăng đến vô hạn.
    c) Tìm tỉ lệ tăng tối ưu 𝑏 ∗ , và tỉ lệ tăng kết quả 𝑊 ∗ .


    Bài 8.4. Entropy của một cuộc đua công bằng
    Giả sử X ~ p(x), x = 1, 2, …, m là xác suất thắng của các con ngựa tham gia một
cuộc đua. Giả sử tỉ lệ đặt cược o(x) là công bằng theo p(x), tức là 𝑜(𝑥) = ( ). Giả sử
b(x) là tỉ lệ đặt cược lên con ngựa x, 𝑏(𝑥) ≥ 0, ∑ 𝑏(𝑥) = 1. Khi đó hệ số tài sản kết
quả sẽ là S(x) = b(x)o(x), với xác suất p(x).
    a) Tìm tài sản kỳ vọng ES(X).
    b) Tìm W*, tốc độ tăng tài sản tối ưu.
    c) Giả sử
                                         1, 𝑋 = 1 ℎ𝑜ặ𝑐 2
                                    𝑌=
                                           0, 𝑛𝑔ượ𝑐 𝑙ạ𝑖
      Nếu thông tin này được biết trước cuộc đua thì nó làm tăng tốc độ tăng tài
      sản W* là bao nhiêu?
    d) Tìm I(X;Y).
    Bài 8.5. Cuộc đua âm
     Xét một cuộc đua có m con ngựa tham gia với xác suất thắng lần lượt là p1, p2, …,
pm. Lần này người chơi lại muốn một con ngựa xác định sẽ thua. Anh ta đặt cược (b1,
b2, …, bm), ∑ 𝑏(𝑥) = 1 vào các con ngựa. Anh ta mất bi nếu con i thắng và còn lại
phần đặt vào các con ngựa khác. Do đó 𝑆 = ∑ 𝑏 , với xác suất pi, và anh ta muốn
cực đại hóa ∑ 𝑝 ln (1 − 𝑏 ) với ràng buộc ∑ 𝑏 = 1.
    a) Tìm chiến lược đầu tư tối ưu b*. Chú ý ràng buộc là ∑ 𝑏 = 1 chứ không yêu
       cầu các bi phải không âm.
    b) Tỉ lệ tăng trưởng tối ưu là bao nhiêu?


                                                                                  146
    Bài 8.6. Cá cược
    Giả sử có trò chơi cá cược X mà mỗi đồng đầu tư sẽ thành X đồng với xác suất


                                                     1
                                        3, 𝑣ớ𝑖 𝑥á𝑐 𝑠𝑢ấ𝑡
                                  𝑋=                 2
                                                     1
                                     0, 𝑣ớ𝑖 𝑥á𝑐 𝑠𝑢ấ𝑡
                                                     2
    Giả sử người chơi luôn đầu tư toàn bộ tài sản ở mỗi lần chơi, tài sản Sn sau n lần
    chơi sẽ là 𝑆 = ∏ 𝑋 .
    a) Tìm EX và ESn
    b) Chứng minh rằng Sn0 theo xác suất (tức là với 𝜀 > 0, 𝑃(𝑆 ≥ 𝜀) → 0 khi 𝑛 →
       ∞.
    c) Bây giờ người chơi quyết định không đầu tư toàn bộ ở mỗi lẫn chơi nữa mà
       chỉ đầu tư b phần và giữa phần còn lại bằng tiền mặt. Do đó hệ số tài sản sẽ
       là (1-b+bX), và tài sản sau n lần chơi

                                  𝑆 =      (1 − 𝑏 + 𝑏𝑋 )

         Tìm b* sao cho cực đại hóa tốc độ tăng tài sản.
    d) Với sự lựa chọn b như trên, tìm lim 𝑙𝑛𝑆
                                           →

    Bài 8.7. Quân bài
    Một bộ bài tú lơ khơ chứa 26 quân đỏ và 26 quân đen được tráo và rút ra lần
lượt từng quân một. Giả sử Xi là màu của quân thứ i.
    a)   Xác định H(X1).
    b)   Xác định H(X2).
    c)   𝐻(𝑋 |𝑋 , … , 𝑋 ) tăng hay giảm?
    d)   Xác định 𝐻(𝑋 , 𝑋 , … , 𝑋 ).
    Bài 8.8. Lotto
     Trong bài này ta sẽ tìm hiểu một mô hình đơn giản hóa của trò chơi xổ số Lotto.
Giả sử người chơi được yêu cầu trả 1 đô la để được chơi và được yêu cầu chọn một
số trong khoảng 1 đến 8. Vào cuối ngày, ủy ban xổ số chọn ngẫu nhiên một số thuộc
khoảng đó theo phân phối đều. Số tiền góp (jackpot - toàn bộ tiền chơi trong ngày
đó) được chia đều cho những người chơi cùng chọn đúng số mà ủy ban chọn. Ví dụ
nếu hôm nay có 100 người chơi, 10 người trong số đó chọn số 2 và đó cũng là số
được ủy ban xổ số chọn ra cuối ngày. Khi đó mỗi người thắng cuộc (trong 10 người)
sẽ được nhận 10 đô la, những người chơi còn lại (90 người) không nhận được gì cả.
    Nói chung người chơi không chọn số theo phân phối đều. Chẳng hạn như các số
3 và 7 được coi là may mắn và hay được chọn hơn là 4 hay 8. Giả sử tỉ lệ người chọn


                                                                                  147
số 1, 2, …, 8 lần lượt là (𝑓 , 𝑓 , … , 𝑓 ), và cũng giả sử có n người chơi mỗi ngày. Cũng
giả sử thêm rằng n là đủ lớn để sự lựa chọn của một người chơi riêng lẻ không thay
đổi tỉ lệ người đánh bất cứ con số nào.
    a) Xác định chiến lược tối ưu để chia tiền của bạn cho các vé số khác nhau sao
       cho cực đại tỉ lệ tăng tài sản dài hạn.
    b) Tỉ lệ tăng tối ưu bạn có thể đạt được trong trò chơi này là bao nhiêu?
    c) Nếu (𝑓 , 𝑓 , … , 𝑓 ) = ( , , , , , , , ) và bạn bắt đầu với 1 đô la, cần bao
        nhiêu thời gian để bạn trở thành triệu phú?
    Bài 8.9. Đua ngựa với tỉ lệ cược bán công bằng (subfair odds)
    Nếu tỉ lệ đặt cược là tồi (vì tracktake – tiền khấu trừ từ mỗi trò đánh cá cho thuế
và track revenue), người chơi có thể muốn giữ tiền trong ví anh ta. Giả sử b(0) là
lượng tiền trong ví và b(1), b(2), …, b(m) là lượng đặt cược vào các con ngựa 1, 2, …,
m, với các tỉ lệ đặt cược o(1), o(2), …, o(m) và các xác suất thắng p(1), p(2), …, p(m). Do
đó tài sản kết quả là S(x) = b(0) + b(x)o(x), với xác suất p(x), x = 1, 2, …, m.
    a) Tìm b* cực đại hóa 𝐸 log 𝑆 nếu ∑       ()
                                                   < 1.
    b) Đánh giá (thảo luận) b* khi ∑          ()
                                                   > 1. (Sẽ không có một giải pháp closed-
        form trong trường hợp này, tuy nhiên có thể áp dụng điều kiện Kuhn-Tucker
        để tìm giải pháp dạng water-filling).
    Bài 8.10. Bài toán hai phong bì
     Có hai phong bì, một cái chứa b đô la, cái còn lại chứa 2b đô la. Giá trị b là chưa
biết. Chọn ngẫu nhiên một phong bì. Giả sử X là số tiền quan sát được trong phong
bì này, và Y là số tiền trong phong bì còn lại. Chọn chiến lược đổi phong bì với xác
suất p(x), trong đó 𝑝(𝑥) =        . Đặt Z là số tiền người chơi nhận được. Ta có:
                                                              1
                                             (𝑏, 2𝑏) 𝑣ớ𝑖 𝑥á𝑐 𝑠𝑢ấ𝑡
                               (𝑋, 𝑌) =                       2
                                                              1
                                         (2𝑏, 𝑏) 𝑣ớ𝑖 𝑥á𝑐 𝑠𝑢ấ𝑡
                                                              2
                                      𝑋 𝑣ớ𝑖 𝑥á𝑐 𝑠𝑢ấ𝑡 1 − 𝑝(𝑥)
                                𝑍=
                                        𝑌 𝑣ớ𝑖 𝑥á𝑐 𝑠𝑢ấ𝑡 𝑝(𝑥)
    a) Chứng minh 𝐸(𝑋) = 𝐸(𝑌) =          .
    b) Chứng minh 𝐸          = . Vì tỉ lệ kỳ vọng của lượng tiền trong phong bì còn lại
        là 5/4, có vẻ như người chơi luôn luôn nên chuyển. (Đây là nguồn gốc của
        nghịch lý chuyển.) Tuy nhiên, chú ý là 𝐸(𝑌) ≠ 𝐸(𝑋)𝐸(𝑌/𝑋). Do đó, mặc dù
        𝐸     > 1, nó không kéo theo 𝐸(𝑌) > 𝐸(𝑋).
    c) Giả sử J là chỉ số của phong bì chứa số tiền lớn nhất, và giả sử J’ là chỉ số của
       phong bì được chọn bởi thuật toán. Chỉ ra rằng với bất kỳ b nào, I(J;J’) > 0. Do
       đó, lượng tiền trong phong bì đầu tiên luôn chứa lượng thông tin nhất định
       về phong bì nên được chọn.

                                                                                       148
d) Chứng minh E(Z) > E(X). Do đó, bạn có thể làm tốt hơn cách luôn cố định
   hay luôn thay đổi. Thực tế, điều này là đúng cho bất kỳ hàm chuyển đơn
   điệu tăng p(x) nào. Bằng cách chuyển ngẫu nhiên theo p(x), bạn có xu hướng
   trade up hơn là trade down.




                                                                         149
Chương 9
MÃ DÒNG


     Trong chương 6, ta đã tìm hiểu về nén dữ liệu trong điều kiện khá lý tưởng là
biết trước phân phối nguồn. Tuy nhiên thực tế thì thường ta không biết dữ liệu cần
nén được sinh ra từ phân phối hay thậm chí họ phân phối nào (tất nhiên ta có thể
đưa ra các giả định về họ phân phối để có thể làm việc). Trong chương này chúng ta
sẽ tìm hiểu về hai phương pháp nén dữ liệu có thể dùng tốt trong trường hợp này.
     Mã hóa số học (arithmetic coding) là một phương pháp đẹp đẽ với tư tưởng nén dữ
liệu đòi hỏi phải xây dựng mô hình xác suất của nguồn dữ liệu. Cho đến năm 1999,
mã hóa số học là phương pháp nén file văn bản tốt nhất. Bên cạnh đó, một số hệ
thống nén ảnh hiệu quả cao nhất cũng sử dụng nó.
    Mã hóa Lempel–Ziv là một phương pháp nén “vạn năng” khác, được thiết kế với
tư tưởng không cần trực tiếp mô hình hóa phân phối xác suất của nguồn, nhưng lại
có thể nén được (tốt) bất kỳ nguồn dữ liệu nào. Người ta đã chứng minh được rằng
tính “vạn năng” đúng trong trường hợp khối lượng dữ liệu là vô hạn. Tất nhiên điều
kiện đó là không thực tế. Tuy nhiên, phương pháp nén Lempel–Ziv cũng được sử
dụng rộng rãi và thường hiệu quả (đánh giá qua thực nghiệm) trong thực tế.


9.1. TRÒ CHƠI DỰ ĐOÁN

    Sự dư thừa trong văn bản tiếng Anh là động lực cho hai phương pháp nén này.
Văn bản có sự dư thừa ở vài mức: ví dụ, chúng chứa kí tự ASCII với tần số khác
nhau, có những cặp kí tự liền kề xuất hiện nhiều hơn các cặp khác, và từ có thể được
dự đoán dựa vào ngữ cảnh và ngữ nghĩa của văn bản.
    Để minh họa sự dư thừa của tiếng Anh, và cách nén dữ liệu, chúng ta có thể
tưởng tượng trò chơi dự đoán trong đó người nói liên tục cố gắng dự đoán kí tự tiếp
theo trong file văn bản.
     Để đơn giản, giả định tập chữ cái chỉ bao gồm 26 chữ hoa A,B,C,…,Z và khoảng
trống ’_’. Trò chơi liên quan đến việc dự đoán từng kí tự, và câu trả lời cho dự đoán
chỉ là đúng hay sai. Sau khi dự đoán đúng, chúng ta lưu số lượng dự đoán đã thực
hiện để xác định kí tự đó, việc dự đoán kí tự tiếp theo diễn ra tương tự.
     Dưới đây là một ví dụ khi người chơi hỏi các kí tự trong câu để dự đoán cả câu,
số lượng dự đoán liệt kê dưới mỗi kí tự.




    Chú ý trong nhiều trường hợp, kí tự tiếp theo có thể dự đoán ngay chỉ trong một
lần đoán. Trong nhiều trường hợp khác, đặc biệt lúc dự đoán kí tự bắt đầu của từ,

                                                                                 150
cần nhiều lần hơn. Vậy trò chơi này và những kết quả của nó cung cấp cho chúng ta
điều gì? Đầu tiên, chúng cho thấy sự dư thừa của tiếng Anh từ cách nhìn của người
chơi. Thứ hai, trò chơi này có thể được sử dụng trong nén dữ liệu, cụ thể như sau:
    Chuỗi kí tự ‘1, 1, 1, 5, 1, . . . ’ bên trên đã thể hiện lại văn bản. Số lượng dự đoán
cho mỗi kí lớn nhất có thẻ là 27, vì vậy công việc của chúng là thực hiện ánh xạ lần
lượt 27 kí tự {A, B, C, . . . , Z, −} vào 27 số {1, 2, 3, . . . , 27}. Các số đó có thể xem như
bảng chữ cái mới. Tổng số kí tự sử dụng là không giảm, nhưng một vài kí hiệu được
sử dụng lặp lại nhiều hơn chuỗi ban đầu rất nhiều, ví dụ số 1 và 2, điều này sẽ giúp
việc nén chuỗi kí hiệu mới dễ dàng hơn.
     Làm thế nào để giải nén chuỗi số ‘1, 1, 1, 5, 1, . . . ’? Trong khi giải nén, chúng ta
không có chuỗi “THERE” ban đầu, chúng ta chỉ có chuỗi đã được mã hóa. Giả định
là chúng ta đã biết văn bản nguồn và đi đố người anh em sinh đôi của ta (người sẽ
hỏi những câu tương tự theo thứ tự tương tự như ta đã hỏi). Nếu người này có số dự
đoán bằng với số đưa ra, tức là anh ta vừa dự đoán đúng, chúng ta có thể nói “phải,
đúng rồi đấy”, và chuyển tới kí tự tiếp. Một cách khác, chúng ta chọn cửa sổ
(window) độ dài L, đây chính là số lượng kí tự của ngữ cảnh. Với mỗi xâu trong 27L
xâu có thể độ dài L, chúng ta hỏi 2 người chơi giống hệt nhau: "bạn dự đoán kí tự
tiếp theo là gì?”, và “nếu dự đoán đó sai, dự đoán mới là gì?”. Sau khi lập bảng câu
trả lời của 26 × 27L câu hỏi, chúng ta có thể sử dụng hai bản sao đó để mã hóa và giải
mã những vị trí hai người đoán giống nhau. Mô hình ngôn ngữ như vậy được gọi là
mô hình Markov bậc L.
   Rõ ràng rằng, những hệ thống này không khả thi để nén dữ liệu trong thực tế,
nhưng chúng đã minh họa cho một vài nguyên tắc mà chúng ta sẽ sử dụng ngay
dưới đây.


9.2. MÃ HÓA SỐ HỌC

    Chú ý là tuy thuật toán Huffman ở Chương 6 tối ưu về lý thuyết nhưng thực tế
áp dụng có một số hạn chế liên quan đến tính mềm dẻo của nó về phân phối xác
suất nguồn (phải được xác định từ đầu) và về vấn đề có thể có một bit vượt quá trên
mỗi ký hiệu khi mã hóa.
     Những khiếm khuyết đó được khắc phục bởi mã hóa số học (được sáng tạo bởi
Elias, Rissanen và Pasco, và đưa vào thực tế sau đó bởi Witten). Trong mã hóa số
học, mô hình hoá xác suất được tách biệt hẳn với thao tác mã hóa. Hệ thống này khá
tương tự như trò chơi dự đoán. Người chơi được thay thế bởi mô hình xác suất của
chuỗi đầu vào. Với mỗi kí tự ở chuỗi đầu vào, mô hình xác suất cung cấp một phân
phối dự đoán của tất cả các giá trị tiếp theo có thể, đương nhiên tổng các xác xuất này
bằng một. Nếu chúng ta chọn nguồn dữ liệu kiểu i.i.d với một vài phân phối biết
trước, thì phân phối dự đoán là như nhau mọi thời điểm, tuy vậy mã hóa số học có thể
dễ dàng tạo ra các mô hình phức tạp (các phân phối dự đoán khác nhau) mà phân


                                                                                           151
phối dự đoán phụ thuộc vào ngữ cảnh. Mô hình dự đoán thường được cài đặt bằng
chương trình máy tính.
    9.2.1. Phương pháp mã hóa số học
    Bộ mã hóa sử dụng các dự đoán của mô hình để tạo ra chuỗi nhị phân. Bộ giải
mã sử dụng mô hình y hệt (giống trong trò chơi dự đoán) để diễn giải xâu nhị phân.
     Giả sử bảng chữ cái nguồn là 𝒜 = {𝑎 , . . . , 𝑎 }, và ký hiệu thứ 𝐼 mang ý nghĩa
kết thúc xâu ký tự nguồn. Nguồn sẽ tạo ra chuỗi 𝑥 , 𝑥 , . . . , 𝑥 , . .. Nguồn không nhất
thiết tạo ra các kí hiệu độc lập và cùng phân phối. Chúng ta sẽ giả định chương trình
máy tính được cung cấp bộ mã gán phân phối xác suất dự đoán cho các 𝑎 là 𝑃(𝑥 =
𝑎 |𝑥 , . . . , 𝑥 ). Người nhận có chương trình giống hệt và tạo ra phân phối xác suất
dự đoán tương tự 𝑃(𝑥 = 𝑎 |𝑥 , . . . , 𝑥 ) tương tự.
    Chú ý từ phần này ta sử dụng ký hiệu khoảng. Khoảng [0.01, 0.10) là tất cả các
số thực giữa 0.01 và 0.1, bao gồm 0.01 nhưng không gồm 0.1. Một phép mã hóa nhị
phân định nghĩa các khoảng thực từ 0 tới 1. Ví dụ, xâu 01 được biến thành số thực
nhị phân 0.01…, tương ứng với khoảng [0.01, 0.10) trong nhị phân, và [0.25, 0.50)
trong hệ 10.




               Hình 9.1. Các chuỗi nhị phân định nghĩa các khoảng thực trong [0,1).

     Xâu dài hơn 01101 tương ứng với khoảng [0.01101, 0.01110). Bởi vì 01101 có 01
là tiền tố, khoảng mới (chứa số 01101) là khoảng con của khoảng [0.01, 0.10). Một
file nhị phân một megabyte(2 bit) được dành cho các số thập phân có 2 triệu chữ
số sau phần thập phân, bởi mỗi byte chuyển đổi ít nhất thành 2 số thập phân.
    Bây giờ chúng ta có thể chia khoảng [0,1) thành 𝐼 khoảng với độ dài bằng xác
suất 𝑃(𝑥 = 𝑎 ) như trong Hình 9.2.




                                                                                      152
            Hình 9.2. Một mô hình xác xuất định nghĩa các khoảng thực bên trong [0,1).

      Chúng ta có thể lấy mỗi khoảng 𝑎 và chia nó thành các khoảng gọi là 𝑎 𝑎 , 𝑎 𝑎 ,
..., 𝑎 𝑎 , mà độ cao của khoảng tỉ lệ thuận với 𝑃(𝑥 = 𝑎 |𝑥 = 𝑎 ). Thật vậy, độ dài
của khoảng 𝑎 𝑎 chính là xác suất phụ thuộc:
                    𝑃(𝑥 = 𝑎 , 𝑥 = 𝑎 ) = 𝑃(𝑥 = 𝑎 )𝑃(𝑥 = 𝑎 |𝑥 = 𝑎 ).
     Lặp lại thủ tục này, khoảng [0, 1) có thể được chia thành dãy các khoảng ứng với
tất cả các xâu chiều dài hữu hạn 𝑥 𝑥 . . . 𝑥 có thể có, như vậy chiều dài của khoảng
bằng xác suất của chuỗi theo mô hình của ta.


             𝑢 = 0.0
             𝑣 = 1.0
             𝑝 = 𝑣−𝑢
             for 𝑛 = 1 to 𝑁 {
                   Tính toán xác suất cộng dồn của 𝑄 và 𝑅
                        𝑣 = 𝑢 + 𝑝𝑅 (𝑥 |𝑥 , … , 𝑥            )
                        𝑢 = 𝑢 + 𝑝𝑄 (𝑥 |𝑥 , … , 𝑥            )
             }

                     Hình 9.3. Thuật toán tìm khoảng [𝒖, 𝒗) cho xâu 𝒙𝟏 𝒙𝟐 . . . 𝒙𝑵

    Công thức mô tả mã hóa số học
      Tiến trình mô tả trong 9.2 có thể được viết rõ ràng như sau. Các khoảng được
định nghĩa bằng các xác suất cộng dồn cao và thấp.

                   𝑄 (𝑎 |𝑥 , … , 𝑥       ) ≡         𝑃(𝑥 = 𝑎 |𝑥 , … , 𝑥          )


                   𝑅 (𝑎 |𝑥 , … , 𝑥       ) ≡         𝑃(𝑥 = 𝑎 |𝑥 , … , 𝑥          )


                                                                                         153
    Khi xử lý kí hiệu thứ 𝑛, chúng ta chia nhỏ khoảng thứ 𝑛 − 1 tại các điểm định
nghĩa bởi 𝑄 và 𝑅 . Ví dụ, bắt đầu với kí hiệu đầu tiên, các khoảng ‘𝑎 ’, ‘𝑎 ’ và ‘𝑎 ’ là:
                            𝑎 ↔ [𝑄 (𝑎 ), 𝑅 (𝑎 )) = [0, 𝑃(𝑥 = 𝑎 )),
                  𝑎 ↔ [𝑄 (𝑎 ), 𝑅 (𝑎 )) = [𝑃(𝑥 = 𝑎 ), 𝑃(𝑥 = 𝑎 ) + 𝑃(𝑥 = 𝑎 )) ,
                  𝑎 ↔ [𝑄 (𝑎 ), 𝑅 (𝑎 )) = [𝑃(𝑥 = 𝑎 )+. . . +𝑃(𝑥 = 𝑎     ), 1.0) .
    Để mã hóa xâu 𝑥 𝑥 … 𝑥 , chúng ta xác định khoảng tương ứng của 𝑥 𝑥 … 𝑥 , và
chọn một xâu nhị phân mà khoảng của nó nằm trong khoảng vừa xác định. Việc mã
hóa này được thực hiện tức thời (on the fly) như trong ví dụ dưới đây.


      9.2.2. Ví dụ về nén các trạng thái khi tung đồng xu cong.
   Tưởng tượng rằng chúng ta có một đồng xu cong có 2 mặt là a, b và một khả
năng nữa là kí hiệu kết thúc file. Vì đồng xu cong nên xác suất a và b là không bằng
nhau và không biết trước.
      a) Mã hóa
    Giả sử xâu nguồn là ‘𝑏𝑏𝑏𝑎□’ (nghĩa là đồng xu được tung 5 lần, ba lần đầu là
mặt b, lần thứ tư là mặt a, lần thứ năm là ký hiệu kết thúc). Ta duyệt qua từng ký tự
của xâu và tính phân phối xác suất có điều kiện của ký tự kế tiếp với điều kiện xâu
hiện tại. Giả sử các xác suất đó là:


        Ngữ cảnh
                              Xác suất của ký tự tiếp theo
        (dãy hiện có)
                             𝑃(𝑎) = 0.425        𝑃(𝑏) = 0.425          𝑃(□) = 0.15
 b                          𝑃(𝑎|𝑏) = 0.28        𝑃(𝑏|𝑏) = 0.57        𝑃(□|𝑏) = 0.15
 bb                         𝑃(𝑎|𝑏𝑏) = 0.21      𝑃(𝑏|𝑏𝑏) = 0.64        𝑃(□|𝑏𝑏) = 0.15
 bbb                       𝑃(𝑎|𝑏𝑏𝑏) = 0.17      𝑃(𝑏|𝑏𝑏𝑏) = 0.68      𝑃(□|𝑏𝑏𝑏) = 0.15
 bbba                     𝑃(𝑎|𝑏𝑏𝑏𝑎) = 0.28     𝑃(𝑏|𝑏𝑏𝑏𝑎) = 0.57      𝑃(□|𝑏𝑏𝑏𝑎) = 0.15




                                                                                      154
                    Hình 9.4. Mô tả quá trình mã hóa số học chuỗi bbba□.




     Khi kí tự đầu tiên ‘b’ được quan sát, bộ mã hóa biết rằng chuỗi mã sẽ bắt đầu
bằng '01 ', '10', hay '11 ', nhưng không biết chính xác là cái nào. Bộ mã hoá không
chọn cái nào, mà xét kí tự tiếp theo là b. Khoảng ‘bb’ nằm trọn trong khoảng ‘1’, do
đó bộ mã hóa xác định được kí hiệu đầu tiên là ‘1’ và viết ra kí hiệu này. Kí hiệu ‘b’
thứ ba thu hẹp khoảng một chút nhưng không đủ để khoảng đó nằm trọn trong
khoảng ‘10’. Chỉ khi đọc tiếp kí hiệu ‘a’ mới có thể mã hóa thêm một số bit nữa. Toàn
bộ khoảng ‘bbba’ nằm trọn trong khoảng ‘1001’, do đó bộ mã hóa sẽ thêm ‘001’ sau
‘1’ đã có. Cuối cùng khi gặp kí tự kết thúc □, chúng ta chấm dứt việc mã hóa.
Khoảng ‘bbbaa’ được phóng đại ở bên phải Hình 9.4. Cần để ý rằng khoảng
‘100111101’ được chứa toàn bộ bởi bbba□, nên việc mã hóa có thể được hoàn thành
bằng cách gắn thêm ‘11101’.


    b) Giải mã
     Bộ giải mã nhận được xâu ‘100111101’ và giải mã từng kí tự. Đầu tiên xác suất
𝑃(𝑎), 𝑃(𝑏), 𝑃(□) được tính nhờ sử dụng chương trình giống hệt như cái bộ mã hóa
sử dụng và khoảng ‘a’, ‘b’, ‘□’ được tạo ra. Khi chuỗi hai bit đầu tiên ‘10’ được xem
xét chắc chắn kí tự đầu tiên là ‘b’ bởi vì khoảng ‘10’ nằm trọn trong khoảng ‘b’. Bộ
giải mã sau đó sử dụng mô hình tính toán 𝑃(𝑎|𝑏), 𝑃(𝑏|𝑏), 𝑃(□|𝑏) và xây dựng ranh
giới cho các khoảng ‘ba’, ‘bb’ and ‘b□’. Tương tự, chúng ta giải mã kí tự b tiếp theo
nhờ đọc chuỗi ‘1001’, và kí tự ‘b’ thứ ba nhờ đọc chuỗi ‘100111’, v.v.. Cứ thế ta xác
định được chuỗi nguồn mà không có nhập nhằng nào. Bộ giải mã biết được thời
điểm dừng việc giải mã nhờ kí hiệu □ đánh dấu kết thúc chuỗi nguồn.

                                                                                  155
    c) Mô hình xác suất
    Kĩ thuật mã hóa số học không yêu cầu phân phối xác suất dự báo phải thỏa mãn
bất kì ràng buộc nào. Như vậy bất kì mô hình xác suất nào cũng có thể được sử
dụng. Tuy nhiên phân phối dự báo có thể được tạo ra một cách tự nhiên theo tiếp
cận Bayes. Bây giờ ta sẽ xem xem mô hình xác suất thích nghi đơn giản được sử
dụng trong ví dụ mã hóa trên được tạo ra theo tiếp cận Bayes như thế nào.




 Hình 9.5. Minh họa khoảng được định nghĩa bởi mô hình Bayes đơn giản. Kích thước của khoảng tỉ lệ
  thuận với xác xuất của chuỗi. Từ mô hình có thể thấy chuỗi với các kí hiệu thiên về a hoặc b có kích
                        thước lớn hơn chuỗi mà tỉ lệ a và b là như nhau(50:50).




     Bảng xác suất ở phần a) được tạo ra bằng cách sử dụng một mô hình đơn giản,
luôn luôn gán xác suất 0.15 cho kí hiệu □ và phân bổ phần còn lại (0.85) cho a và b.
Tỉ lệ phân chia được xác định theo quy tắc Laplace:
                                                           𝐹 +1
                                𝑝 (𝑎|𝑥 , … , 𝑥     )=
                                                         𝐹 +𝐹 +2
    ở đây 𝐹 (𝑥 , . . , 𝑥 ) và 𝐹 (𝑥 , . . , 𝑥 ) lần lượt là số lần mà kí hiệu a và kí hiệu b
xuất hiện trong xâu 𝑥 , . . , 𝑥 . Công thức này tương ứng với một mô hình Bayes
đơn giản được mô tả kỹ hơn dưới đây và đầy đủ hơn nữa trong chương 10.

                                                                                                   156
    Hình 9.5 hiển thị các khoảng tương ứng với một số chuỗi có độ dài không quá 5.
Chú ý là nếu chuỗi hiện thời chứa nhiều kí hiệu b thì xác suất của b tăng lên một
cách tương đối so với a, và ngược lại. Nhớ rằng khoảng càng lớn thì số bit để mã hóa
càng ít.
     Mô hình này được mô tả bằng các tham số 𝑝□ , 𝑝 , và 𝑝 . Một đồng xu cong có
nhãn 𝑎 và 𝑏 được tung 𝑙 lần, 𝑙 không biết trước. Xác suất mặt 𝑎 xuất hiện là 𝑝 và
𝑝 = 1 − 𝑝 , các tham số 𝑝 , 𝑝 là không được biết trước. Chuỗi nguồn 𝑠 = 𝑏𝑎𝑎𝑏𝑎□
chỉ ra rằng 𝑙 = 5 và chuỗi các biến cố sơ cấp là 𝑏𝑎𝑎𝑏𝑎. Không nên nhầm các xác suất
này với xác suất dự đoán trong ngữ cảnh cụ thể, ví dụ 𝑃(𝑎|𝑠 = 𝑏𝑏𝑎). Ta sử dụng một
số giả định sau:
       Giả sử độ dài xâu 𝑙 tuân theo phân phối xác suất mũ:
                                     𝑝(𝑙) = (1 − 𝑝□ ) 𝑝□
    Phân phối này tương ứng với việc giả định một xác suất hằng 𝑝□ cho ký hiệu kết
thúc □ tại mỗi kí tự.
     Giả sử các kí tự không kết thúc trong xâu được lựa chọn độc lập, ngẫu nhiên
theo phân phối xác suất 𝑝 = (𝑝 , 𝑝 ); xác suất 𝑝 được cố định trong toàn bộ chuỗi
với giá trị nằm trong khoảng từ 0 tới 1. Xác suất a là kí hiệu tiếp theo, với xác suất 𝑝
đã cho (nếu chúng ta biết trước nó), là (1 − 𝑝□ )𝑝 . Xác suất, với 𝑝 biết trước, mà một
chuỗi không kết thúc độ dài 𝐹 là một chuỗi 𝑠 chứa 𝐹 ký tự a và 𝐹 ký tự b là phân
phối Bernoulli:
                             𝑃(𝑠|𝑝 , 𝐹) = 𝑝       (1 − 𝑝 )
       Chúng ta giả định một phân phối tiên nghiệm đều cho 𝑝
                                 𝑝(𝑝 ) = 1, 𝑝 ∈ [0,1]
    Và định nghĩa 𝑝 = 1 − 𝑝 . Cũng có thể sử dụng các phân phối tiên nghiệm khác
cho 𝑝 , chẳng hạn phân phối Beta là lựa chọn tốt. Trong chương 10 ta sẽ tìm hiểu kỹ
hơn việc sử dụng phân phối Beta làm tiên nghiệm trong một mô hình Bayes gọi là
Beta-nhị thức.
    Khi đó xác suất của ký tự kế tiếp sẽ là qui tắc Laplace được nêu ở trên:
                                                    𝐹 +1
                            𝑝 (𝑎|𝑥 , … , 𝑥   )=
                                                  𝐹 +𝐹 +2
    9.2.3. Thảo luận
     Làm thế nào người ta có thể sử dụng mã hóa số học để nén một số tập tin riêng
biệt sử dụng bảng chữ cái nhị phân? Một khi đã xử lý đến kí tự □, bộ giải mã thiết
lập lại trạng thái ban đầu của nó. Nghĩa là nó sẽ không chuyển giao các số liệu thống
kê học được từ file đầu tiên sang file thứ hai. Tuy vậy, nếu chúng ta tin rằng có một
mối liên hệ giữa các file mà chúng ta sẽ nén, chúng ta có thể định nghĩa bảng chữ cái
khác đi, và sử dụng một kí hiệu kết thúc file thứ hai – kí hiệu này chỉ rõ file đã kết



                                                                                    157
thúc nhưng yêu cầu bộ giải mã và mã hóa tiếp tục sử dụng mô hình xác suất hiện
thời.
     Chú ý rằng, để xử lý một chuỗi 𝑁 kí tự chỉ cần tính 𝑁|𝒜| xác suất có điều kiện
(xác suất xuất hiện của mỗi kí hiệu trong bảng chữ cái trong mỗi ngữ cảnh thực sự
gặp phải), cũng giống như trò chơi dự đoán. Chi phí này có thể được so sánh với lựa
chọn sử dụng một mã Huffman để mã hóa theo khối lớn (nhằm giảm khả năng vượt
quá 1 bít mỗi ký hiệu), trong đó tất cả các chuỗi khối có thể xuất hiện phải được xem
xét và tính xác suất tương ứng.
     Cần chú ý tính linh hoạt của mã số học, nó có thể được sử dụng với bất kì bảng
chữ cái nguồn và bảng chữ cái đích nào. Kích thước của các bảng chữ cái này có thể
thay đổi trong quá trình sử dụng. Bên cạnh đó mã hóa số học có thể sử dụng với bất
kì phân phối xác suất nào, và phân phối đó có thể thay đổi hoàn toàn trong các ngữ
cảnh khác nhau. Hơn nữa, nếu chúng ta muốn các ký hiệu của bảng chữ cái mã hóa
(0 và 1) được sử dụng với tần số khác nhau, ta chỉ cần phân chia khoảng bên phải tỉ
lệ với các tần suất cần thiết.


9.3. CÁC ỨNG DỤNG MỞ RỘNG CỦA MÃ SỐ HỌC

     9.3.1. Tạo xâu ngẫu nhiên hiệu quả
     Bên cạnh chức năng chính là nén dữ liệu, mã hóa số học còn cho ta một cách để
sinh ra các xâu ngẫu nhiên. Tưởng tượng chúng ta cắm một chốt vào khoảng đơn vị
ở vị trí bất kì, khoảng đó đã được chia thành các khoảng con tỉ lệ với xác suất 𝑝 , xác
suất mà chốt của bạn sẽ nằm trong khoảng 𝑖 là 𝑝 .
     Vì vậy để tạo ra một xâu ngẫu nhiên từ một mô hình, toàn bộ cái chúng ta cần
làm là đưa các bit ngẫu nhiên vào một bộ giải mã số học của mô hình đó. Một chuỗi
bit ngẫu nhiên vô hạn tương ứng với lựa chọn một điểm ngẫu nhiên từ khoảng [0,1],
vì thế bộ giải mã sau đó lựa chọn một chuỗi ngẫu nhiên từ phân phối giả định.
Phương pháp dựa trên mã hóa số học này đảm bảo chỉ sử dụng một số lượng bit
ngẫu nhiên gần như nhỏ nhất có thể để tạo ra sự lựa chọn ngẫu nhiên. Vì số ngẫu
nhiên rất có giá trị5, hiệu quả phương pháp này mang lại là không nhỏ!
    Một ví dụ đơn giải của việc sử dụng kĩ thuật này là việc sinh ra các bit ngẫu
nhiên với phân phối không đều {p0,p1}
     9.3.2. Thiết bị nhập dữ liệu hiệu quả
    Khi chúng ta nhập văn bản vào trong máy tính, chúng ta có những cử chỉ sau:
gõ bàn phím, rê chuột, hoặc nhấp chuột. Một hệ thống nhập văn bản hiệu quả là một
hệ thống sử dụng với số lượng nhỏ nhất các cử động cần thiết.



5Thực tế là không ít tiền bạc đã được chi tiêu cho việc sinh ra các dãy bit ngẫu nhiên sử dụng trong
phần mềm và phần cứng. Số ngẫu nhiên là có giá trị kinh tế.

                                                                                                  158
     Viết có thể được xem như là một quá trình ngược của nén dữ liệu. Trong nén dữ
liệu mục đích là lập một ánh xạ từ một chuỗi đã cho vào chuỗi bit ngắn hơn. Trong
việc nhập văn bản chúng ta muốn một dãy ít các cử chỉ để tạo ra văn bản mong
muốn.
     Dựa vào việc đảo ngược một bộ mã hóa số học chúng ta có thể có được một thiết
bị nhập thông tin hiệu quả được điều khiển bằng cử chỉ (Ward và cộng sự, 2000).
Trong hệ thống này (gọi là Dasher) người sử dụng zoom vào khoảng đơn vị để định
vị khoảng tương ứng với chuỗi dự kiến, theo cách tương tự với Hình 9.4. Một mô
hình ngôn ngữ (giống như được sử dụng cho nén văn bản) điều khiển kích thước
của khoảng sao cho dễ dàng và nhanh chóng xác định được các xâu có thể. Sau một
giờ thực hành, một người dùng mới có thể viết với một ngón tay điều khiển Dasher
25 từ/phút, bằng một nửa tốc độ của người đánh máy sử dụng 10 ngón trên bàn
phím thông thường,. Thực nghiệm cho thấy tốc độ có thể đạt tới 25 từ/phút, không
cần dùng tay, mà dùng mắt điều khiển Dasher.


9.4. MÃ HÓA LEMPEL-ZIV

    Trong phần này ta sẽ tìm hiểu một phương pháp mã hoá thông dụng và có tính
chất tối ưu phổ dụng theo nghĩa tỉ lệ nén của nó tiệm cận đến tỉ lệ entropy của bất kì
nguồn ergodic dừng nào. Bên cạnh đó việc cài đặt phương pháp này cũng khá đơn
giản. Tên phương pháp (Lempel- Ziv) được đặt theo tên các tác giả của hai bài báo
gốc, vốn mô tả hai thuật toán cơ bản nhất của phương pháp. Các thuật toán này
cũng có thể được gọi là thuật toán nén từ điển thích nghi.
    Ý tưởng sử dụng từ điển cho nén đã có từ lâu, từ thời mà máy điện báo mới
được sử dụng chưa lâu. Vào thời đó, việc tính tiền là dựa trên số ký tự được sử dụng
trong các bức điện được gửi. Vì vậy để tiết kiệm, nhiều khách hàng (là công ty lớn)
đã tự đặt ra bảng mã, chứa các cụm từ hay được sử dụng, và sử dụng các từ mã
trong liên lạc bằng điện báo. Một ví dụ khác là về các bức điện chúc mừng, vốn phổ
biến ở Ấn Độ. Các thông điệp chúc mừng phổ biến như “Chúc năm mới vạn sự tốt
lành!”, “Chúc anh chị trăm năm hạnh phúc!” được đánh số. Khi một người muốn
gửi điện chúc thì chỉ cần chọn số, và số này sẽ được dùng để sinh ra lời chúc thực sự
ở đích.
    Mặc dù ý tưởng chung đã có từ lâu như vậy nhưng mãi về sau các phương pháp
nén dựa vào từ điển thích nghi mới được Lempel và Ziv khám phá. Trong bài báo
của mình, hai ông đã đưa ra hai phiên bản là: thuật toán Lempel-Ziv cửa sổ trượt
hay còn gọi là LZ77, và thuật toán Lempel-Ziv cấu trúc cây hay còn gọi là LZ78. Đôi
khi các thuật toán này còn được gọi là LZ1 và LZ2.
     Ý tưởng chính trong các thuật toán Lempel- Ziv là phân tích một xâu ký tự
thành các xâu con, và thay thế các xâu con xuất hiện lặp lại bằng một con trỏ chỉ tới
vị trí cuối cùng xâu con xuất hiện trước đấy. Sự khác nhau giữa hai thuật toán nằm ở
tập những vị trí trùng khớp cũng như độ dài trùng khớp mà thuật toán cho phép.

                                                                                  159
    Các thuật toán Lempel-Ziv được sử dụng rộng rãi để nén dữ liệu (ví dụ lệnh
gzip và compress trong các hệ thống Linux) và chúng khác với mã hóa số học về tư
tưởng, thể hiện ở chỗ không có sự tách biệt giữa mô hình và mã hóa, cũng như
không có mô hình hoá trực tiếp.
    9.4.1 Phương pháp Lempel-Ziv dạng cửa sổ trượt
   Thuật toán này, được miêu tả trong bài báo xuất bản năm 1977, mã hoá một xâu
bằng cách tìm đoạn trùng khớp dài nhất trong cửa sổ của các kí hiệu đã từng xuất
hiện và biểu diễn xâu bằng một con trỏ tới đoạn trùng khớp trong cửa sổ và độ dài
đoạn đó. Đã có nhiều biến thể của thuật toán cơ bản này, ở đây chúng ta sẽ tìm hiểu
thuật toán của Storer và Szymanski.

   Giả sử ta có một xâu 𝑥 , 𝑥 , … cần nén. Xâu này được sinh ra từ một nguồn với
bảng chữ cái hữu hạn. Một cách phân chia xâu 𝑥 𝑥 … ra thành các đoạn tách nhau
bởi dấu phảy được gọi là một phân tích (parse), ký hiệu là 𝑆. Giả sử 𝑊 là độ dài của
cửa sổ. Khi đó thuật toán có thể được miêu tả như sau:

      Giả sử chúng ta đã nén xâu tới ký hiệu thứ 𝑖 − 1.
      Để tìm đoạn tiếp theo
          o Tìm số 𝑘 lớn nhất sao cho với 𝑗 nào đó, 𝑖 − 1 − 𝑊 ≤ 𝑗 ≤ 𝑖 − 1, thì xâu
             độ dài 𝑘 bắt đầu từ vị trí 𝑥 bằng với xâu (cũng độ dài 𝑘) bắt đầu từ vị
             trí 𝑥 (nghĩa là 𝑥     =𝑥      với mọi 0 ≤ 𝑙 < 𝑘).
          o Đoạn tiếp theo (cụ thể là 𝑥 … 𝑥             ) khi đó có độ dài 𝑘 được biểu diễn
             bằng cặp (𝑃, 𝐿) với 𝑃 là vị trí bắt đầu lặp và L là độ dài đoạn lặp.
          o Nếu không tìm thấy đoạn lặp nào trong cửa sổ thì ký tự kế tiếp sẽ được
             gửi không nén. Và để phân biệt hai trường hợp có nén và không nén,
             ta cần dùng một bit biểu diễn thông tin đó (ký hiệu là F). Do vậy các
             đoạn sẽ thuộc một trong hai loại (𝐹, 𝑃, 𝐿) hoặc (𝐹, 𝐶), trong đó 𝐶 thể
             hiện một ký tự không nén.

   Chú ý là đoạn lặp có thể có độ dài 𝐿 lớn hơn độ động 𝑊 của cửa sổ. Về lý thuyết
thì độ dài này có thể là tùy ý, tuy nhiên trong thực tế độ dài cực đại của đoạn được
giới hạn nhỏ hơn một tham số định trước.

   Ví dụ: với cửa số có độ rộng 𝑊 = 4 và xâu cần mã là 𝐴𝐵𝐵𝐴𝐵𝐵𝐴𝐵𝐵𝐵𝐴𝐴𝐵𝐴𝐵𝐴.
Ban đầu, cửa sổ khởi tạo là rỗng. Khi đó xâu sẽ được phân tích thành:

                              𝐴, 𝐵, 𝐵, 𝐴𝐵𝐵𝐴𝐵𝐵, 𝐵𝐴, 𝐴, 𝐵𝐴, 𝐵𝐴

   và biểu diễn bởi dãy “con trỏ” như sau:

              (0, 𝐴), (0, 𝐵), (1,1,1), (1,3,6), (1,4,2), (1,1,1), (1,3,2), (1,2,2)

                                                                                       160
      trong đó 𝐹 = 0 nếu không có sự trùng khớp, và 𝐹 = 1 nếu có trùng khớp. Vị trí
trùng khớp được tìm ngược từ điểm cuối của cửa sổ. Hình dưới đây minh họa rõ
hơn quá trình mã xâu vào trên.




                              Hình 9.6. Áp dụng thuật toán LZ77

      Ta có thể hình dung các xâu con trong cửa sổ cộng với tập ký hiệu vào tạo
thành một từ điển. Thuật toán trên sẽ tìm “từ” dài nhất trong từ điển mà khớp với vị
trí từ ký hiện đang xét trở đi và dùng một “con trỏ” để mã hóa đoạn trùng khớp.
Thuật toán này là một phiên bản của LZ77, hầu hết các cài đặt thực tế của LZ77 như
𝑔𝑧𝑖𝑝 và 𝑝𝑘𝑧𝑖𝑝 là dựa trên phiên bản này.
      9.4.2 Phương pháp Lempel-Ziv cấu trúc cây
      Theo bài báo năm 1978, phương pháp này phân tích một xâu thành các đoạn,
trong đó mỗi đoạn là ngắn nhất và chưa từng xuất hiện trước đó. Thuật toán này có
thể được xem như xây dựng một từ điển biểu diễn dưới dạng cây, trong đó các nút
tương ứng với các đoạn đã được phân tích đến thời điểm hiện tại. Thuật toán khá
đơn giản để cài đặt và được sử dụng phổ biến như là một trong những thuật toán
chuẩn để nén file trên máy tính vì tốc độ và hiệu năng của nó. Nó cũng được sử
dụng nén dữ liệu trong các modem tốc độ cao.

      Ví dụ: Xét dãy nguồn ta đã sử dụng ở phần trên, 𝐴𝐵𝐵𝐴𝐵𝐵𝐴𝐵𝐵𝐵𝐴𝐴𝐵𝐴𝐵𝐴𝐴,
chúng ta phân tích nó thành 𝐴, 𝐵, 𝐵𝐴, 𝐵𝐵, 𝐴𝐵, 𝐵𝐵𝐴, 𝐴𝐵𝐴, 𝐵𝐴𝐴. Sau mỗi dấu phảy, ta
tìm trên xâu vào cho tới khi tìm ra dãy ngắn nhất mà chưa xuất hiện trước đó. Do
vậy, tiền tố của dãy ngắn nhất đó chắc chắn đã từng xuất hiện rồi. Xâu mới được mã
hóa bằng vị trí của tiền tố và giá trị của ký hiệu cuối cùng (phân biệt xâu mới với các
xâu      cũ).   Xâu    vào     của     ta    khi     đó      sẽ   được   mã     hóa     là
(0, 𝐴), (0, 𝐵), (2, 𝐴), (2, 𝐵), (1, 𝐵), (4, 𝐴), (5, 𝐴), (3, 𝐴). Xem hình ảnh minh hoạ dưới
đây:




                                                                                      161
                             Hình 9.7. Áp dụng thuật toán LZ78

   Gửi một kí tự không nén trong mỗi đoạn như trên cũng dẫn tới việc giảm hiệu
năng. Một cách để xử lý vấn đề này là coi ký tự cuối cùng của đoạn hiện thời là một
phần của đoạn kế tiếp. Biến thể này do Welch phát triển và trở thành cơ sở của hầu
hết các cài đặt thực tế của LZ78, chẳng hạn compress trên Unix, trong nén dữ liệu
modem, hay trong định dạng ảnh nén GIF.

9.5. SỰ TỐI ƯU CỦA MÃ LEMPEL-ZIV

9.5.1 Phương pháp cửa sổ trượt
   Wyner và Ziv đã chứng minh rằng thuật toán LZ77 là tiệm cận tối ưu. Cụ thể
hơn, họ chứng minh được là tỉ lệ nén hội tụ tới entropy của một nguồn ergodic.
Chứng minh này dựa vào bổ để đơn giản của Kac: độ dài trung bình của thời gian
bạn cần phải đợi để thấy một kí tự đặc biệt là nghịch đảo xác suất của kí tự đó. Do
vậy chúng ta thường thấy các xâu có xác suất cao xuất hiện trong cửa sổ và mã hoá
các xâu đó một cách hiệu quả. Các xâu mà chúng ta không tìm thấy trong cửa sổ có
xác suất thấp hơn, vì vậy, nói một cách gần đúng, các xâu này không ảnh hưởng kết
quả nén.

   Giả sử xâu vào dài vô hạn và trong quá trình nén/giải nén cả người gửi và người
nhận đều có thể truy cập đến phần đã được xử lý của xâu (phần này cũng dài vô
hạn). Một đoạn dài 𝑛 sẽ được biểu diễn bằng cách trỏ tới lần xuất hiện cuối cùng của
nó trong quá khứ.

   Giả sử ta có một quát trình ergodic dừng được định nghĩa cho thời gian từ −∞
tới +∞ và cả người mã hoá và người giải mã có thể truy cập tới … , 𝑋 𝑋 , phần dài
vô hạn đã được xử lý của dãy. Sau đó để mã hoá 𝑋 𝑋 … 𝑋           (một khối dài 𝑛), ta tìm
lần xuất hiện cuối cùng của dãy 𝑛 kí hiệu đó trong quá khứ. Giả sử

      𝑅 (𝑋 , 𝑋 , … , 𝑋   ) = max {𝑗 < 0 ∶ 𝑋 , 𝑋         …𝑋       = (𝑋 , … , 𝑋   )}




                                                                                     162
    Sau đó để biểu diễn 𝑋 , … , 𝑋       , chúng ta chỉ cần gửi 𝑅 tới người nhận. Khi đó
người nhận có thể tìm lại 𝑅           bit trong phần đã được giải mã và khôi phục
𝑋 ,…,𝑋       . Do đó, chi phí để mã hoá là chi phí biểu diễn 𝑅 . Ta sẽ chỉ ra rằng chi phí
này xấp xỉ log 𝑅 và 𝐸 log 𝑅 → Η(𝒳) một cách tiệm cận. Ta sẽ cần một số bổ đề sau.

    Bổ đề 9.5.1: Tồn tại mã tiền tố cho các số nguyên mà độ dài của từ mã ứng với số
nguyên 𝑘 là log 𝑘 + 2 log log 𝑘 + 𝑂(1).

    Bổ đề 9.5.2 (Kac): Giả sử … , 𝑈 , 𝑈 , 𝑈 , 𝑈 , … là một quá trình ergodic dừng trên
một bảng chữ cái có kích thước đếm được. Với 𝑢 bất kì sao cho 𝑝(𝑢) > 0 và với 𝑖 =
1,2 …, đặt

                   𝑄 (𝑖) = P {𝑈      = 𝑢; 𝑈 ≠ 𝑢 𝑣ớ𝑖 − 𝑖 < 𝑗 < 0|𝑈 = 𝑢}

    (nghĩa là 𝑄 (𝑖) là xác suất có điều kiện mà lần xuất hiện gần đây nhất của ký
hiệu 𝑢 là 𝑖, biết 𝑈 = 𝑢). Khi đó:

                                                                   1
                           𝐸(𝑅 (𝑈)|𝑋 = 𝑢) =            𝑖𝑄 (𝑖) =
                                                                  𝑝(𝑢)

    Vậy nên thời gian đợi kỳ vọng có điều kiện để lại thấy kí hiệu 𝑢 (bằng cách tìm
ngược lại từ chỉ số hiện tại – 0), là 1/𝑝(𝑢).

    Chú ý là thời gian lặp (recurrence) kỳ vọng đơn giản là:

                                                        1
                               𝐸𝑅 (𝑈) =         𝑝(𝑢)        =𝑚
                                                       𝑝(𝑢)

    Trong đó 𝑚 là kích thước bảng chữ cái.

    Hệ quả: Giả sử … , 𝑋 , 𝑋 , 𝑋 … là một quá trình ergodic dừng và 𝑅 (𝑋 , … , 𝑋               )
là chỉ số phần tử đầu tiên của lần xuất hiện cuối cùng của 𝑋 , … , 𝑋              trong quá khứ.
Khi đó:

                                                                          1
                    𝐸[𝑅 (𝑋 , … , 𝑋    )|(𝑋 , … , 𝑋     )=𝑥        ]=
                                                                       𝑝(𝑥    )

    Chứng minh: Ta định nghĩa một quá trình mới với 𝑈 = (𝑋 , 𝑋                    ,…,𝑋      ). U
cũng là quá trình ergodic dừng, theo bổ đề Kac thì thời gian lặp trung bình của U với
điều kiện 𝑈 = 𝑢 là 1/𝑝(𝑢). Chuyển đổi kết quả này qua quá trình X ta có hệ quả.

    Định lý 9.5.1. Giả sử 𝐿 (𝑋        ) = log 𝑅 + 2 log log 𝑅 + 𝑂(1) là độ dài mô tả cho
𝑋    trong thuật toán đơn giản trên, khi đó


                                                                                            163
                                    1
                                      𝐸𝐿 (𝑋        ) → 𝐻(𝒳),
                                    𝑛

    khi 𝑛 → ∞, trong đó 𝐻(𝒳) là tỉ lệ entropy của quá trình trình {𝑋 }.

    Chứng minh: Chúng ta sẽ chứng minh cận trên và cận dưới cho 𝐸𝐿 . Cận dưới
được suy ra trực tiếp từ định lý mã hóa nguồn (nghĩa là 𝐸𝐿 ≥ 𝑛𝐻 với bất kì mã tiền
tố nào). Với cận trên, trước hết ta chỉ ra rằng:

                                        1
                                     lım 𝐸 log 𝑅 ≤ 𝐻
                                        𝑛

    Để chứng minh cận của 𝐸 log 𝑅 chúng ta mở rộng kì vọng bằng điều kiện trên
giá trị của 𝑋    và áp dụng bất đẳng thức Jensen. Do đó:

            1           1
              𝐸 log 𝑅 =           𝑝( 𝑥       )𝐸[log 𝑅 (𝑋          ) |𝑋           =𝑥    ]
            𝑛           𝑛
                              1
                          ≤          𝑝(𝑥       ) log 𝐸[𝑅 (𝑋               )|𝑋     =𝑥       ]
                              𝑛
                              1                           1               1
                          =          𝑝(𝑥       ) log                  =     𝐻(𝑋       ) ↘ 𝐻(𝒳)
                              𝑛                        𝑝(𝑥        )       𝑛

    Hạng thức thứ hai trong công thức tính 𝐿 là log log 𝑅 , và ta muốn chứng minh
rằng:

                                  1
                                    𝐸[log log 𝑅 (𝑋         )] → 0
                                  𝑛

    Tiếp tục sử dụng bất đẳng thức Jensen, ta có:

                            1              1
                              𝐸 log log 𝑅 ≤ 𝐸[log 𝑅 (𝑋                      )]
                            𝑛              𝑛
                                             1
                                         ≤     log 𝐻(𝑋        )
                                             𝑛

    Với bất kì 𝜖 > 0, với 𝑛 đủ lớn, 𝐻(𝑋          ) < 𝑛(𝐻 + 𝜖), do đó log log 𝑅 <
  logn + log(𝐻 + 𝜖) → 0 . Định lý được chứng minh.

9.5.2 Phương pháp cấu trúc cây
    Trong phần này ta sẽ xem xét phương pháp Lempel-Ziv cấu trúc cây, trong đó
xâu vào được phân tích thành các đoạn, mỗi đoạn là xâu ngắn nhất mà chưa tồn tại
trước đó. Cách chứng minh ở đây sẽ khác hẳn với chứng minh LZ77 ở phần trên.
Bản chất của chứng minh này là một phép đếm giúp chỉ ra rằng số đoạn không thể

                                                                                                 164
quá lớn nếu tất cả đều phân biệt. Bên cạnh đó xác suất của dãy ký hiệu bất kì có thể
bị chặn bởi một hàm của số đoạn phân biệt trong quá trình phân tích xâu vào.

      Thuật toán được mô tả ở phần 9.4.2 yêu cầu hai lần duyệt qua xâu. Trong lần
thứ nhất, chúng ta phân tích xâu và tính số đoạn 𝑐(𝑛). Kế tiếp giá trị đó được sử
dụng để quyết định xem cần bao nhiêu bit [log 𝑐(𝑛)] để biểu diễn các con trỏ trong
thuật toán. Trong lần duyệt thứ hai, chúng ta tính các con trỏ và tạo ra xâu mã hoá.
Thuật toán có thể được sửa thành chỉ cần một lần duyệt xâu và sử dụng ít bit hơn
cho các con trỏ biểu diễn phần đầu của xâu vào. Sự thay đổi này không ảnh hưởng
tới tính hiệu quả tiệm cận của thuật toán. Ta sẽ chỉ ra rằng cũng giống như phiên
bản cửa số trượt của phương pháp Lempel- Ziv, thuật toán này (tiệm cận) đạt được
tỉ lệ entropy của nguồn ergodic chưa biết trước. Trước tiên, ta có định nghĩa sau đây
về phép phân tích xâu.

      Định nghĩa: Một phân tích 𝑆 của một xâu nhị phân 𝑥 𝑥 … 𝑥 là phép chia xâu đó
thành các đoạn, ngăn cách nhau bởi dấu phảy. Một phân tích phân biệt (hay không
trùng lặp) là phân tích mà không có hai đoạn nào là trùng nhau. Ví dụ, 0, 111, 1 là
một phân tích phân biệt của 01111, nhưng 0, 11, 11 là một phân tích không phân biệt.

      Thuật toán LZ78 cho ra output là một phân tích phân biệt. Giả sử 𝑐(𝑛) biểu diễn
số cụm trong phân tích LZ78 của dãy có độ dài 𝑛. Tất nhiên, 𝑐(𝑛) phụ thuộc vào
chuỗi 𝑋 . Dãy được nén (sau khi thực hiện thuật toán Lempel- Ziv) chứa một danh
sách 𝑐(𝑛) cặp số, mỗi cặp chứa một con trỏ tới lần xuất hiện trước đây của tiền tố của
đoạn và bit cuối cùng của đoạn đó. Mỗi con trỏ biểu diễn bởi log 𝑐(𝑛) bit và do đó
tổng độ dài của dãy nén là 𝑐(𝑛)[log 𝑐(𝑛) + 1] bit. Bây giờ chúng ta chỉ ra rằng
( )       ( )
                → H(𝒳) với một chuỗi ergodic dừng 𝑋 , 𝑋 , … , 𝑋 . Chứng minh này dựa
trên chứng minh của Wyner và Ziv về tính tiệm cận tối ưu của LZ78.

      Ý tưởng chính của chứng minh bao gồm:

      -   Bổ đề đầu tiên chỉ ra rằng số đoạn trong một phân tích không trùng lặp của
          một dãy nhỏ hơn 𝑛/ log 𝑛. Cơ sở để chứng minh là không có đủ đoạn ngắn
          không trùng lặp. Cận này đúng cho phân tích không trùng lặp bất kỳ, không
          nhất thiết phải là phân tích LZ78.
      -   Ý tưởng chính thứ hai là một cận của xác suất của một dãy dựa trên số đoạn
          phân biệt. Xét ví dụ về một dãy biến ngẫu nhiên độc lập và cùng phân phối
          𝑋 , 𝑋 , 𝑋 , 𝑋 có thể nhận bốn giá trị có thể có gồm {𝐴, 𝐵, 𝐶, 𝐷} với xác suất
          𝑝 , 𝑝 , 𝑝 , 𝑝 . Vì 𝑝 , +𝑝 + 𝑝 + 𝑝 = 1, tích 𝑝 𝑝 𝑝 𝑝 đạt cực đại khi các xác
          suất bằng nhau (nghĩa là giá trị xác suất cực đại của một dãy bốn ký hiệu khác


                                                                                    165
       nhau là 1/256). Mặt khác, nếu ta xét dãy 𝐴, 𝐵, 𝐴, 𝐵, xác suất của dãy này là cực
       đại bằng    nếu 𝑝 = 𝑝 = , 𝑝 = 𝑝 = 0. Một dãy dạng 𝐴, 𝐴, 𝐴, 𝐴 có thể có xác
       suất bằng 1. Các ví dụ này có chung một điểm cơ bản: dãy chứa nhiều ký hiệu
       (hay đoạn) khác nhau không thể có xác suất cao. Bất đẳng thức Ziv (Bổ đề
       9.5.5) là mở rộng của ý tưởng này cho trường hợp xích Markov.
   -   Vì độ dài mô tả của một dãy tăng theo 𝑐 log 𝑐, các dãy mà có ít đoạn phân biệt
       có thể được nén hiệu quả và tương ứng với các xâu mà có xác suất cao. Mặt
       khác, các xâu có nhiều đoạn phân biệt thì hiệu quả nén sẽ thấp hơn, tuy nhiên
       xác suất của các chuỗi đó không thể quá lớn theo bất đẳng thức Ziv. Do đó
       bất đẳng thức Ziv cho phép ta liên hệ logarit của xác suất của dãy với số đoạn
       trong phân tích của nó. Và kết quả này được dùng để chứng minh tính tối ưu
       tiệm cận của thuật toán Lempel-Ziv cấu trúc cây.

    Trước tiên ta cần chứng minh vài bổ đề cần sử dụng cho chứng minh định lý
chính. Bổ đề đầu tiên là về số đoạn có thể có trong một phân tích không trùng lặp
của chuỗi nhị phân dài 𝑛.

    Bổ đề 9.5.3. Số đoạn 𝑐(𝑛) trong một phân tích phân biệt của dãy nhị phân
𝑋 , 𝑋 , … , 𝑋 thoả mãn:
                                                    𝑛
                                     𝑐(𝑛) ≤
                                              (1 − 𝜖 ) log 𝑛
                          (     )
    Với 𝜖 = min 1,                  → 0, 𝑘ℎ𝑖 𝑛 → ∞.

    Bổ đề sau là về entropy cực đại.

    Bổ đề 9.5.4. Giả sử 𝑍 là một biến ngẫu nhiên nguyên không âm với giá trị trung
bình 𝜇. Khi đó entropy 𝐻(𝑍) bị chặn trên bởi:

                              𝐻(𝑍) ≤ (𝜇 + 1) log(𝜇 + 1) − 𝜇 log 𝜇

    Bây giờ ta sẽ tìm hiểu bổ đề về một cận trên đáng ngạc nhiên của xác suất của
một xâu dựa vào phân tích của xâu đó.

    Bổ đề 9.5.5. (Bất đẳng thức Ziv) Với bất kì phân tích không trùng lặp nào (đặc biệt
là phân tích LZ78) của xâu 𝑥 𝑥 … 𝑥 chúng ta có

                          log 𝑄 (𝑥 , 𝑥 , … , 𝑥 |𝑠 ) ≤ −        𝑐 log 𝑐
                                                          ,


    Chú ý là vế phải không phụ thuộc vào 𝑄 .


                                                                                    166
    Chứng minh:

    Ta viết

                          𝑄 (𝑥 , 𝑥 , … , 𝑥 |𝑠 ) = 𝑄 (𝑦 , 𝑦 , … , 𝑦 |𝑠 )


                                              =             𝑃(𝑦 |𝑠í )


    hay

                     log 𝑄 (𝑥 , 𝑥 , … , 𝑥 |𝑠 )

                                      =            log 𝑃(𝑦 |𝑠í )

                                      =                            log 𝑃(𝑦 |𝑠í )
                                          ,        :| |     ,
                                                                                   1
                                      =            𝑐 , log                            log 𝑃(𝑦 |𝑠í )
                                                                                   𝑐,
                                          ,                     :| |   ,

                                                                                      1
                                      ≤            𝑐 , log                              𝑃(𝑦 |𝑠í )
                                                                                     𝑐,
                                              ,                   :|   |       ,


    theo bất đẳng thức Jensen và tính lõm của hàm logarit.

    Do các 𝑦 phân biệt nên ta có ∑ :|               |   ,       𝑃(𝑦 |𝑠í) ≤ 1, suy ra

                                                                                            1
                            log 𝑄 (𝑥 , 𝑥 , … , 𝑥 |𝑠 ) ≤                            𝑐 log
                                                                                           𝑐
                                                                           ,


    Ta có điều phải chứng minh.

    Với các bổ đề trên, chúng ta có thể chứng minh định lý chính.

    Định lý 9.5.2. Với {𝑋 } là một quá trình ergodic dừng với tỉ lệ entropy 𝐻(𝒳) và
𝑐(𝑛) là số đoạn trong một phân tích không trùng lặp của một mẫu độ dài 𝑛 từ quá
trình này. Khi đó:

                                                  𝑐(𝑛) log 𝑐(𝑛)
                                 lim 𝑠𝑢𝑝                        ≤ 𝐻(𝒳)
                                  →                     𝑛

    với xác suất 1.

    Chứng minh: Bắt đầu với bất đẳng thức Ziv, được viết lại dưới dạng:



                                                                                                      167
                                                                     𝑐 𝑐
                         log 𝑄 (𝑥 , 𝑥 , … , 𝑥 |𝑠 ) ≤ −       𝑐 log
                                                                      𝑐
                                                         ,

                                                      𝑐      𝑐
                                = −𝑐 log 𝑐 − 𝑐           log
                                                       𝑐      𝑐

   Viết 𝜋 =     ta có:

                                                             𝑛
                                       𝜋 = 1,        𝑙𝜋 =
                                                             𝑐
                                   ,             ,


   Ta định nghĩa hai biến ngẫu nhiên 𝑈, 𝑉:

                                   P(𝑈 = 𝑙, 𝑉 = 𝑠) = 𝜋

   Do đó 𝐸𝑈 =    và log 𝑄 (𝑥 , 𝑥 , … , 𝑥 |𝑠 ) ≤ 𝑐 𝐻(𝑈, 𝑉) − 𝑐 log 𝑐

   hay

                   1                           𝑐       𝑐
                  − log 𝑄 (𝑥 , 𝑥 , … , 𝑥 |𝑠 ) ≥ log 𝑐 − 𝐻(𝑈, 𝑉)
                   𝑛                           𝑛       𝑛

   Ta có

                                 𝐻(𝑈, 𝑉) ≤ 𝐻(𝑈) + 𝐻(𝑉)

   và 𝐻(𝑉) ≤ log |𝒳| = 𝑘. Từ bổ đề 9.5.4 ta có
                                                 𝑛        𝑛     𝑛    𝑛
    𝐻(𝑈) ≤ (𝐸𝑈 + 1) log(𝐸𝑈 + 1) − (𝐸𝑈) log(𝐸𝑈) =   + 1 𝑙𝑜𝑔 + 1 − 𝑙𝑜𝑔
                                                 𝑐        𝑐     𝑐    𝑐
                      𝑛    𝑛          𝑐
                = 𝑙𝑜𝑔 +      + 1 𝑙𝑜𝑔 + 1
                      𝑐    𝑐          𝑛

   Suy ra
                             𝑐          𝑐   𝑐   𝑐
                               𝐻(𝑈, 𝑉) ≤ 𝑘 + log + 𝑜(1)
                             𝑛          𝑛   𝑛   𝑛

   Với một số 𝑛 cho trước, giá trị cực đại của log đạt được với giá trị cưc đại của
𝑐 (với ≤ ). Nhưng theo bổ đề 9.5.3, 𝑐 ≤              (1 + 𝑜(1)) do đó:

                                   𝑐    𝑛    log log 𝑛
                                     log ≤ 𝑂(          )
                                   𝑛    𝑐      log 𝑛

   Và vậy nên 𝐻(𝑈, 𝑉) → 0 𝑘ℎ𝑖 𝑛 → ∞. Suy ra:

                𝑐(𝑛) log 𝑐(𝑛)    1
                              ≤ − log 𝑄 (𝑥 , 𝑥 , … , 𝑥 |𝑠 ) + 𝜖 (𝑛)
                      𝑛          𝑛

                                                                                168
    ở đây 𝜖 (𝑛) → 0, 𝑘ℎ𝑖 𝑛 → ∞. Suy ra với xác suất 1,
              ( )     ( )
    lim sup                 ≤ lim − 𝑙𝑜𝑔 𝑄 𝑥 , 𝑥 , … , 𝑥 𝑋   (   )   → 𝐻(𝒳)
     →                         →

                                      = 𝐻(𝑋 |𝑋 , … , 𝑋 )

                                      → 𝐻(𝒳) khi 𝑘 → ∞.

    Bây giờ ta chứng minh mã hóa LZ78 là tiệm cận tối ưu.

    Định lý 9.5.3. Giả sử {𝑋 }          là một quá trình ergodic dừng nhị phân. Đặt
𝑙(𝑋 , 𝑋 , … , 𝑋 ) là độ dài từ mã LZ78 tương ứng với 𝑋 , 𝑋 , … , 𝑋 . Khi đó

                                       1
                                lim 𝑠𝑢𝑝 𝑙(𝑋 , 𝑋 , … , 𝑋 ) ≤ 𝐻(𝒳)
                                 →     𝑛

    với xác suất 1.

    Chứng minh: Chúng ta đã chỉ ra rằng 𝑙(𝑋 , 𝑋 , … , 𝑋 ) = 𝑐(𝑛) (log 𝑐(𝑛) + 1), trong
đó 𝑐(𝑛) là số đoạn trong phân tích LZ78 của xâu 𝑋 , 𝑋 , … , 𝑋 . Bổ đề 9.5.3 đã chỉ ra
rằng lim sup 𝑐(𝑛) /𝑛 = 0, kết hợp với định lý 9.5.2 trên:

                            𝑙(𝑋 , 𝑋 , … , 𝑋 )           𝑐(𝑛) log 𝑐(𝑛) 𝑐(𝑛)
               lim sup                        = lim sup              +
                                   𝑛                          𝑛        𝑛

                                      ≤ 𝐻(𝒳) với xác suất 1.

    Do vậy độ dài mỗi kí tự nguồn của mã hoá LZ78 (tiệm cận) không lớn hơn
entropy của nguồn. Chứng minh ở trên có một số đặc điểm thú vị đáng chú ý. Các
cận của số đoạn phân biệt và bất đẳng thức của Zip đúng với bất kì phân tích phân
biệt nào của xâu, chứ không chỉ đúng với cách phân tích đã dùng trong thuật toán
này. Chứng minh này có thể được mở rộng theo nhiều cách bằng cách thay đổi thuật
toán phân tích. Ví dụ có thể sử dụng nhiều cây mà phụ thuộc ngữ cảnh hoặc trạng
thái. Bất đẳng thức Ziv có tính hấp dẫn cao vì nó liên hệ xác suất ở vế này với một
hàm hoàn toàn tất định của một phân tích của một dãy ký hiệu ở vế kia.

    Mã hoá Lempel- Ziv là một ví dụ đơn giản của mã phổ dụng (mã mà không phụ
thuộc vào phân phối của nguồn). Cách mã hoá này có thể được sử dụng mà không
cần biết phân phối nguồn trong khi vẫn đạt được hiệu quả tiệm cận tới tỉ lệ entropy
của nguồn.


9.5. MINH HỌA THỰC TẾ


                                                                                  169
    Phần này cung cấp thông tin về một số phần mềm mà bạn có thể tìm hiểu và thử
nghiệm nhằm bổ trợ cho kiến thức đã học trong chương này. Bên cạnh đó một số kết
quả thực nghiệm cũng được đưa ra để so sánh các phương pháp với nhau.
     Trước tiên phải kể đến dasher.tcl6, một phương tiện được đưa thêm vào để giúp
bạn khám phá về mã số học, qua đó hiểu sâu hơn về loại mã này. Bên cạnh đó, một
gói phần mềm minh hoạ mã số học đã được Radford Neal viết bao gồm modul mã
hóa và giải mã, và người dùng có thể thêm các modul định nghĩa các mô hình xác
suất. Cần nhấn mạnh rằng không có một máy nén mã hóa số học cho tất cả các loại
dữ liệu, mỗi nguồn cần một mô hình riêng. Gói của Radford Neal bao gồm một mô
hình thích nghi đơn giản tương tự như mô hình Bayes đã được mô tả ở phần 9.2. Các
kết quả sử dụng mô hình Laplace này nên được xem như là chuẩn mực bởi vì nó là
mô hình xác xuất đơn giản nhất có thể - nó chỉ đơn giản giả định rằng các kí tự trong
tập tin là độc lập được sinh từ một biến ngẫu nhiên. Các tần suất {𝐹 } của các kí hiệu
{𝑎 } được biến đổi tỉ lệ và làm tròn khi các file đã được đọc sao cho toàn bộ các giá trị
này nằm trong khoảng giữa 1 và 256.
     DjVu được coi là một máy nén tốt nhất cho tài liệu chứa cả văn bản và hình ảnh.
Nó sử dụng một bộ mã hóa số học được thiết kế cẩn thận cho các bảng chữ cái nhị
phân được gọi là Z-coder, nhanh hơn nhiều so với phần mềm mã hóa số học được
trình bày phía trên. Một trong những thủ thuật được Z-coder sử dụng là: mô hình
thích nghi chỉ thỉnh thoảng được biến đổi (để tiết kiệm thời gian), với quyết định khi
nào thích nghi được điều khiển giả ngẫu nhiên bởi liệu bộ mã hóa số học phát ra
một bit hay không.
       Chuẩn nén ảnh nhị phân JBIG sử dụng mã hóa số học với một mô hình phụ
thuộc ngữ cảnh, thích nghi sử dụng một quy tắc giống như quy tắc Laplace. PPM là
phương pháp hàng đầu cho nén văn bản, và nó sử dụng mã hóa số học (Teahan,
1995).
    Có rất nhiều chương trình dựa trên Lempel-Ziv. gzip dựa trên phiên bản
Lempel Zip gọi là ‘LZ77’ (Ziv và Lempel 1977). compress dựa trên ‘LZW’ (Welch
1984). Theo kinh nghiệm của chúng tôi gzip là tốt nhất.
      bzip là một chương trình nén file sắp khối, sử dụng biến đổi Burrows Wheeler.
Phương pháp này không dựa trên mô hình xác suất, và nó chỉ làm việc tốt cho các
file lớn hơn vài nghìn kí tự. Nhưng trong thực tế nó là một cách nén rất hiệu quả cho
các file mà ngữ cảnh của kí tự giúp dự đoán chính xác kí tự đó.
       Nén file văn bản
     Bảng 9.3 đưa ra thời gian tính bằng giây và hiệu quả nén đạt được khi chương
trình này áp dụng trên 1 file Latex chứa một văn bản tiếng Anh với kích thước
20,942 byte.



6   http://www.inference.phy.cam.ac.uk/mackay/itprnn/softwareI.html

                                                                                     170
                     Bảng 9.3. So sánh các thuật toán nén áp dụng cho file văn bản


                                Thời gian                Kích cỡ nén                 Thời gian giải
        Phương pháp
                                nén / sec             (%age của 20942)                 nén/sec

 Mô hình Laplace                     0.28             129741 (61%)                       0.32
 gzip                                0.1              8177 (39%)                         0.01
 compress                            0.05             10816 (51%)                        0.05
 bzip                                                 7495 (36%)
 bzip2                                                7640 (36%)
 ppmz                                                 6800 (32%)


       Nén file thưa
      Thật thú vị, gzip không phải luôn luôn hiệu quả. Bảng 9.4 cung cấp các kết quả
 nén đạt được khi chương trình được áp dụng cho các file văn bản chứa 10 6 kí tự, mỗi
 kí tự đó là số 0 hoặc 1 với xác suất 0.99 và 0.01. Mô hình Laplace khá phù hợp với
 nguồn này và mã hóa số học chuẩn cho hiệu suất tốt, compress kém hơn một chút,
 gzip là tồi nhất. Một mô hình lý tưởng cho nguồn này sẽ nén file vào khoảng 106
 H2(0.01)/8 ~ 10100 byte. Máy nén sử dụng mô hình Laplace chỉ gần đạt hiệu suất này
 bởi vì nó được cài đặt dựa trên độ chính xác 8 bit. Máy nén ppmz là tốt nhất cho tất
 cả các trường hợp nhưng lại mất thời gian tính toán nhiều hơn
 Bảng 9.4. So sánh các thuật toán nén áp dụng cho một file ngẫu nhiên chứa 10 6 ký tự, 99% là 1 và 1% là
                                                  0


                                                       Kích cỡ nén
  Phương pháp            Thời gian nén / sec                                   Thời gian giải nén/sec
                                                     (%age của 20942)
Mô hình Laplace               0.45                      14143 (1.4%)                 0.57
gzip                          0.22                      20646 (2.1%)                 0.04
gzip --best+                  1.63                      15553 (1.6%)                 5
compress                      0.13                      14785 (1.5%)                 0.03
Bzip                          0.3                       10903 (1.09%)                0.17
bzip2                         0.19                      11260 (1.12%)                0.05
Ppmz                          533                       10447 (1.04%)                535


 BÀI TẬP



                                                                                                    171
    Bài 9.1. Mô tả một thuật toán mã hoá số học để mã các dãy bit ngẫu nhiên độ dài
N và trọng số K (ví dụ, K số 1 và N-K số 0). Ở đây N và K được cho trước. Với
trường hợp N=5 và K=2, hãy chỉ ra cụ thể các khoảng tương ứng với các xâu con
nguồn độ dài từ 1 đến 5.
    Bài 9.2. Mô tả một thuật toán mã hoá số học để sinh các xâu bit độ dài N ngẫu
nhiên với mật độ f (ví dụ mỗi bit bằng 1 với xác suất f). N là cho trước.
   Bài 9.3. Đưa ra ví dụ về các nguồn dữ liệu đơn giản, entropy thấp, mà thuật toán
Lempel-Ziv nén không tốt lắm.
    Bài 9.4. Nén xâu 000000000000100000000000 sử dụng thuật toán Lempel-Ziv cơ
bản ở trên.
   Bài 9.5. Giải mã xâu 00101011101100100100011010101000011 mà đã được nén
bằng thuật toán Lempel-Ziv cơ bản.
    Bài 9.6. Mã hóa số học
    Giả sử {𝑋 }    là một xích Markov nhị phân dừng với ma trận chuyển
                                           3   1
                                  𝑝 =      4   4
                                           1   3
                                           4   4
     Tính ba bit đầu tiên của 𝐹(𝑋 ) = 0. 𝐹 𝐹 … trong đó 𝑋   = 1010111 … Bao nhiêu
bit của 𝑋 được mô tả?
    Bài 9.7. Mã hóa số học
    Giả sử 𝑋 là xích Markov dừng nhị phân với ma trận chuyển
                                       1   2
                                       3   3
                                       2   1
                                       3   3
          a) Tìm 𝐹(01110) = 𝑃(. 𝑋 𝑋 … 𝑋 < .01110)
          b) Ta có thể biết chắc được bao nhiêu bit . 𝐹 𝐹 … nếu ta không biết 𝑋 =
             01110 tiếp tục thế nào?
    Bài 9.8. Lempel-Ziv
   Bạn hãy đưa ra phân tích và xâu mã của 00000011010100000110101 áp dụng
phương pháp LZ78.
    Bài 9.9. Mã hóa dãy hằng số
    Cho dãy hằng 𝑥 = 11111 …
    a) Đưa ra phân tích LZ78 cho dãy vào trên.
    b) Lý giải tại sao số bit mã hóa mỗi ký hiệu của dãy vào trên tiến tới không khi
       𝑛 → ∞.


                                                                                172
    Bài 9.10. Độ dài con trỏ trong LZ77
    Trong phiên bản thuật toán LZ77 do Storer và Szymanski đưa ra (mô tả trong
phần 9.4.1), một đoạn khớp ngắn có thể được biểu diễn bởi (𝐹, 𝑃, 𝐿) hoặc (𝐹, 𝐶). Giả
sử cửa sổ có độ dài 𝑊, và độ dài đoạn khớp cực đại là 𝑀.
    a) Cần bao nhiêu bit để biểu diễn 𝑃? Cần bao nhiêu bit để biểu diễn 𝐿?
    b) Giả sử 𝐶 (biểu diễn một ký tự) dài 8 bit. Nếu biểu diễn cả 𝑃 và 𝐿 dài hơn 8
       bit, sẽ tốt hơn nếu biểu diễn đoạn khớp chỉ có một ký tự đơn lẻ như một ký
       tự không nén thay vì như một đoạn khớp trong từ điển. Tìm đoạn khớp
       ngắn nhất (hàm của 𝑊 và 𝑀) mà ta nên biểu diễn như một đoạn khớp thay
       vì như một ký tự không nén.
    c) Đặt 𝑊 = 4096 và 𝑀 = 256. Tìm đoạn khớp ngắn nhất mà ta nên biểu diễn
       như một đoạn khớp chứ không phải là ký tự không nén.




                                                                                173
Chương 10

SUY LUẬN BAYES



       Suy luận thống kê là các suy luận được đưa ra bằng cách sử dụng dữ
liệu và một mô hình thống kê, chất keo để liên kết dữ liệu với nhau. Dữ liệu là
cái chúng ta có thể quan sát, hoặc thu thập được giá trị bằng thực nghiệm và
các thiết bị công nghệ. Trong suy luận thống kê, dữ liệu được dùng để cập
nhật hoặc suy luận ra xác suất của các giả thuyết. Có hai vấn đề chính, một là
suy diễn về tham số hay còn gọi là ước lượng về tham số, và hai là dự báo.
       Suy luận Bayes là suy luận thống kê dựa trên luật Bayes. Suy luận Bayes
sử dụng một ước lượng xác suất thể hiện mức độ tin tưởng vào một giả thuyết
trước khi quan sát được bằng chứng – dữ liệu, và tính toán một ước lượng xác
suất thể hiện mức độ tin tưởng vào giả thuyết đó sau khi đã quan sát được
bằng chứng. Dựa theo định lý Bayes, chúng ta có thể thấy suy luận Bayes có ba
thông tin:
           - Thông tin hậu nghiệm: cái chúng ta muốn biết
           - Thông tin tiền nghiệm: cái chúng ta đã biết
           - Thông tin likelihood (khả năng): cái dữ liệu cho chúng ta biết
       Chúng ta có thể phát biểu suy diễn Bayes theo ngôn ngữ hàng ngày như
sau: những gì chúng ta biết là tổng hợp những gì chúng ta đã biết cộng với
chứng cứ thực tế. Có thể nói rằng suy diễn Bayes thể hiện cách suy nghĩ rất
phổ biến của tất cả chúng ta: đó là chúng ta tiếp thu kiến thức theo kiểu tích
lũy. Cụ thể, giả sử một người đi khám bệnh, trước khi bệnh nhân được xét
nghiệm, người bác sĩ đã biết được khả năng bệnh nhân mắc bệnh như thế nào
(qua các thông tin về tỉ lệ hiện hành trong cộng đồng), sau khi có kết quả xét
nghiệm bác sĩ có thêm chứng cứ thực tế, và hai thông tin này giúp cho bác sĩ
đánh giá lại khả năng mắc bệnh của bệnh nhân.
       Do đó, 3 yếu tố trên thường được gọi là xác suất hậu nghiệm, xác suất
tiền nghiệm, và xác suất khả năng, có thể thể hiện qua công thức chung như
sau:
          Xác suất hậu nghiệm = Xác suất tiền nghiệm + Xác suất likelihood


11.1. GIỚI THIỆU
      Nhắc lại luật Bayes
                                 𝑝(𝑋 = 𝑥, 𝑌 = 𝑦)
                𝑝(𝑋 = 𝑥|𝑌 = 𝑦) =
                                    𝑝(𝑌 = 𝑦)
                                   𝑝(𝑋 = 𝑥)𝑝(𝑌 = 𝑦|𝑋 = 𝑥)
                               =
                                 ∑ 𝑝(𝑋 = 𝑥′)𝑝(𝑌 = 𝑦|𝑋 = 𝑥′)


                                                                                  174
        Ví dụ về chuẩn đoán y học:
        Giả sử bạn là một phụ nữ ở tuổi 40, bạn muốn làm xét nghiệm y học để
kiểm tra bệnh ung thư vú, xét nghiệm này gọi là mammogram. Nếu kết quả
test là dương tính, xác suất bạn bị ung thư là bao nhiêu? Tất nhiên xác suất đó
sẽ phụ thuộc vào độ tin cậy của xét nghiệm. Giả sử bác sĩ nói với bạn rằng xét
nghiệm có độ nhạy (sensitivity) là 80%, nghĩa là nếu bạn bị ung thư, kết quả
xét nghiệm sẽ là dương tính với xác suất 0.8. Nói cách khác
                                𝑝(𝑥 = 1|𝑦 = 1) = 0.8
        trong đó x = 1 là sự kiện mammogram là dương tính, và y = 1 là biến cố
bạn bị ung thư. Nhiều người kết luận ngay rằng khả năng 80% là họ bị ung
thư. Nhưng điều đó là sai! Lập luận đó đã bỏ qua xác suất tiên nghiệm (prior)
về bệnh ung thư, may mắn là khá thấp:
                                  𝑃(𝑦 = 1) = 0.004
        Bỏ qua xác suất tiên nghiệm này gọi là base rate fallacy. Ta cũng cần tính
đến thực tế là xét nghiệm dương tính sai (false positive) hay báo động giả
(false alarm). Không may là khả năng dương tính sai là khá cao (với công nghệ
hiện nay):
                                𝑝(𝑥 = 1|𝑦 = 0) = 0.1
        Kết hợp các xác suất trên sử dụng luật Bayes, ta có thể tính ra câu trả lời
đúng:
                                        𝑝(𝑥 = 1|𝑦 = 1)𝑝(𝑦 = 1)
       𝑝(𝑦 = 1|𝑥 = 1) =
                          𝑝(𝑥 = 1|𝑦 = 1)𝑝(𝑦 = 1) + 𝑝(𝑥 = 1|𝑦 = 0)𝑝(𝑦 = 0)
                                 0.8 × 0.004
                       =
                          0.8 × 0.004 + 0.1 × 0.996
                       = 0.031

      ở đây 𝑝(𝑦 = 0) = 1 − 𝑝(𝑦 = 1) = 0.996. Tóm lại, nếu kết quả xét nghiệm
là dương tính, xác suất bị ung thư của bạn chỉ là 3%.

       Ta có thể tổng quát hóa ví dụ về chẩn đoán y học trên để phân lớp các
vector thuộc tính x có kiểu bất kỳ như sau:
                                     𝑝(𝑦 = 𝑐|𝜃)𝑝(𝑥|𝑦 = 𝑐, 𝜃)
                  𝑝(𝑦 = 𝑐|𝑥, 𝜃) =
                                   ∑ 𝑝(𝑦 = 𝑐 |𝜃)𝑝(𝑥|𝑦 = 𝑐′, 𝜃)

       Hàm trên gọi là bộ phân lớp tạo sinh (generative classifier), vì nó mô tả
cách sinh ra dữ liệu từ phân phối xác suất có điều kiện p(x|y=c) và xác suất tiên
nghiệm p(y=c). Một lựa chọn khác là trực tiếp dựa trên phân phối hậu nghiệm
𝑝(𝑦 = 𝑐|𝑥); được biết đến như là bộ phân lớp phân biệt.
       Vì mẫu số là như nhau với mọi y cho nên ta có thể viết
                     𝑝(𝑦 = 𝑐|𝑥, 𝜃) ∝ 𝑝(𝑥|𝑦 = 𝑐, 𝜃)𝑝(𝑦 = 𝑐|𝜃)


11.2. Học khái niệm theo tiếp cận Bayes
      Xét ví dụ về việc học từ của trẻ em, chẳng hạn từ “mèo”. Giả sử cha mẹ

                                                                                      175
em chỉ ra các ví dụ dương (positive) của khái niệm này, bằng cách nói “nhìn
con mèo xinh chưa kìa!”, hay “chú ý con mèo”, v.v. Tuy nhiên, thường cha mẹ
sẽ không chỉ ra các ví dụ âm (negative), bằng cách nói “kia không phải là con
mèo”. Tất nhiên, các ví dụ âm có thể thu được qua quá trình học tích cực
(active learning), ví dụ em bé nói “a con mèo!”, và cha mẹ nói “nó là con chó
con ạ”. Gần đây, một số nghiên cứu về tâm lý học đã chỉ ra rằng con người có
thể học chỉ dựa vào ví dụ dương. Từ phần sau trở đi, ta mặc định nói ví dụ để
chỉ ví dụ dương.
        Ta có thể coi việc học nghĩa của từ như học khái niệm (concept
learning), tương đương với phân lớp nhị phân. Theo kiểu học này, f(x) = 1 nếu
x là một ví dụ của khái niệm C, và f(x) = 0 nếu ngược lại. Mục tiêu là học hàm
chỉ thị f, giúp xác định phần tử nào thuộc tập C.
        Để dễ hiểu, ta xét một ví dụ hết sức đơn giản về học khái niệm gọi là trò
chơi số học. Trò chơi diễn ra như sau: Người chơi A chọn một khái niệm số học
đơn giản C, chẳng hạn “số nguyên tố” hay “một số nguyên giữa 1 và 10”. Sau
đó A đưa cho B một dãy các ví dụ được chọn ngẫu nhiên 𝒟 = {𝑥 , … , 𝑥 } sinh
ra từ C, và hỏi B một số trường hợp mới 𝑥 thuộc C hay không, nói cách khác A
yêu cầu B phân loại 𝑥 .
        Để đơn giản, giả sử rằng tất cả các số đều là số nguyên và nằm trong
khoảng 1 đến 100. Bây giờ giả sử A nói với B “16”, một ví dụ (dương) về khái
niệm. B sẽ cho rằng các số nào khác thuộc khái niệm? 17? 6? 32? 99? Thật khó
có thể dự đoán về C với chỉ một ví dụ, vì vậy dự đoán của B sẽ khá mơ hồ! Có
thể B sẽ dự đoán các số tương tự với 16 theo một nghĩa nào đó. Nhưng tương
tự theo nghĩa nào? 17 là tương tự vì nó gần với 16, 6 là tương tự vì nó có chung
một chữ số, 32 là tương tự vì nó cũng là lũy thừa cơ số 2, nhưng 99 thì có vẻ
không tương tự lắm. Do đó một số con số là có khả năng cao hơn các số khác.
Ta có thể biểu diễn khả năng này bằng một phân phối xác suất, 𝑝(𝑥 |𝒟), cho
biết xác suất 𝑥 ∈ 𝐶 biết dữ liệu 𝒟 với bất kỳ 𝑥 ∈ {1, … ,100}. Hàm này gọi là
phân phối dự đoán hậu nghiệm. Hình 10.1 (phần trên cùng) biểu diễn phân
phối dự đoán có được bằng cách thực hiện thí nghiệm với sự tham gia của một
số người. Ta có thể thấy rằng họ đoán các con số tương tự với 16 theo rất nhiều
kiểu khác nhau.




                                                                                    176
                              Hình 10.1. Phân phối dự đoán thực nghiệm

        Bây giờ giả sử A nói với B là 8, 2, 64 cũng là các ví dụ thuộc khái niệm.
Khi đó B có thể đoán rằng khái niệm ẩn là “lũy thừa cơ số hai”. Đây là một ví
dụ của qui nạp (induction). Với giả thuyết này, phân phối dự đoán thực
nghiệm là khá đặc thù, và hầu hết xác suất tập trung ở các lũy thừa cơ số 2,
như chỉ ra trong Hình 10.1 (phần thứ ba). Nếu A nói với B rằng 𝒟 =
{16,23,19,20}, khi đó những người tham gia thí nghiệm sẽ có dự đoán khác,
như chỉ ra trong Hình 10.1 (phần dưới cùng).
        Làm thế nào bạn có thể giải thích hành vi này và mô phỏng nó sử dụng
máy tính? Giải pháp cổ điển cho qui nạp là giả sử ta có một không gian giả
thuyết của các khái niệm, ký hiệu là ℋ, chẳng hạn: số lẻ, số chẵn, tất cả các số
trong khoảng 1 đến 100, các lũy thừa cơ số hai, tất cả các số có đuôi là j (0 ≤ 𝑗 ≤
9), v.v. Không gian con của ℋ mà chỉ gồm các giả thuyết nhất quán với dữ liệu
𝒟 gọi là không gian giải thích7 (version space). Khi ta càng quan sát được nhiều
ví dụ, không gian giải thích thu hẹp và ta càng chắc chắn về khái niệm.
        Tuy nhiên, không gian giải thích không phải toàn bộ câu chuyện. Sau
khi thấy 𝒟 = {16}, có nhiều luật nhất quán; làm thế nào bạn kết hợp chúng để
dự đoán 𝑥 ∈ 𝐶 hay không? Cũng như vậy, sau khi biết được 𝒟 = {16,8,2,64},
tại sao bạn chọn luật “lũy thừa cơ số hai” mà không chọn “tất cả số chẵn”, hay
“lũy thừa cơ số hai trừ 32”, liệu tất cả chúng có nhất quán như nhau với chứng
cứ? Bây giờ ta sẽ giải thích nó sử dụng qui tắc suy diễn Bayes.

      11.2.1 Likelihood
      Ta cần giải thích tại sao ta chọn ℎ  = "𝑙ũ𝑦 𝑡ℎừ𝑎 𝑐ơ 𝑠ố ℎ𝑎𝑖" mà không
chọn, chẳng hạn, ℎ ẵ = "𝑠ố 𝑐ℎẵ𝑛" sau khi biết 𝒟 = {16,8,2,64} mặc dù cả hai
đều nhất quán với chứng cứ. Trực quan là ta muốn tránh trùng hợp ngẫu
nhiên đáng ngờ. Nếu khái niệm đúng là số chẵn, tại sao ta chỉ thấy các số là

7Dữ liệu là cái ta quan sát được nhưng chưa biết qui luật. Mỗi giả thuyết sẽ giải thích dữ liệu theo
một cách riêng.

                                                                                                   177
mũ của 2 trong tập 𝒟?
       Để hình thức hóa, giả sử rằng các ví dụ được lấy mẫu theo phân phối
đều từ mở rộng của một khái niệm. Mở rộng của một khái niệm là tập các số
thuộc nó. Chẳng hạn mở rộng của ℎ ẵ là {2,4, … ,98,100}; mở rộng của “các số
kết thúc bằng 9” là {9,19, … ,99}. Khi đó xác suất của việc lấy mẫu độc lập N
phần tử (có hoàn lại) từ h là
                                       1          1
                          𝑝(𝒟|ℎ) =            =
                                    𝑠𝑖𝑧𝑒(ℎ)      |ℎ|

      Phương trình quan trọng này gọi là nguyên lý kích thước, nghĩa là mô
hình ưu tiên giả thuyết đơn giản nhất (nhỏ nhất) nhất quán với dữ liệu.
Nguyên lý này được biết đến nhiều hơn với tên gọi dao cạo của Occam.
      Để xem cụ thể nó hoạt động thế nào, giả sử 𝒟 = {16}. Khi đó
𝑝(𝒟|ℎ ) = 1/6, vì chỉ có 6 số là lũy thừa cơ số hai nhỏ hơn 100, nhưng
𝑝(𝒟|ℎ ẵ ) = 1/50, vì có 50 số chẵn. Vì vậy likelihood mà ℎ = ℎ cao hơn ℎ =
ℎ   ẵ   . Với 𝒟 = {16,8,2,64}, likelihood của ℎ   là     = 7.7 × 10 , trong khi

đó likelihood của ℎ     ẵ   là    = 1.6 × 10 . Do đó tỉ lệ likelihood sẽ là 5000:1
thiên về ℎ . Tính toán này lượng hóa trực quan của chúng ta về việc sẽ là
trùng hợp ngẫu nhiên đáng ngờ nếu 𝒟 = {16,8,2,64} được sinh ra bởi ℎ ẵ .
       11.2.2 Tiên nghiệm
       Giả sử 𝒟 = {16,8,2,64}. Khi đó khái niệm h’ = “lũy thừa cơ số hai trừ 32”
có vẻ hợp lý hơn h = “lũy thừa cơ số hai” vì h’ không phải giải thích việc 32
không có trong tập ví dụ.
       Tuy nhiên, giả thuyết h’ = “lũy thừa cơ số hai trừ 32” có vẻ là khái niệm
“thiếu tự nhiên”. Ta có thể tính đến trực quan đó bằng cách gán xác suất tiên
nghiệm thấp cho các khái niệm thiếu tự nhiên. Tất nhiên, tiên nghiệm của
người này có thể khác của người khác. Khía cạnh chủ quan của lập luận Bayes
là nguồn gốc của nhiều tranh luận, vì nó nghĩa là, một đứa trẻ và một giáo sư
toán sẽ đi đến các câu trả lời khác nhau.
       Mặc dù tính chủ quan của tiên nghiệm là gây tranh cãi, thực tế nó khá
hữu dụng. Nếu người ta cho bạn biết rằng các con số được tạo ra từ các qui tắc
số học, khi đó đưa cho bạn 1200, 1500, 900, 1400, bạn sẽ đoán 400 là hợp lý hơn
1183. Nhưng nếu người ta nói với bạn các con số là thể hiện mức cholesterol
khỏe mạnh, bạn có thể sẽ cho là 400 ít hợp lý hơn 1183. Do đó ta có thể thấy
rằng tiên nghiệm là cơ chế cho phép kiến thức nền có thể được đưa vào phục
vụ giải quyết vấn đề. Không có nó, học nhanh (ví dụ từ các kích thước mẫu
nhỏ) là không thể.
       Hình 10.2 minh họa một tiên nghiệm đơn giản, trong đó 30 khái niệm số
học đơn giản được gán xác suất như nhau. Riêng hai khái niệm chẵn và lẻ có
xác suất cao hơn. Bên cạnh đó, hai khái niệm thiếu tự nhiên là “lũy thừa cơ số
2, cộng với 37” và “lũy thừa cơ số 2, trừ 32” được gán xác suất thấp.


                                                                                     178
                Hình 10.2. Tiên nghiệm, likelihood, và hậu nghiệm cho 𝓓 = {𝟏𝟔}.

      11.2.3 Hậu nghiệm
      Hậu nghiệm là likelihood nhân với tiên nghiệm. Ta có:
                               𝑝(𝒟|ℎ)𝑝(ℎ)
                    𝑝(ℎ|𝒟) =
                             ∑ ∈ℋ 𝑝(𝒟, ℎ )
                                 𝑝(ℎ)𝕀(𝒟 ∈ ℎ)/|ℎ|
                           =
                             ∑ ∈ℋ 𝑝(ℎ )𝕀(𝒟 ∈ ℎ )/|ℎ |

       Trong đó 𝕀(𝒟 ∈ ℎ) là 1 nếu và chỉ nếu toàn bộ dữ liệu là mở rộng của giả
thuyết h. Hình 10.2 thể hiện tiên nghiệm, likelihood, và hậu nghiệm sau khi
biết 𝒟 = {16}. Ta thấy rằng hậu nghiệm là kết hợp của tiên nghiệm và
likelihood. Với hầu hết khái niệm, tiên nghiệm là phân phối đều, vì thế hậu
nghiệm tỉ lệ với likelihood. Tuy nhiên các khái niệm thiếu tự nhiên, “lũy thừa
cơ số 2, cộng với 37” và “lũy thừa cơ số 2, trừ 32”, có hậu nghiệm thấp mặc dù

                                                                                  179
likelihood cao, do tiên nghiệm thấp. Ngược lại khái niệm số lẻ có hậu nghiệm
thấp, mặc dù tiên nghiệm cao, vì likelihood thấp.
       Hình 10.3 vẽ tiên nghiệm, likelihood, và hậu nghiệm sau khi quan sát
thấy 𝒟 = {16,8,2,64}. Ta có thể thấy likelihood tập trung vào khái niệm lũy
thừa cơ số hai, vì vậy khái niệm này có xác suất hậu nghiệm trội hẳn. Ví dụ
này cho ta thấy tầm quan trọng của tiên nghiệm, trái lại chắc “lũy thừa cơ số 2,
trừ 32” đã được chọn.




          Hình 10.3. Tiên nghiệm, likelihood, và hậu nghiệm sau khi thấy 𝓓 = {𝟏𝟔, 𝟖, 𝟐, 𝟔𝟒}

      Nói chung, khi có đủ dữ liệu, hậu nghiệm 𝑝(ℎ|𝒟) có đỉnh tại một khái
niệm gọi là ước lượng MAP:
                            𝑝(ℎ|𝒟) → 𝛿     (ℎ)

      trong đó ℎ        = 𝑎𝑟𝑔𝑚𝑎𝑥 𝑝(ℎ|𝒟) là mode hậu nghiệm, và 𝛿 là độ đo

                                                                                              180
Dirac định nghĩa bởi:
                                      1 𝑛ế𝑢 𝑥 ∈ 𝐴
                            𝛿 (𝐴) =
                                      0 𝑛ế𝑢 𝑥 ∉ 𝐴

      Chú ý là ước lượng MAP có thể được viết là:
        ℎ     = argmax 𝑝(𝒟|ℎ)𝑝(ℎ) = argmax[ log 𝑝(𝒟|ℎ) + log 𝑝(ℎ)]


      Vì likelihood phụ thuộc vào N theo hàm mũ, trong khi tiên nghiệm
không đổi, khi kích thước dữ liệu tăng, ước lượng MAP hội tụ tới ước lượng
hợp lý cực đại (MLE):
                  ℎ   = argmax 𝑝(𝒟|ℎ) = argmax log 𝑝(𝒟|ℎ)


       Nói cách khác, nếu dữ liệu đủ lớn, nó sẽ lấn át tiên nghiệm. Trong
trường hợp này, ước lượng MAP hội tụ tới MLE.
       Nếu giả thuyết đúng có trong không gian giả thuyết, các ước lượng
MLE và MAP sẽ hội tụ đến giả thuyết này. Do đó ta nói rằng suy diễn Bayes
(và ước lượng MLE) là các phương pháp (estimator) nhất quán. Ta cũng nói
rằng không gian giả thuyết là có thể nhận biết trong giới hạn, có nghĩa là ta có
thể tìm ra chân lý trong giới hạn của dữ liệu vô hạn. Nếu lớp giả thuyết của ta
không đủ giàu có để biểu diễn giả thuyết đúng, kết quả sẽ hội tụ đến giả
thuyết mà gần với giải thuyết đúng nhất có thể. Tuy nhiên, ta sẽ không đi sâu
vào chứng minh ở đây.

      11.2.4 Phân phối dự đoán hậu nghiệm
      Hậu nghiệm là trạng thái niềm tin bên trong của chúng ta vào thế giới.
Cách để kiểm tra xem niềm tin của chúng ta có cơ sở hay không là sử dụng
chúng để dự đoán khách quan các đại lượng quan sát được (đây là cơ sở của
phương pháp khoa học). Cụ thể hơn, phân phối dự đoán hậu nghiệm trong
trường hợp này là:
                     𝑝(𝑥 ∈ 𝐶|𝒟) =     𝑝(𝑦 = 1|𝑥, ℎ)𝑝(ℎ|𝒟)


       Công thức trên chỉ là trung bình có trọng số của mỗi giả thuyết đơn lẻ
và được gọi là trung bình mô hình Bayes (BMA). Hình 10.4 là một minh họa.
Các chấm ở đáy cho biết các dự đoán từ mỗi giả thuyết; đường cong dọc bên
phải cho biết trọng số của mỗi giả thuyết. Nếu ta nhân mỗi hàng với trọng số
của nó và cộng lại, ta được phân phối ở đỉnh.
       Khi ta có một tập dữ liệu nhỏ và (hoặc) nhập nhằng, hậu nghiệm 𝑝(ℎ|𝒟)
là mơ hồ, không xác định rõ phân phối dự đoán. Tuy nhiên, khi tập dữ liệu đủ
tốt, hậu nghiệm trở thành một hàm delta mà trung tâm là ước lượng MAP.
Trong trường hợp này, phân phối dự đoán trở thành:



                                                                                   181
                           𝑝(𝑥 ∈ 𝐶|𝒟) =        𝑝(𝑥|ℎ)𝛿 (ℎ)

                                        = 𝑝(𝑥|ℎ)




              Hình 10.4. Phân phối dự đoán hậu nghiệm ứng với dữ liệu   𝓓 = {𝟏𝟔}.

       Cách xấp xỉ phân phối dự đoán này được sử dụng rộng rãi vì nó đơn
giản. Tuy nhiên, nói chung cách này không thể hiện hết được sự không chắc
chắn của chúng ta, và do đó dự đoán của ta sẽ không “trơn” bằng khi sử dụng
BMA.
       Mặc dù phương pháp MAP là đơn giản, nó không thể giải thích sự
chuyển dịch dần dần từ lập luận dựa vào tương tự (với các hậu nghiệm không
chắc chắn) sang lập luận dựa vào luật (với các hậu nghiệm chắc chắn). Ví dụ,
giả sử ta quan sát 𝒟 = {16}. Nếu ta sử dụng tiên nghiệm đơn giản như trên, giả
thuyết nhất quán tối thiểu là “lũy thừa cơ số 4”, do đó chỉ 4, 16, và 64 là có xác
suất dự đoán khác không. Tất nhiên đây là một ví dụ của overfitting. Biết 𝒟 =
{16,8,2,64}, giả thuyết MAP là “lũy thừa cơ số hai”. Do đó phân phối dự đoán
plugin trở nên rộng hơn (theo nghĩa nhiều số có xác suất khác không hơn) khi
ta có thêm dữ liệu. Trái lại, theo tiếp cận Bayes, ta bắt đầu rộng và sau đó thu
hẹp dần khi học, dễ cảm nhận trực quan hơn. Cụ thể, giả sử 𝒟 = {16}, có nhiều
giả thuyết hỗ trợ hậu nghiệm đáng kể, vì thế phân phối dự đoán là rộng. Tuy
nhiên khi 𝒟 = {16,8,2,64}, hậu nghiệm tập trung xác suất của nó vào một giả
thuyết, vì thế phân phối dự đoán hẹp hơn. Tóm lại dự đoán theo tiếp cận
plugin và tiếp cận Bayes là khá khác nhau khi dữ liệu nhỏ, mặc dù chúng hội
tụ đến cùng kết quả khi ta có thêm dữ liệu.


                                                                                     182
        11.3 Mô hình beta-nhị thức
        Trò chơi đoán số liên quan đến việc tính toán (dự đoán) một phân phối
trên một tập các biến rời rạc sinh ra từ không gian giả thuyết hữu hạn, ℎ ∈ ℋ,
cho trước một chuỗi quan sát rời rạc. Ở ví dụ này, việc tính toán rất đơn giản,
ta chỉ cần cộng, nhân, và chia. Tuy nhiên, trong nhiều ứng dụng khác, các tham
số chưa biết là giá trị thực, vì vậy không gian giả thuyết sẽ là (tập con của) 𝑅 ,
trong đó K là số lượng tham số. Khi đó bài toán về mặt toán học sẽ phức tạp
hơn nhiều, do ta phải thay thế tổng bằng tích phân. Tuy nhiên các ý tưởng cơ
bản là không thay đổi.
        Trong phần này ta sẽ xem xét bài toán dự đoán xác suất xuất hiện mặt
ngửa của một đồng xu, đã biết kết quả một dãy phép thử của nó. Mặc dù ví dụ
này có vẻ quá đơn giản, tuy nhiên mô hình này lại tạo thành cơ sở của nhiều
phương pháp quan trọng khác như phân lớp Bayes, mô hình Markov, v.v. Về
mặt lịch sử nó cũng là quan trọng vì trong bài báo của Bayes năm 1763, ông ta
cũng phân tích ví dụ này. Sau đó các phân tích của Bayes được Pierre-Simon
Laplace khái quát hóa thành một qui tắc mà ngày nay ta biết đến với cái tên
“luật Bayes”.
        Mô hình mà ta xét trong phần này được mô tả bởi đồ thị sau, trong đó
mũi tên thể hiện sự phụ thuộc xác suất, hình tròn thể hiện biến ngẫu nhiên,
hình chữ nhật thể hiện sự lặp lại với số lần lặp được ghi ở góc phải dưới. Chú
ý 𝑎, 𝑏 được gọi là các siêu tham số hay tham số ở tầng cao trong mô hình Bayes
(nếu ta coi ở tầng thấp nhất chính là dữ liệu ta quan sát được).


                                                 Xi

       Cụ thể hơn, 𝑋 là biến ngẫu nhiên thể hiện dữ liệu mà ta quan sát được,
đó là kết quả của lần gieo thứ 𝑖 trong 𝑁 lần gieo. 𝜃 là tham số của phân phối
Bernoulli cho biết xác suất xuất hiện mặt ngửa. Tham số này cũng là ngẫu
nhiên và tuân theo phân phối Beta. Phân phối Beta có các tham số là 𝑎 và 𝑏
(không ngẫu nhiên nữa).
       Trong các phần sau đây ta sẽ áp dụng công thức quen thuộc đó là mô tả
likelihood và tiên nghiệm, sau đó dẫn ra hậu nghiệm và dự đoán hậu nghiệm.

       11.3.1 Likelihood
       Giả sử 𝑋 ~𝐵𝑒𝑟(𝜃), trong đó 𝑋 = 1 biểu diễn “ngửa”, 𝑋 = 0 biểu diễn
“sấp”, và 𝜃 ∈ [0,1] là tham số (xác suất xuất hiện mặt ngửa). Nếu dữ liệu là độc
lập và cùng phân phối, likelihood của nó là:
                              𝑝(𝒟|𝜃) = 𝜃 (1 − 𝜃)
       trong đó 𝑁 = ∑ 𝕀(𝑥 = 1) lần xuất hiện mặt ngửa và 𝑁 =
∑ 𝕀(𝑥 = 0) lần xuất hiện mặt sấp. Hai con số này được gọi là thống kê đủ
của dữ liệu vì chỉ cần biết 𝑁 , 𝑁 là ta có thể suy ra 𝜃.

                                                                                     183
       Hình thức hơn nữa, ta nói 𝑠(𝒟) là một thống kê đủ của dữ liệu 𝒟 nếu
𝑝(𝜃|𝒟) = 𝑝(𝜃|𝑠(𝒟)). Nếu ta sử dụng tiên nghiệm đều, phát biểu đó tương
đương với 𝑝(𝒟|𝜃) ∝ 𝑝(𝑠(𝒟)|𝜃). Hệ quả là, nếu ta có hai tập dữ liệu với cùng
thống kê đủ, ta sẽ suy ra cùng một giá trị của 𝜃.
      Giả sử 𝑁 = 𝑁 + 𝑁 , khi đó 𝑁 ~𝐵𝑖𝑛(𝑁, 𝜃), trong đó Bin biểu diễn phân
phối nhị thức, hàm phân phối là:
                                        𝑛
                         𝐵𝑖𝑛(𝑘|𝑛, 𝜃) =      𝜃 (1 − 𝜃)
                                        𝑘

       Vì    là một hằng số độc lập với 𝜃, likelihood của mô hình lấy mẫu nhị
thức sẽ bằng với likelihood của mô hình Bernoulli. Vì thế bấy kỳ suy diễn nào
về 𝜃 sẽ là như nhau trong các trường hợp: quan sát được tần suất, quan sát
được 𝒟 = {𝑁 , 𝑁 }, hay dãy phép thử 𝒟 = {𝑥 , 𝑥 , … , 𝑥 }.

       11.3.2 Tiên nghiệm
       Ta cần một phân phối tiên nghiệm mà xác định trên đoạn [0,1]. Sẽ thuận
tiện cho tính toán hơn nếu tiên nghiệm có cùng dạng với likelihood, cụ thể
trong trường hợp này:
                              𝑝(𝜃) ∝ 𝜃 (1 − 𝜃)
       Trong đó 𝛾 , 𝛾 là các tham số tiên nghiệm. Khi đó, việc tính toán hậu
nghiệm sẽ dễ dàng hơn bằng cách tổng các số mũ:
                              𝑝(𝜃) ∝ 𝑝(𝒟|𝜃)𝑝(𝜃)
                          = 𝜃 (1 − 𝜃) 𝜃 (1 − 𝜃)
                          =𝜃      (1 − 𝜃)

       Khi tiên nghiệm và hậu nghiệm có cùng dạng, ta nói rằng tiên nghiệm là
một tiên nghiệm liên hợp với likelihood tương ứng. Các tiên nghiệm liên hợp
hay được sử dụng bởi vì chúng giúp đơn giản hóa tính toán và dễ hiểu.
       Trong trường hợp phân phối Bernoulli, tiên nghiệm liên hợp của nó là
phân phối beta:
                           𝐵𝑒𝑡𝑎(𝜃|𝑎, 𝑏) ∝ 𝜃 (1 − 𝜃)
       Các tham số của tiên nghiệm gọi là siêu tham số. Ta có thể thiết lập
chúng sao cho thể hiện niềm tin của chúng ta. Ví dụ, để thể hiện niềm tin rằng
𝜃 có trung bình 0.7 và độ lệch chuẩn 0.2, ta đặt a = 2.975 và b = 1.275. Hoặc để
thể hiện niềm tin 𝜃 có trung bình 0.15 và nó nằm trong khoảng (0.05, 0.3) theo
xác suất, ta đặt a = 4.5 và b = 25.5.
       Nếu không biết gì về 𝜃, ngoại trừ việc nó thuộc đoạn [0, 1], ta có thể sử
dụng tiên nghiệm đều (khi đó thực chất tiên nghiệm không mang thông tin gì).
Phân phối đều có thể biểu diễn bằng phân phối beta với a = b = 1.




                                                                                   184
                                         (a)




                                         (b)

                   Hình 10.5. Minh họa một số mô hình Beta-nhị thức

      11.3.3 Hậu nghiệm
      Nếu ta nhân likelihood với tiên nghiệm beta, ta có hậu nghiệm sau:
      𝑝(𝜃|𝒟) ∝ 𝐵𝑖𝑛(𝑁 |𝜃, 𝑁 + 𝑁 )𝐵𝑒𝑡𝑎(𝜃|𝑎, 𝑏) ∝ 𝐵𝑒𝑡𝑎(𝜃|𝑁 + 𝑎, 𝑁 + 𝑏)

       Ta dễ thấy hậu nghiệm thu được bằng cách tính tổng của siêu tham số
tiên nghiệm và tần suất. Vì lý do này, các siêu tham số còn được gọi là tần suất
giả. Sức mạnh của tiên nghiệm, còn được gọi là kích thước mẫu hiệu quả của
tiên nghiệm, là tổng của tần suất giả, a+b; vai trò của nó tương tự với kích
thước tập dữ liệu 𝑁 + 𝑁 = 𝑁.
       Hình 10.5 biểu diễn hai ví dụ. Ở ví dụ thứ nhất (a), một tiên nghiệm yếu
Beta(2,2) được kết hợp với một hàm likelihood có chóp nhọn – ứng với kích
thước mẫu lớn – ta thấy rằng hậu nghiệm gần như giống hệt với likelihood.


                                                                                   185
Trong trường hợp này dữ liệu lấn át tiên nghiệm. Ở ví dụ thứ hai (b), một tiên
nghiệm mạnh Beta(5,2) được kết hợp với một hàm likelihood có chóp nhọn, ta
thấy rằng hậu nghiệm thể hiện sự “thỏa hiệp” giữa tiên nghiệm và likelihood.
       Giả sử ta có hai hay nhiều tập dữ liệu, khi đó việc tính toán tuần tự
(sequential) hay tính toán một lần (single batch) cho kết quả như nhau. Giả sử
hai tập dữ liệu của ta là 𝒟 và 𝒟 với các thống kê đủ 𝑁 , 𝑁 và 𝑁 , 𝑁 . Đặt
𝑁 = 𝑁 + 𝑁 và 𝑁 = 𝑁 + 𝑁 là các thống kê đủ của tập dữ liệu kết hợp. Nếu
chỉ tính một lần ta có:
                  𝑝(𝜃|𝒟 , 𝒟 ) ∝ 𝐵𝑖𝑛(𝑁 |𝜃, 𝑁 + 𝑁 )𝐵𝑒𝑡𝑎(𝜃|𝑎, 𝑏)
                              ∝ 𝐵𝑒𝑡𝑎(𝜃|𝑁 + 𝑎, 𝑁 + 𝑏)

      Còn tính tuần tự:
         𝑝(𝜃|𝒟 , 𝒟 ) ∝ 𝑝(𝒟 |𝜃)𝑝(𝜃|𝒟 )
                      ∝ 𝐵𝑖𝑛 𝑁 |𝜃, 𝑁 + 𝑁 𝐵𝑒𝑡𝑎(𝜃|𝑁 + 𝑎, 𝑁 + 𝑏)
                      ∝ 𝐵𝑒𝑡𝑎 𝜃|𝑁 + 𝑁 + 𝑎, 𝑁 + 𝑁 + 𝑏

      Đây là một tính chất mà làm cho suy diễn Bayes rất thích hợp cho tiếp
cận học trực tiếp (online learning), tuy nhiên ta không đi sâu vào chủ đề này ở
đây.
      11.3.3.1 Trung bình và mode của hậu nghiệm
      Ước lượng MAP là:
                                        𝑎+𝑁 −1
                              𝜃    =
                                      𝑎+𝑏+𝑁−2

     Nếu ta dùng tiên nghiệm đều, khi đó ước lượng MAP cho kết quả tương
đương với MLE:
                                       𝑁
                               𝜃    =
                                       𝑁

      Công thức trên ta có thể tính bằng một cách khác là áp dụng giải tích cơ
bản để cực đại hóa hàm likelihood.
      Trung bình hậu nghiệm là:
                                      𝑎+𝑁
                                𝜃̅ =
                                     𝑎+𝑏+𝑁

       Sự khác nhau này giữa mode và trung bình sẽ được khai thác về sau.
       Bây giờ ta chỉ ra rằng trung bình hậu nghiệm là kết hợp lồi của trung
bình tiên nghiệm và MLE, qua đó thể hiện rằng hậu nghiệm là thỏa hiệp giữa
cái mà ta tin trước đây và cái mà dữ liệu nói với chúng ta.
       Đặt 𝛼 = 𝑎 + 𝑏 là kích thước mẫu tương đương của tiên nghiệm, đại
lượng này điều khiển sức mạnh của nó, và đặt trung bình tiên nghiệm là 𝑚 =
𝑎/𝛼 . Khi đó trung bình hậu nghiệm là:
                                  𝛼 𝑚 +𝑁
                        𝐸[𝜃|𝒟] =
                                   𝑁+𝛼

                                                                                  186
                                   𝛼           𝑁 𝑁
                             =          𝑚 +
                                 𝑁+𝛼         𝑁+𝛼 𝑁
                               = 𝜆𝑚 + (1 − 𝜆)𝜃
      ở đây 𝜆 =        là tỉ lệ của tiên nghiệm trên kích thước mẫu tương
đương hậu nghiệm. Vì thế tiên nghiệm càng yếu, 𝜆 càng nhỏ, và do đó hậu
nghiệm càng gần với MLE. Tương tự, ta có thể chỉ ra rằng mode hậu nghiệm là
một kết hợp lồi của mode tiên nghiệm và MLE, và nó cũng hội tụ tới MLE.

       11.3.3.2 Phương sai của hậu nghiệm
       Trung bình và mode là các ước lượng điểm, tuy nhiên sẽ là hữu ích nếu
ta biết mức độ tin cậy của chúng. Phương sai của hậu nghiệm là một cách để
đánh giá điều đó. Phương sai của hậu nghiệm Beta là:
                                     (𝑎 + 𝑁 )(𝑏 + 𝑁 )
               𝑣𝑎𝑟[𝜃|𝒟] =
                          (𝑎 + 𝑁 + 𝑏 + 𝑁 ) (𝑎 + 𝑁 + 𝑏 + 𝑁 + 1)

       Ta có thể đơn giản hóa biểu thức phức tạp này trong trường hợp 𝑁 ≫
𝑎, 𝑏 và thu được:
                                    𝑁𝑁     𝜃(1 − 𝜃 )
                         𝑣𝑎𝑟[𝜃|𝒟] ≈      =
                                    𝑁𝑁𝑁       𝑁

      ở đây 𝜃 là MLE. Do đó “đường lỗi” (độ lệch chuẩn hậu nghiệm) trong
ước lượng của ta là:
                                           𝜃 (1 − 𝜃)
                        𝜎=    𝑣𝑎𝑟[𝜃|𝒟] ≈
                                               𝑁

       Ta thấy rằng độ không chắc chắn giảm với tốc độ 1/√𝑁. Chú ý là sự
không chắc chắn (phương sai) là cực đại khi 𝜃 = 0.5, và là cực tiểu khi 𝜃 gần
tới 0 hay 1. Điều này có nghĩa là việc một đồng xu là không cân đối và đồng
chất là đáng tin cậy hơn điều ngược lại.

      11.3.4 Phân phối dự đoán hậu nghiệm
      Cho đến giờ, ta đã tập trung vào việc suy diễn các tham số chưa biết.
Bây giờ ta chuyển sang việc dự đoán dữ liệu có thể quan sát trong tương lai.
      Xét việc dự đoán xác suất mặt ngửa là kết quả một phép thử tuân theo
hậu nghiệm 𝐵𝑒𝑡𝑎(𝑎, 𝑏) trong đó 𝑎 =        và 𝑏 =      . Ta có:

                    𝑝(𝑥 = 1|𝒟) =    𝑝(𝑥 = 1|𝜃)𝑝(𝜃|𝒟)𝑑𝜃
                                                        𝑎
                   =    𝜃𝐵𝑒𝑡𝑎(𝜃|𝑎, 𝑏)𝑑𝜃 = 𝐸[𝜃|𝒟] =
                                                       𝑎+𝑏

      Do đó ta thấy rằng trung bình của phân phối dự đoán hậu nghiệm
tương đương (trong trường hợp này) với đưa vào các tham số trung bình hậu

                                                                                187
nghiệm:
                           𝑝(𝑥 |𝒟) = 𝐵𝑒𝑟(𝑥|𝐸[𝜃|𝒟])

       11.3.4.1 Vấn đề overfitting và nghịch lý thiên nga đen
       Giả sử ta dùng kết quả của ước lượng MLE cho việc dự báo, 𝑝(𝑥 |𝒟) ≈
𝐵𝑒𝑟(𝑥|𝜃 ). Không may là xấp xỉ này có thể cho kết quả kém khi kích thước
mẫu nhỏ. Ví dụ, giả sử ta đã quan sát được 𝑁 = 3 mặt sấp. MLE khi đó sẽ cho
ta kết quả 𝜃 = = 0, vì ước lượng này cực đại xác suất của dữ liệu quan sát
được. Tuy nhiên, sử dụng ước lượng này, ta dự đoán rằng khả năng xuất hiện
mặt ngửa là không thể. Vấn đề này gọi là vấn đề tần suất bằng không hay vấn
đề dữ liệu thưa, và thường gặp khi ta tính tần suất trên những dữ liệu nhỏ.
Bạn có thể cho rằng trong kỷ nguyên của “big data” như hiện nay, vấn đề đó
không còn nhiều ý nghĩa. Nhưng chú ý rằng, thực tế cho thấy, một khi ta chia
dữ liệu dựa trên các tiêu chí nào đó – như số lần một người cụ thể tham gia
vào một hoạt động cụ thể – kích thước mẫu có thể nhỏ đi rất nhiều. Vấn đề này
sẽ phát sinh, ví dụ, khi cố gắng thực hiện việc giới thiệu có tính cá nhân hóa
các trang web. Do đó các phương pháp Bayes vẫn là hữu ích ngay trong kỷ
nguyên big data hiện nay.
       Vấn đề dữ liệu thưa tương tự với một vấn đề trong triết học gọi là
nghịch lý thiên nga đen. Nghịch lý này dựa trên nhận thức ở Phương Tây ngày
xưa rằng thiên nga chỉ có màu trắng. Trong ngữ cảnh đó, thiên nga đen là hình
ảnh ẩn dụ cho cái gì đó không thể tồn tại (Thiên nga đen được phát hiện ở Úc
bởi các nhà thám hiểm Châu Âu vào thế kỷ 17). Thuật ngữ “nghịch lý thiên
nga đen” lần đầu được sử dụng bởi nhà triết học Karl Popper. Nghịch lý này
được sử dụng để minh họa vấn đề qui nạp, cách để đưa ra kết luận chung về
tương lai từ các quan sát cụ thể về quá khứ.
       Bây giờ chúng ta thử đưa ra một giải pháp Bayes đơn giản cho vấn đề
này. Ta sẽ sử dụng tiên nghiệm đều, vì vậy 𝑎 = 𝑏 = 1. Trong trường hợp này,
sử dụng trung bình hậu nghiệm cho ta luật thành công Laplace:
                                            𝑁 +1
                            𝑝(𝑥 = 1|𝒟) =
                                         𝑁 +𝑁 +2

        Việc sử dụng tiên nghiệm đều cho kết quả tương đương với kỹ thuật
làm trơn cộng thêm một hay được dùng trong thực tế. Hoặc cũng có thể coi đây
là lý giải theo quan điểm Bayes cho kỹ thuật làm trơn đó.

      11.3.4.2 Dự đoán kết quả nhiều phép thử trong tương lai
      Giả sử ta muốn đoán số lần xuất hiện mặt ngửa x trong M phép thử
tương lai. Xác suất đó xác định bởi:

          𝑝(𝑥|𝒟, 𝑀) =    𝐵𝑖𝑛(𝑥|𝜃, 𝑀)𝐵𝑒𝑡𝑎(𝜃|𝑎, 𝑏)𝑑𝜃
                        𝑀   1
                    =                𝜃 (1 − 𝜃)    𝜃   (1 − 𝜃)   𝑑𝜃
                        𝑥 𝐵(𝑎, 𝑏)

                                                                                 188
         Tích phân trên là hệ số chuẩn hóa của phân phối 𝐵𝑒𝑡𝑎(𝑎 + 𝑥, 𝑀 − 𝑥 + 𝑏),
đo đó:

                𝜃 (1 − 𝜃)    𝜃    (1 − 𝜃)     𝑑𝜃 = 𝐵(𝑥 + 𝑎, 𝑀 − 𝑥 + 𝑏)


      Do vậy ta tìm ra rằng dự đoán hậu nghiệm cho bởi phân phối sau
(thường gọi là phân phối beta-binomial):
                                   𝑀 𝐵(𝑥 + 𝑎, 𝑀 − 𝑥 + 𝑏)
                   𝐵𝑏(𝑥|𝑎, 𝑏, 𝑀) =
                                   𝑥       𝐵(𝑎, 𝑏)

      Phân phối này có giá trị trung bình và phương sai như sau:
                                           𝑎
                                𝐸[𝑥] = 𝑀
                                         𝑎+𝑏
                                   𝑀 𝑎𝑏 (𝑎 + 𝑏 + 𝑀)
                       𝑣𝑎𝑟[𝑥] =
                                  (𝑎 + 𝑏) 𝑎 + 𝑏 + 1
      Nếu 𝑀 = 1, và do đó 𝑥 ∈ {0,1}, ta thấy rằng trung bình trở thành
𝔼[𝑥|𝒟] = 𝑝(𝑥 = 1|𝒟) =    , nhất quán với phương trình ở phần 11.3.4.
       Quá trình này được mô tả trong Hình 10.6 (a). Phân phối tiên nghiệm là
𝐵𝑒𝑡𝑎(2,2), thống kê (đủ) từ dữ liệu cho ta 𝑁 = 3, 𝑁 = 17. Phần (b) của Hình
10.6 thể hiện dự báo mà tham số được ước lượng sử dụng MAP. Ta thấy rằng
dự đoán Bayes có đuôi dài hơn, dải xác suất rộng hơn, và do đó ít thiên về
overfitting và nghịch lý kiểu thiên nga đen.




                  (a)                                            (b)
                         Hình 10.6. Dự báo hậu nghiệm và dự báo MAP



      11.4 Mô hình Dirichlet-Đa thức
      Trong phần trước, ta đã thảo luận cách suy diễn ra xác suất một đồng xu
xuất hiện mặt ngửa. Trong phần này, ta khái quát hóa các kết quả đó để tính
toán xác suất một con xúc xắc K mặt xuất hiện mặt k. Vấn đề này nghe qua có

                                                                                   189
vẻ vẫn là một ví dụ minh họa nhỏ, tuy nhiên mô hình ta sẽ khảo sát đây lại
được sử dụng rộng rãi để phân tích dữ liệu văn bản, dữ liệu sinh học, v.v.
      Mô hình này được mô tả bằng đồ thị sau:


                                                  Xi

        trong đó 𝛼 là siêu tham số (tham số của phân phối Dirichlet, không
ngẫu nhiên), 𝜃 là tham số (vector 𝐾 chiều) cho biết khả năng xuất hiện của
từng mặt của con xúc xắc, 𝑋 là biến ngẫu nhiên thể hiện kết quả của lần gieo
thứ 𝑖 trong 𝑁 lần gieo.

        11.4.1 Likelihood
        Giả sử ta quan sát N lần gieo xúc xắc, 𝒟 = {𝑥 , … , 𝑥 }, trong đó 𝑥 ∈
{1, … , 𝐾}. Nếu ta giả sử rằng dữ liệu là độc lập và cùng phân phối, likelihood sẽ
có dạng:

                                 𝑝(𝒟|𝜃) =       𝜃

      trong đó 𝑁 = ∑ 𝕀(𝑥 = 𝑘) là số lần mặt k xuất hiện (các số 𝑁 này là
thống kê đủ của mô hình này). Likelihood cho mô hình đa thức có cùng dạng.

       11.4.2 Tiên nghiệm
       Vì vector tham số nằm trên đơn hình xác suất K chiều, ta cần một tiên
nghiệm mà miền xác định là đơn hình này. Lý tưởng là nó có cả tính liên hợp.
May mắn là phân phối Dirichlet thỏa mã cả hai tiêu chuẩn trên. Vì thế ta dùng
tiên nghiệm:
                                    1
                      𝐷𝑖𝑟(𝜃|𝛼) =            𝜃       𝕀(𝑥 ∈ 𝑆 )
                                   𝐵(𝛼)


      11.4.3 Hậu nghiệm
      Nhân likelihood với tiên nghiệm ta có hậu nghiệm, cũng là một phân
phối Dirichlet như sau:
                    𝑝(𝜃|𝒟) ∝ 𝑝(𝒟|𝜃)𝑝(𝜃)

                             ∝     𝜃   𝜃     =       𝜃

                             = 𝐷𝑖𝑟(𝜃|𝛼 + 𝑁 , … , 𝛼 + 𝑁 )

       Ta thấy rằng hậu nghiệm là phân phối Dirichlet có tham số là tổng của
siêu tham số của tiên nghiệm (tần suất giả) 𝛼 và tần suất thực nghiệm 𝑁 .
       Ta có thể tính mode của hậu nghiệm này (ước lượng MAP) sử dụng giải
tích. Tuy nhiên, ràng buộc cần có là ∑ 𝜃 = 1. Áp dụng phương pháp số gia

                                                                                     190
Lagrange ta có thể tính ra các giá trị tham số. Hàm mục tiêu có ràng buộc, hay
hàm Lagrange, sẽ là:

          𝑙(𝜃, 𝜆) =    𝑁 log 𝜃 +     (𝛼 − 1) log 𝜃 + 𝜆 1 −       𝜃


       Ta thấy hàm trên là tổng của likelihood lô-ga-rít, tiên nghiệm lô-ga-rít,
và ràng buộc.
       Để đơn giản hóa ký hiệu, ta định nghĩa 𝑁 = 𝑁 + 𝛼 − 1. Lấy đạo hàm
riêng theo 𝜆 ta nhận được ràng buộc ban đầu:
                            𝜕𝑙
                               = 1−       𝜃 =0
                            𝜕𝜆


      Tính đạo hàm riêng theo 𝜃 ta có:
                              𝜕𝑙   𝑁
                                 =     −𝜆 =0
                             𝜕𝜃    𝜃
                              𝑁 = 𝜆𝜃

      Ta có thể tìm 𝜆 sử dụng ràng buộc tổng bằng một:
                                     𝑁 =𝜆       𝜃

                             𝑁+𝛼 −𝐾 =𝜆

      ở đây 𝛼 = ∑   𝛼 là kích thước mẫu tương đương của tiên nghiệm. Do
đó ước lượng MAP cho bởi:
                                 𝑁 +𝛼 −1
                           𝜃 =
                                 𝑁+𝛼 −𝐾

      Nếu ta sử dụng tiên nghiệm đều, 𝛼 = 1, kết quả sẽ là MLE:
                                      𝑁
                                 𝜃 =
                                       𝑁

      Đây đơn giản là tỉ lệ số lần mặt k xuất hiện được xác định dựa vào thực
nghiệm (dữ liệu).

      11.4.4 Dự đoán hậu nghiệm
      Phân phối dự đoán hậu nghiệm của một phép thử đa thức được tính
bằng công thức sau:
       𝑝(𝑋 = 𝑗|𝒟) =    𝑝(𝑋 = 𝑗|𝜃)𝑝(𝜃|𝒟)𝑑𝜃

                   =   𝑝 𝑋=𝑗𝜃         𝑝 𝜃 , 𝜃 𝒟 𝑑𝜃      𝑑𝜃
                                                      𝛼 +𝑁      𝛼 +𝑁
                   =   𝜃 𝑝 𝜃 𝒟 𝑑𝜃 = 𝐸 𝜃 |𝒟 =                  =
                                                    ∑ (𝛼 + 𝑁 ) 𝛼 + 𝑁


                                                                                   191
       ở đây 𝜃 là các thành phần của 𝜃 trừ 𝜃 .
       Biểu thức trên tránh được vấn đề tần suất bằng không. Thực tế, khi
phép thử có càng nhiều khả năng, vấn đề dữ liệu thưa cũng gia tăng, do đó
việc làm trơn càng trở nên quan trọng. Do đó dạng làm trơn Bayes này thậm
chí còn quan trọng hơn trường hợp nhị phân (mô hình Beta-nhị thức mà ta xét
ở phần trên).

       11.4.4.1 Ví dụ về mô hình ngôn ngữ
       Một ứng dụng của làm trơn Bayes sử dụng mô hình Dirichlet-đa thức là
mô hình ngôn ngữ. Bài toán này nhằm mục đích dự đoán những từ nào có thể
xuất hiện kế tiếp trong một chuỗi. Giả sử rằng từ thứ i, 𝑋 ∈ {1, … , 𝐾}, được lấy
mẫu độc lập với tất cả các từ khác sử dụng phân phối rời rạc 𝐶𝑎𝑡(𝜃). Mô hình
này được gọi là mô hình túi từ (bag of words model). Biết một dãy từ đã xuất
hiện, làm thế nào ta có thể dự đoán từ nào có khả năng xuất hiện kế tiếp?
       Để đơn giản, giả sử ta quan sát được dữ liệu (một bài đồng dao) sau:
                                 Con kiến mà leo cành đa
                              Leo phải cành cụt leo ra leo vào
                                Con kiến mà leo cành đào
                              Leo phải cành cụt leo vào leo ra

      Hơn nữa, giả sử từ vựng của chúng ta là:
           con_kiến, đa, đào, cành, cụt, leo, ra, vào, mà, phải, khế, cam
           1          2 3      4     5 6 7 8            9 10 11 12

       Chú ý là khế và cam là hai từ mà không xuất hiện trong dữ liệu trên. Ta
thay thế từ trong dãy đã cho bằng chỉ số tương ứng của nó và thu được:
                                       19642
                                    6 10 4 5 6 7 6 8
                                       19643
                                    6 10 4 5 6 8 6 7

      Bỏ qua trật tự từ, bằng cách đếm tần suất ta thu được bảng sau:
                   Từ       1 2 3 4 5 6 7 8 9 10 11 12
                   Tần suất 2 1 1 4 2 8 2 2 2 2 0 0

       Biểu diễn các tần suất bởi 𝑁 và giả sử ta sử dụng tiên nghiêm Dirichlet,
ta có phân phối dự đoán hậu nghiệm là:
                                      𝛼 +𝑁          1+𝑁       1+𝑁
            𝑝 𝑋=𝑗𝐷 =𝐸 𝜃 𝐷 =                      =         =
                                    ∑ 𝛼 +𝑁         12 + 26     38

      Nếu chọn 𝛼 = 1 ta có:
                       3 2 2 5 3 9 3 3 3 3 1 1
        𝑝 𝑋=𝑗𝐷 =( , , , , , , , , , , , )
                      38 38 38 38 38 38 38 38 38 38 38 38

                                                                                    192
      Mode của phân phối dự đoán là 𝑋 = 6 (từ leo). Chú ý rằng các từ khế và
cam mặc dù không có trong dữ liệu huấn luyện nhưng xác suất của chúng là
khác không và có thể xuất hiện trong tương lai.
      Đây chỉ là dạng mô hình ngôn ngữ hết sức đơn giản, không phụ thuộc
ngữ cảnh. Thực tế các mô hình ngôn ngữ hay được sử dụng hơn là các mô
hình ngram.

       ĐỌC THÊM
       Để kiểm soát được độ phức tạp của mô hình thì công cụ chính ở đây là
phải tham số hóa mô hình. Các tham số là phần còn lại của mô hình xác suất
mà chúng ta phải ước lượng. Đến đây có một vấn đề nho nhỏ, các tham số là
một giá trị không biết nhưng không ngẫu nhiên, hay bản thân chúng là ngẫu
nhiên. Có hai cách tiếp cận vấn đề này, trường phái tần suất giả dụ cách đầu,
còn trường phái Bayes thì giả dụ cách sau. Nội dung chương này có thể xem
như thiên về trường phái Bayes hơn. Như ta đã thấy, theo quan điểm này thì
đối với vấn đề ước lượng tham số thì chỉ suy diễn điều kiện vào dữ liệu có sẵn,
và lấy tích phân để làm mất các tham số ngẫu nhiên trong việc dự báo. Sau đó,
phân phối dự báo hậu nghiệm được dùng để tính xác suất của các điểm dữ
liệu mới, chưa biết. Trái lại, quan điểm tần suất sử dụng một ước lượng điểm
tối ưu, có thể được tính dựa vào MLE hay MAP, sau đó đưa vào công thức để
tính xác suất dữ liệu mới. Như đã minh họa trong chương này, phân phối dự
báo có một số ưu điểm như khả năng xử lý dữ liệu thưa, tuy nhiên khi dữ liệu
quan sát được lớn lên thì sự khác biệt giữa các tiếp cận sẽ giảm đi. Bảng dưới
đây so sánh cách giải quyết bài toán gieo đồng xu và bài toán gieo xúc xắc theo
hai tiếp cận tần suất và Bayes.

                         Tần suất                     Bayes
Bài toán gieo đồng xu
Tham số                  Không ngẫu nhiên             Ngẫu nhiên theo phân
                                                      phối Beta
Suy diễn tham số         MLE, MAP
Dự báo                   Phân phối Bernoulli          Phân phối dự báo hậu
                         với tham số 𝜃                nghiệm (còn gọi là
                         hoặc 𝜃                       BMA), cũng là phân
                                                      phối Bernouli nhưng
                                                      tránh được vấn đề dữ
                                                      liệu thưa
Bài toán gieo xúc xắc
Tham số                  Không ngẫu nhiên             Ngẫu nhiên theo phân
                                                      phối Dirichlet
Suy diễn tham số         MLE, MAP


                                                                                  193
Dự báo                     Phân phối rời rạc              Phân phối dự báo hậu
                           (Multinoulli)  với             nghiệm (còn gọi là
                           tham số 𝜃     hoặc             BMA), cũng là phân
                           𝜃                              phối Multinouli nhưng
                                                          tránh được vấn đề dữ
                                                          liệu thưa

      Chú ý là với mô hình thống kê còn các vấn đề như làm sao có thể đánh
giá được tính hiệu quả hoặc tính phổ quát của mô hình, làm sao có thể chọn ra
được mô hình hữu ích. Tuy nhiên, nội dung của chương không đi sâu vào các
vấn đề đó.

      Bài tập

       Bài 10.1. Cập nhật phân phối Beta
       Giả sử ta gieo đồng xu 5 lần. Giả sử X là số lần xuất hiện mặt ngửa. Ta
quan sát thấy rằng có ít hơn 3 lần xuất hiện mặt ngửa, nhưng ta không biết
chính xác là bao nhiêu lần. Chọn phân phối xác suất tiên nghiệm là 𝑝(𝜃) =
𝐵𝑒𝑡𝑎(𝜃|1,1). Hãy tính hậu nghiệm 𝑝(𝜃|𝑋 < 3), cụ thể bạn cần đưa ra một biểu
thức tỉ lệ với 𝑝(𝜃, 𝑋 < 3).

      Bài 10.2. Tiên nghiệm không chứa thông tin
      Giả sử 𝜙 = 𝑙𝑜𝑔𝑖𝑡(𝜃) = log
      Chỉ ra rằng nếu 𝑝(𝜙) ∝ 1 thì 𝑝(𝜃) ∝ 𝐵𝑒𝑡𝑎(𝜃|0,0)

      Bài 10.3. MLE cho phân phối Poisson
      Hàm phân phối Poisson được định nghĩa như sau:
      𝑃𝑜𝑖(𝑥|𝜆) = 𝑒        với 𝑥 ∈ {0,1,2, … } trong đó 𝜆 > 0 là tham số tỉ lệ.
                      !
      Hãy tính ước lượng MLE.

      Bài 10.4. Phân tích Bayes cho phân phối Poisson
      Trong bài tập trên ta đã định nghĩa phân phối Poisson với tỉ lệ 𝜆 và ước
lượng MLE của nó. Bây giờ ta sẽ phân tích Bayes liên hợp:
      a. Dẫn ra hậu nghiệm 𝑝(𝜆|𝐷) giả sử tiên nghiệm liên hợp là 𝑝(𝜆) =
         𝐺𝑎(𝜆|𝑎, 𝑏) ∝ 𝜆 𝑒
      b. Khi 𝑎 → 0 và 𝑏 → 0 hậu nghiệm sẽ tiến đến giá trị nào? (nhắc lại là
         trung bình của phân phối 𝐺𝑎(𝑎, 𝑏) là 𝑎/𝑏).

      Bài 10.5. MLE cho phân phối đều
      Xét một phân phối đều có tâm là 0 và độ rộng 2𝑎. Hàm mật độ xác suất
cho bởi


                                                                                  194
                                     1
                           𝑝(𝑥) =      𝐼(𝑥 ∈ [−𝑎, 𝑎])
                                    2𝑎

      a. Cho tập dữ liệu 𝑥 , … , 𝑥 , ước lượng MLE của a (ký hiệu 𝑎) là bao
         nhiêu?
      b. Xác suất mà mô hình gán cho một điểm dữ liệu mới 𝑥      sử dụng 𝑎
         là bao nhiêu?
      c. Bạn có thấy tiếp cận trên có vấn đề gì không? Bạn hãy gợi ý ngắn
         gọn một tiếp cận tốt hơn.

       Bài 10.6. Phân tích Bayes cho phân phối đều
       Xét phân phối đều 𝑈𝑛𝑖𝑓(0, 𝜃). Ước lượng hợp lý cực đại là 𝜃 = max (𝒟),
như ta thấy ở bài tập trên, nhưng ước lượng này không phù hợp để dự đoán
dữ liệu tương lai vì nó gán xác suất không cho các dữ liệu nằm ngoài tập huấn
luyện. Trong bài tập này, ta sẽ áp dụng phương pháp suy diễn Bayes cho phân
phối đều. Phân phối tiên nghiệm liên hợp là Pareto, 𝑝(𝜃) = 𝑃𝑎𝑟𝑒𝑡𝑜(𝜃|𝑏, 𝐾). Khi
đó phân phối hợp của 𝜃 và 𝒟 = {𝑥 , … , 𝑥 } là:
                                      𝐾𝑏
                         𝑝(𝒟, 𝜃) =         𝕀(𝜃 ≥ max(𝒟))
                                    𝜃

      Đặt 𝑚 = max (𝒟). Chứng cứ (xác suất cả N mẫu sinh ra từ cùng một
phân phối đều) là:
                                     𝐾𝑏
                          𝑝(𝒟) =           𝑑𝜃
                                   𝜃
                        ⎧      𝐾
                        ⎪ (𝑁 + 𝐾)𝑏     𝑛ế𝑢 𝑚 ≤ 𝑏
                      =
                        ⎨    𝐾𝑏
                        ⎪(𝑁 + 𝐾)𝑚      𝑛ế𝑢 𝑚 > 𝑏
                        ⎩

      Hãy dẫn xuất ra hậu nghiệm 𝑝(𝜃|𝒟) và chỉ ra rằng nó có thể được biểu
diễn như một phân phối Pareto.

       Bài 10.7. Bài toán taxicab
       Giả sử bạn đến một thành phố lạ và thấy một xe taxi đánh số 100. Liệu
có bao nhiêu xe taxi trong thành phố này? Giả sử rằng các xe taxi được đánh số
tuần tự bằng các số nguyên từ 0 trở lên đến cận là 𝜃 chưa biết. Do đó hàm
likelihood là phân phối đều 𝑝(𝑥) = 𝑈(0, 𝜃). Mục tiêu là ước lượng 𝜃. Ta sẽ sử
dụng suy diễn Bayes có được từ bài tập trên.
       a. Giả sử ta thấy một xe taxi đánh số 100, khi đó 𝒟 = {100}, 𝑚 =
          100, 𝑁 = 1. Sử dụng một tiên nghiệm không có thông tin về 𝜃 có
          dạng 𝑝(𝜃) = 𝑃𝑎(𝜃|0,0) ∝ 1/𝜃, hãy tính hậu nghiệm 𝑝(𝜃|𝒟).
       b. Tính trung bình hậu nghiệm, mode và số trung vị (median) của taxi
          trong thành phố, nếu đại lượng đó tồn tại.


                                                                                 195
      c. Thay vì cố gắng tính một ước lượng điểm về số taxi, ta có thể tính
         hàm mật độ dự đoán về số taxicab kế tiếp sử dụng:
                𝑝(𝐷 |𝐷, 𝛼) =    𝑝(𝐷 |𝜃)𝑝(𝜃|𝐷, 𝛼)𝑑𝜃 = 𝑝(𝐷 |𝛽)
         ở đây 𝛼 = (𝑏, 𝐾) là các siêu tham số, 𝛽 = (𝑐, 𝑁 + 𝐾) là các siêu tham
      số được cập nhật. Bây giờ xét trường hợp 𝒟 = {𝑚}, và 𝒟′ = {𝑥}. Sử dụng
      phương trình ở bài tập trên, hãy viết một biểu thức cho
                                      𝑝(𝑥|𝒟, 𝛼)
      Như trên, sử dụng một tiên nghiệm không có thông tin 𝑏 = 𝐾 = 0.
      d. Sử dụng công thức mật độ dự đoán để tính xác suất mà taxi kế tiếp
         bạn có thể thấy có số 100, 50, hay 150. Nghĩa là tính 𝑝(𝑥 = 100|𝒟, 𝛼),
         …
      e. Mô tả ngắn gọn (trong 1-2 câu) một cách nào đó có thể giúp mô hình
         dự đoán chính xác hơn.

      Bài 10.8. Ước lượng MAP cho phân phối Bernoulli với tiên nghiệm không liên
hợp
        Trong phần lý thuyết, ta đã tìm hiểu về suy diễn Bayes cho một tham số
tỉ lệ Bernoulli với tiên nghiệm 𝑝(𝜃) = 𝐵𝑒𝑡𝑎(𝜃|𝛼, 𝛽). Khi đó ước lượng MAP là:
                                      𝑁 +𝛼−1
                                𝜃=
                                    𝑁+𝛼+𝛽−2

      trong đó 𝑁 là số lần xuất hiện mặt ngửa, 𝑁 là số lần xuất hiện mặt xấp,
và 𝑁 = 𝑁 + 𝑁 là số phép thử.
      a. Bây giờ xét tiên nghiệm sau, qua đó thể hiện niềm tin rằng đồng xu
         là cân đối đồng chất hoặc hơi thiên về mặt xấp
                                   0.5 𝑛ế𝑢 𝜃 = 0.5
                        𝑝(𝜃) =     0.5 𝑛ế𝑢 𝜃 = 0.4
                                0 𝑛ế𝑢 𝜃 𝑐ó 𝑔𝑖á 𝑡𝑟ị 𝑘ℎá𝑐
      Tính ước lượng MAP theo tiên nghiệm này như là một hàm của 𝑁 và
N.
      b. Giả sử phân phối đúng là𝜃 = 0.41. Tiên nghiệm nào dẫn tới một ước
         lượng tốt hơn khi N nhỏ? Cái nào tốt hơn khi N lớn?

       Bài 10.9. Phân phối dự đoán hậu nghiệm cho một bó dữ liệu với mô hình
Dirichlet-đa thức
       Trong phần lý thuyết, ta đã đưa ra phân phối dự đoán hậu nghiệm cho
một phép thử đa thức sử dụng tiên nghiệm Dirichlet. Bây giờ xét việc dự đoán
một bó dữ liệu mới, 𝒟 = (𝑋 , … , 𝑋 ), bao gồm m phép thử đa thức(giống như
dự đoán m từ kế tiếp trong câu, giả sử chúng được sinh ra độc lập và cùng
phân phối). Dẫn xuất ra một biểu thức cho
                                  𝑝(𝒟|𝒟, 𝛼)
       Câu trả lời của bạn nên làm một hàm của 𝛼 và các tần suất cũ và mới
như sau:

                                                                                   196
                       𝑁    =         𝐼(𝑥 = 𝑘)
                                 ∈𝒟
                       𝑁     =        𝐼(𝑥 = 𝑘)
                                 ∈𝒟


Bài 10.10. Dự đoán hậu nghiệm cho Dirichlet-đa thức
a. Giả sử ta tính phân phối thực nghiệm trên các ký tự của bảng chữ cái
   Roman cộng với ký tự khoảng trống (tổng số 27 giá trị) từ 2000 mẫu.
   Giả sử ta thấy ký tự e 260 lần. Hãy tính 𝑝(𝑥     = 𝑒|𝒟), nếu ta giả sử
   𝜃~𝐷𝑖𝑟(𝛼 , … , 𝛼 ), trong đó 𝛼 = 10 với mọi k.
b. Giả sử trong 2000 mẫu, ta nhìn thấy ký tự e 260 lần, a 100 lần, và p 87
   lần. Hãy tính 𝑝(𝑥            = 𝑝, 𝑥      = 𝑎|𝒟) nếu ta giả sử
   𝜃~𝐷𝑖𝑟(𝛼 , … , 𝛼 ), trong đó 𝛼 = 10 với mọi k. Trình bày giải pháp
   của bạn.




                                                                             197
Chương 11

ENTROPY CỰC ĐẠI


Trong trường hợp ta không có đủ thông tin để phân biệt xác suất hai sự kiện, chiến lược tốt
nhất là coi chúng đồng khả năng.
                                                                           Pierre Laplace


        Ý tưởng về entropy cực đại có một lịch sử lâu dài. Laplace có thể coi là
cha đẻ của entropy cực đại khi quan niệm trong trường hợp ta không có đủ thông
tin để phân biệt xác suất hai sự kiện, chiến lược tốt nhất là coi chúng đồng khả năng.
Hay gần đây hơn là Jaynes: nó đồng ý với mọi thứ được biết nhưng tránh giả thuyết
những gì mà không được biết. Nhờ độ đo entropy của Shannon mà nguyên lý này
có thể được phát biểu bằng ngôn ngữ toán học và nhờ đó có ứng dụng trong
các lĩnh vực của khoa học máy tính như học máy, xử lý ảnh, xử lý ngôn ngữ tự
nhiên, v.v.
        Trong chương này ta sẽ tìm hiểu xem nguyên lý này được ứng dụng thế
nào trong suy luận thống kê. Ta sẽ thấy là phân phối entropy cực đại hóa ra
thuộc về họ phân phối mũ, một họ phân phối mà có nhiều tính chất hữu dụng.

11.1. HỌ PHÂN PHỐI MŨ
      Trong các chương trước, ta đã gặp các phân phối như phân phối chuẩn
(Gauss), phân phối Bernoulli, phân phối gamma, phân phối đều, v.v. Hầu hết
các phân phối này là thành viên của một lớp rộng hơn gọi là họ phân phối mũ.
Ở phần đầu của chương này, ta sẽ tìm hiểu về họ phân phối mũ này.
      Họ phân phối mũ đóng vai trò quan trọng trong lý thuyết thông tin,
thống kê, học máy, v.v. vì một số lý do sau:
   - Họ phân phối mũ là họ phân phối duy nhất mà có tiên nghiệm liên hợp,
      nhờ đó đơn giản hóa việc tính toán hậu nghiệm như đã chỉ ra trong
      chương trước.
   - Họ phân phối mũ là họ phân phối mà áp đặt ít giả thuyết nhất về dữ liệu, trong
      khi vẫn thỏa mãn các ràng buộc mà người dùng chọn.
   - Dưới một số điều kiện chính qui nhất định, họ phân phối mũ là họ phân
      phối duy nhất mà có các thống kê đủ với kích thước hữu hạn, nghĩa là
      ta có thể nén dữ liệu thành một biểu diễn có kích thước cố định mà
      không mất thông tin.

        11.1.1 Định nghĩa
        Một hàm mật độ xác suất hay phân phối xác suất 𝑝(𝑥|𝜃), với 𝑥 =
(𝑥 , … , 𝑥 ) ∈ 𝒳 và 𝜃 ∈ Θ ⊆ 𝑅 , được gọi là thuộc họ phân phối mũ nếu nó có

                                                                                              198
dạng:
                                 1
                       𝑝(𝑥|𝜃) =      ℎ(𝑥) exp[𝜃 𝜙(𝑥)]
                                𝑍(𝜃)
                              = ℎ(𝑥) exp[𝜃 𝜙(𝑥) − 𝐴(𝜃)]
        trong đó

                        𝑍(𝜃) =        ℎ(𝑥) exp[𝜃 𝜙(𝑥)] 𝑑𝑥
                                  𝒳
                        𝐴(𝜃) = log 𝑍(𝜃)

      Ở đây 𝜃 được gọi là tham số tự nhiên hay tham số chính tắc, 𝜙(𝑥) ∈ 𝑅
được gọi là vector thống kê đủ, 𝑍(𝜃) là hàm phân hoạch, 𝐴(𝜃) gọi là hàm phân
hoạch logarit hay hàm tích lũy, và ℎ(𝑥) là hằng số tỉ lệ, thường bằng 1. Nếu
𝜙(𝑥) = 𝑥 thì hàm phân phối đang xét thuộc họ phân phối mũ tự nhiên.
      Dạng hàm trên có thể được tổng quát hóa:
                    𝑝(𝑥|𝜃) = ℎ(𝑥) exp[𝜂(𝜃) 𝜙(𝑥) − 𝐴(𝜂(𝜃))]

      ở đây 𝜂 là một hàm ánh xạ tham số 𝜃 thành tham số chính tắc 𝜂 = 𝜂(𝜃).
Nếu dim(𝜃) < dim 𝜂(𝜃), hàm đang xét được gọi là thuộc họ phân phối mũ
cong, nghĩa là ta có nhiều thống kê đủ hơn tham số. Nếu 𝜂(𝜃) = 𝜃, mô hình
được gọi là thuộc dạng chính tắc. Ta sẽ luôn giả sử rằng mô hình ở dạng chính
tắc.

      11.1.2 Một số ví dụ
          c) Phân phối Bernoulli
      Phân phối Bernoulli với 𝑥 ∈ {0,1} có thể được viết dưới dạng họ phân
phối mũ như sau:
                 𝐵𝑒𝑟(𝑥|𝜇) = 𝜇 (1 − 𝜇)
                           = exp[𝑥 log 𝜇 + (1 − 𝑥) log(1 − 𝜇)]
                           = exp[𝜙(𝑥) 𝜃]

      ở đây 𝜙(𝑥) = [𝕀(𝑥 = 0), 𝕀(𝑥 = 1)] và 𝜃 = [log(𝜇) , log(1 − 𝜇)]. Tuy nhiên,
biểu diễn này là quá đầy đủ vì có một phụ thuộc tuyến tính giữa các thuộc
tính:
                     1 𝜙(𝑥) = 𝕀(𝑥 = 0) + 𝕀(𝑥 = 1) = 1

      Hệ quả là 𝜃 không phải là duy nhất, trái với yêu cầu thường có là biểu
diễn là tối thiểu theo nghĩa có duy nhất một 𝜃 ứng với phân phối. Trong
trường hợp này ta chỉ cần định nghĩa:
                                                   𝜇
                     𝐵𝑒𝑟(𝑥|𝜇) = (1 − 𝜇) exp 𝑥 log
                                                  1−𝜇

        Ta có 𝜙(𝑥) = 𝑥, 𝜃 = log       là tỉ lệ log-odds, và 𝑍 = 1/(1 − 𝜇). Ta có thể
khôi phục tham số trung bình 𝜇 từ tham số chính tắc sử dụng:


                                                                                       199
                                                         1
                                 𝜇 = 𝑠𝑖𝑔𝑚(𝜃) =
                                                       1+𝑒

          d) Phân phối rời rạc (multinoulli)
       Ta có thể biểu diễn phân phối rời rạc như một họ phân phối mũ tối
thiểu như sau (trong đó 𝑥 = 𝕀(𝑥 = 𝑘)):

         𝐶𝑎𝑡(𝑥|𝜇) =          𝜇    = exp[      𝑥 log 𝜇 ]


                     = exp[       𝑥 log 𝜇 + 1 −                 𝑥       log 1 −       𝜇   ]

                                             𝜇
                     = exp        𝑥 log                     + log 1 −             𝜇
                                           1−∑         𝜇
                                           𝜇
                     = exp        𝑥 log      + log 𝜇
                                           𝜇


      ở đây 𝜇 = 1 − ∑   𝜇 . Thay vào công thức trên ta có:
                  𝐶𝑎𝑡(𝑥|𝜃) = exp(𝜃 𝜙(𝑥) − 𝐴(𝜃))
                                  𝜇          𝜇
                         𝜃 = log , … , log
                                 𝜇            𝜇
                      𝜙(𝑥) = [𝕀(𝑥 = 1), … , 𝕀(𝑥 = 𝐾 − 1)]

      Tham số trung bình được tính như sau:
                                     𝑒
                            𝜇 =
                                  1+∑     𝑒

      Từ đó ta có:
                                       ∑       𝑒                    1
                         𝜇 = 1−                         =
                                     1+∑           𝑒        ∑           𝑒

      và do đó:

                                 𝐴(𝜃) = log 1 +             𝑒


      Nếu ta định nghĩa 𝜃 = 0, ta có thể viết 𝜇 = 𝑆(𝜃) và 𝐴(𝜃) = log ∑                        𝑒 ,
trong đó 𝑆 là hàm softmax:
                                        𝑒
                            𝑆(𝜂) =
                                     ∑     𝑒

         e) Phân phối Gauss một biến



                                                                                                    200
                                        1             1
                𝒩(𝑥|𝜇, 𝜎 ) =                 exp −      (𝑥 − 𝜇)
                                                     2𝜎
                                   (2𝜋𝜎 )
                                      1               1    𝜇    1
                               =             exp −      𝑥 + 𝑥−    𝜇
                                                     2𝜎    𝜎   2𝜎
                                 (2𝜋𝜎 )
                                   1
                               =      exp(𝜃 𝜙(𝑥))
                                 𝑍(𝜃)
      trong đó:
                                   𝜇/𝜎
                                   𝜃=−1
                                    2𝜎
                                   𝑥
                            𝜙(𝑥) =
                                   𝑥
                                                   𝜇
                         𝑍(𝜇, 𝜎 ) = √2𝜋𝜎 exp
                                                  2𝜎
                                        −𝜃  1           1
                            𝐴(𝜃) =         − log(−2𝜃 ) − log(2𝜋)
                                        4𝜃  2           2

       11.1.3 Dẫn xuất entropy cực đại
       Như đã nói ở đầu chương, một trong các lý do làm cho họ phân phối
mũ hay được sử dụng là vì phân phối này đặt ít giả thiết nhất về dữ liệu, trong
khi vẫn thỏa mãn các ràng buộc mà người dùng chọn. Cụ thể hơn, giả sử ta chỉ
biết các giá trị kỳ vọng của các thuộc tính hay hàm nào đó:
                                            𝑓 (𝑥)𝑝(𝑥) = 𝐹


       ở đây 𝐹 là các hằng số, 𝑓 (𝑥) là một hàm tùy ý. Nguyên lý entropy cực
đại nói là ta nên chọn phân phối có entropy cực đại (gần với đều nhất), thỏa
mãn các ràng buộc rằng mô-men của phân phối bằng với mô-men thực nghiệm
của các hàm đã mô tả.
      Để cực đại entropy với các ràng buộc mô tả trên, cộng với các ràng buộc
                              𝑝(𝑥) ≥ 0 và ∑ 𝑝(𝑥) = 1
      ta cần sử dụng phương pháp số gia Lagrange, hàm Lagrange cho bởi:

  𝐽(𝑝, 𝜆) = −         𝑝(𝑥) log 𝑝(𝑥) + 𝜆      1−        𝑝(𝑥) +     𝜆 (𝐹 −   𝑝(𝑥)𝑓 (𝑥))


      Ta coi 𝑝 là một vector độ dài cố định (vì ta đang giả sử 𝑥 là rời rạc). Ta
có:
                          𝜕𝐽
                               = −1 − log 𝑝(𝑥) − 𝜆 −            𝜆 𝑓 (𝑥)
                         𝜕𝑝(𝑥)


      Đặt             = 0 ta có:
                ( )




                                                                                        201
                                  1
                         𝑝(𝑥) =     exp −     𝜆 𝑓 (𝑥)
                                  𝑍


      ở đây 𝑍 = 𝑒    , sử dụng ràng buộc tổng bằng 1 ta có:
                                  1
                    1=     𝑝(𝑥) =     exp −     𝜆 𝑓 (𝑥)
                                  𝑍


      Do đó hằng số chuẩn hóa bằng:

                          𝑍=      exp −      𝜆 𝑓 (𝑥)


       Do đó phân phối cực đại entropy 𝑝(𝑥) có dạng phân phối mũ, hay còn
gọi là phân phối Gibbs.
       Trong phần này ta đã tìm cách chứng tỏ rằng phân phối entropy cực đại
thuộc họ phân phối mũ. Chứng minh trên khá đơn giản và thuần túy toán học.
Có lẽ đến giờ ta chưa hình dung rõ được phân phối entropy cực đại dùng cho
suy diễn thống kê (ví dụ suy luận Bayes) như đã được mô tả trong chương
trước thế nào. Ta chưa thấy các ràng buộc thể hiện thông tin thế nào, nó mới
được mô tả là các hàm tùy ý. Bên cạnh đó ta cũng chưa thấy biến thể hiện
thông tin về “lớp”. Ở phần sau ta sẽ tìm hiểu cụ thể hơn về các vấn đề đó,
phân phối entropy cực đại sẽ là phân phối xác suất có điều kiện và được dùng
cho bài toán phân lớp.

11.2. HÀM PHÂN LỚP ENTROPY CỰC ĐẠI
11.2.1 Ví dụ

       Trước tiên, khái niệm entropy cực đại sẽ được minh họa qua một ví dụ
đơn giản. Giả sử ta muốn mô hình hóa khả năng ra quyết định của một chuyên
gia dịch thuật trong việc dịch giới từ “in” từ tiếng Anh ra tiếng Việt. Mô hình p
của chúng ta cho biết khả năng chuyên gia dịch thuật chọn mỗi từ hay cụm từ
v trong tiếng Việt là từ/cụm từ dịch của “in” thông qua xác suất p(v). Để có
được phân phối p, ta cố gắng thu thập càng nhiều càng tốt các mẫu dịch của
người chuyên gia đó.
       Một manh mối hiển nhiên ta có thể thu được từ mẫu là danh sách
từ/cụm từ là khả năng dịch của “in”. Ví dụ, ta có thể khám phá ra rằng chuyên
gia dịch luôn chọn trong nhóm năm từ tiếng Việt sau {ở, trong, về, vào, theo}.
Với thông tin này, ta có thể đưa ra ràng buộc đầu tiên về mô hình p như sau:
                       p(ở) + p(trong) + p(về) + p(vào) + p(theo) = 1
        Nếu ràng buộc của ta chỉ có vậy, rõ ràng có vô số phân phối p thỏa
mãn. Chẳng hạn mô hình mà luôn gán xác suất 1 cho “ở” và xác suất 0 cho bốn
từ còn lại.
                                          p(ở) = 1

                                                                                    202
                            p(trong) = p(về) = p(vào) = p(theo) = 0
        Một mô hình khác là “theo” có xác suất 1/2 và “về” cũng có xác suất 1/2,
các từ còn lại có xác suất bằng 0:
                                      p(về) = p(theo) = 1/2
                                  p(ở) = p(trong) = p(vào) = 0
        Tuy nhiên dựa vào cơ sở nào mà ta chọn một trong hai mô hình trên? Rõ
ràng ta chỉ biết là người chuyên gia luôn chọn dịch “in” theo một trong năm
cách trên chứ không biết thêm là anh ta hay dùng cách nào hơn. Nói cách khác
hai mô hình trên đã giả thuyết nhiều hơn về cách ra quyết định (dịch) của
người chuyên gia mà ta thực sự biết. Như vậy một mô hình khác có vẻ hợp lý
hơn sẽ là:
                        p(ở) = p(trong) = p(về) = p(vào) = p(theo) = 1/5
        Mô hình này đã phân đều xác suất cho năm khả năng dịch mà ta biết.
Tuy nhiên nó không phải mô hình đều nhất nếu như mọi từ tiếng Việt khác
cũng được tính đến.
        Thực tế, ta thường muốn có thêm manh mối về cách dịch của người
chuyên gia từ dữ liệu ta thu thập được. Giả sử ta biết thêm được rằng người
chuyên gia chọn “ở” hay “trong” trong 30% số lần dịch. Tri thức mới này có
thể được dùng để cập nhật mô hình của ta, thể hiện bằng các ràng buộc:
                                     p(ở) + p(trong) = 3/10
                         p(ở) + p(trong) + p(về) + p(vào) + p(theo) = 1
        Với hai ràng buộc như vậy rõ ràng vẫn có vô số phân phối xác suất thỏa
mãn. Với lập luận tương tự như trong trường hợp một ràng buộc, một lựa
chọn khả dĩ là phân phối đều nhất:
                                     p(ở) = p(trong) = 3/20
                                p(về) = p(vào) = p(theo) = 7/30
        Giả sử ta tiếp tục phân tích dữ liệu và tìm ra một sự kiện nữa là trong
một nửa số trường hợp, người chuyên gia chọn “ở” hoặc “về”. Ta có thể đưa
thông tin này vào mô hình dưới dạng ràng buộc thứ ba:
                                     p(ở) + p(trong) = 3/10
                         p(ở) + p(trong) + p(về) + p(vào) + p(theo) = 1
                                       p(ở) + p(về) = 1/2
        Một lần nữa ta có thể tìm phân phối đều nhất thỏa mãn các ràng buộc.
Tuy nhiên lần này kết quả không hiển nhiên như hai lần trước (ít ràng buộc
hơn). Khi ta càng tăng số ràng buộc (cũng là tăng độ phức tạp mô hình), ta gặp
hai khó khăn một lúc:
    - Thứ nhất: thế nào là “đều” và làm thế nào để đo mức độ đều của một
        mô hình?
    - Thứ hai: làm thế nào để tìm ra mô hình đều nhất thỏa mãn các ràng
        buộc như trong ví dụ vừa nêu.
        Câu trả lời cho câu hỏi thứ nhất rõ ràng là độ đo entropy của Shannon.
Với câu hỏi thứ hai, trong phần đầu của chương ta đã thấy một phần câu trả
lời, đó là dạng tham số của phân phối sẽ là dạng mũ.

                                                                                   203
11.2.1 Bài toán phân lớp

       Giả sử ta cần dự đoán giá trị y thuộc tập hữu hạn 𝒴 dựa vào thông tin
mà ta đã biết được biểu diễn bởi x thuộc tập hữu hạn 𝒳. Trong ví dụ về dịch ở
phần trên, bài toán dự đoán của ta ứng với việc dịch từ “in” từ tiếng Anh sang
tiếng Việt trong đó y có giá trị thuộc tập {ở, trong, về, vào, theo}. Tuy nhiên ở
ví dụ đơn giản đó ta chưa xét đến thông tin chứa trong x, cho biết ngữ cảnh mà
từ “in” xuất hiện.
       Mục tiêu của ta là ước lượng phân phối xác suất có điều kiện p(y|x), cho
biết xác suất của y với điều kiện ngữ cảnh x. Ta gọi 𝒫 là tập tất cả các phân
phối xác suất có điều kiện có thể có. Do đó mô hình p(y|x) là một phần tử của
𝒫.

11.2.2 Dữ liệu huấn luyện

        Để ước lượng p(y|x), ta thu thập càng nhiều càng tốt các mẫu
(𝑥 , 𝑦 ), (𝑥 , 𝑦 ), … , (𝑥 , 𝑦 ). Trong ví dụ ta đang xét, mỗi mẫu sẽ chứa cụm từ x
biểu diễn các từ xuất hiện quanh “in”, cùng với từ dịch y của “in” sang tiếng
Việt. Tuy không thực tế8 lắm nhưng ta có thể hình dung là để có các mẫu dịch
đó, người chuyên gia được đưa các cụm từ tiếng Anh ngẫu nhiên có chứa “in”
và được yêu cầu dịch sang tiếng Việt.
        Ta có thể biểu diễn tập mẫu huấn luyện bằng phân phối xác suất thực
nghiệm 𝑝, cho bởi:
                                           1
                                 𝑝(𝑥, 𝑦) = × 𝑐𝑜𝑢𝑛𝑡(𝑥, 𝑦)
                                           𝑁
        trong đó 𝑐𝑜𝑢𝑛𝑡(𝑥, 𝑦) là số lần (𝑥, 𝑦) xuất hiện trong tập mẫu.
        Thực tế, một cặp (𝑥, 𝑦) nào đó sẽ không xuất hiện nhiều lắm trong dữ
liệu huấn luyện, tức là nó hoặc không xuất hiện, hoặc xuất hiện vài lần.

       11.2.3 Thống kê, thuộc tính, và ràng buộc
       Mục tiêu của chúng ta là xây dựng một mô hình thống kê mà sinh ra
mẫu huấn luyện mô tả bởi 𝑝(𝑥, 𝑦). Cấu kiện để xây dựng mô hình này là tập
các thống kê trên mẫu huấn luyện. Trong ví dụ trên ta đã xét một số thống kê
độc lập ngữ cảnh như: tần suất “in” được dịch thành “ở” hay “trong” là 3/10,
tần suất dịch “in” thành “ở” hoặc “về” là 1/2, v.v. Tuy nhiên ta cũng có thể
dùng các thống kê mà phụ thuộc vào thông tin điều kiện x. Ví dụ, ta có thể
phát hiện ra rằng, trong mẫu huấn luyện, nếu “spring” theo sau “in” thì tần
suất dịch “in” thành “vào” là 9/10.
       Để mô tả sự kiện “in” được dịch thành “vào” khi “spring” là từ xuất
hiện kề bên phải, ta có thể sử dụng hàm chỉ thị sau:

8Thực tế thì các mẫu dịch sẽ được học tự động từ tập các văn bản song ngữ dựa vào mô hình thống
kê.

                                                                                           204
                          1 𝑛ế𝑢 𝑦 = "𝑣à𝑜" 𝑣à "𝑠𝑝𝑟𝑖𝑛𝑔" 𝑡ℎ𝑒𝑜 𝑠𝑎𝑢 "𝑖𝑛"
             𝑓(𝑥, 𝑦) =
                          0             𝑛ế𝑢 𝑛𝑔ượ𝑐 𝑙ạ𝑖
       Giá trị kỳ vọng của f theo phân phối thực nghiệm 𝑝(𝑥, 𝑦) chính là thống
kê ta cần tính. Giá trị này như mô tả như sau:
                             𝑝(𝑓) =         𝑝(𝑥, 𝑦)𝑓(𝑥, 𝑦)
                                        ,
      Bất kỳ thống kê nào cũng có thể được biểu diễn dưới dạng kỳ vọng của
một hàm chỉ thị nhị phân phù hợp. Hàm chỉ thị trên gọi là hàm thuộc tính hay
ngắn gọn là thuộc tính.
      Khi tìm ra một thống kê hữu ích, ta có thể đưa vào mô hình dưới dạng
một ràng buộc. Ràng buộc có dạng:
                                   𝑝(𝑓) = 𝑝(𝑓)
      trong đó 𝑝(𝑓) là giá trị kỳ vọng của f theo mô hình p(y|x):
                           𝑝(𝑓) =       𝑝(𝑥)𝑝(𝑦|𝑥)𝑓(𝑥, 𝑦)
                                    ,
      Thay các biểu thức cụ thể của 𝑝(𝑓) và 𝑝(𝑓), ràng buộc là:
                         𝑝(𝑥)𝑝(𝑦|𝑥)𝑓(𝑥, 𝑦) =          𝑝(𝑥, 𝑦)𝑓(𝑥, 𝑦)
                    ,                             ,
      Chú ý là biết dữ liệu, 𝑝(𝑥, 𝑦), 𝑓(𝑥, 𝑦), 𝑝(𝑥) là đã biết, chỉ có các phân
phối xác suất có điều kiện 𝑝(𝑦|𝑥) là chưa biết.
      Chú ý là mặc dù có lúc hai thuật ngữ thuộc tính và ràng buộc được
dùng thay cho nhau, ta không được lẫn lộn hai từ này. Thuộc tính là một hàm
nhị phân của (𝑥, 𝑦), trong khi ràng buộc là phương trình của giá trị kỳ vọng
của hàm thuộc tính theo mô hình và theo dữ liệu huấn luyện.

       11.2.4 Nguyên lý entropy cực đại
       Giả sử ta có n hàm thuộc tính 𝑓 xác định các thống kê mà ta cho là quan
trọng trong việc mô hình hóa. Ta muốn mô hình của mình phù hợp với các
thống kê đó. Khi đó, mô hình p sẽ nằm trong tập con 𝒞 của 𝒫:
                       𝒞 = {𝑝 ∈ 𝒫|𝑝(𝑓 ) = 𝑝(𝑓 ) với 𝑖 ∈ {1,2, … , 𝑛}
       Hình 11.1 thể hiện một cách diễn giải hình học của bài toán ta đang mô
hình hóa. Ở đây 𝒫 là không gian tất cả các phân phối xác suất trên ba điểm,
hay còn gọi là đơn hình. Nếu không có ràng buộc gì (hình (a)), mọi mô hình
xác suất đều là có thể. Trong trường hợp có một ràng buộc 𝐶 , mô hình p sẽ bị
giới hạn trên đoạn thẳng biểu diễn 𝐶 như trong hình (b). Nếu thêm một ràng
buộc nữa, mô tả bởi 𝐶 , sẽ có hai khả năng xảy ra. Khả năng thứ nhất (hình (c)),
có đúng một mô hình p thỏa mãn cả hai ràng buộc, p là giao điểm của hai đoạn
thẳng biểu diễn ràng buộc. Khả năng thứ hai (hình (d)), không có mô hình nào
cùng thỏa mãn cả 𝐶 và 𝐶 cả. Tuy nhiên, theo cách mô hình hóa hiện tại của
chúng ta, vì các ràng buộc tuyến tính được trích rút từ dữ liệu huấn luyện, do
đó chúng không thể không nhất quán. Hơn nữa, các ràng buộc tuyến tính nói
chung sẽ không xác định duy nhất một khả năng 𝑝 ∈ 𝒫 như trong (c), mà tập
𝒞 = 𝒞 ∩ 𝒞 ∩ … ∩ 𝒞 có thể chứa một số lượng vô hạn phần tử.

                                                                                   205
      Trong các mô hình 𝑝 ∈ 𝒞, nguyên lý entropy cực đại nói rằng ta nên
chọn mô hình đều nhất. Thế nào là đều, ta có thể áp dụng độ đo entropy ở đây:
                      𝐻(𝑝) = −               𝑝(𝑥)𝑝(𝑦|𝑥) log 𝑝(𝑦|𝑥)
                                    ,
      Chú ý là ở công thức trên, 𝐻(𝑝) chính là 𝐻(𝑌|𝑋), trong đó X và Y là các
biến ngẫu nhiên với phân phối phụ thuộc 𝑝(𝑥)𝑝(𝑦|𝑥). Để nhấn mạnh sự phụ
thuộc của entropy vào phân phối p, ta dùng ký hiệu 𝐻(𝑝).
      Theo các tính chất của entropy đã học ở Chương 2, ta biết rằng entropy
nằm trong khoảng 0 và log |𝒴|, trong đó 𝒴 là tập các giá trị có thể có của y.
      Nguyên lý entropy cực đại: Để chọn một mô hình từ tập 𝒞 các phân
phối xác suất có thể có, ta chọn mô hình 𝑝∗ ∈ 𝒞 sao cho 𝐻(𝑝) đạt giá trị cực đại.
Nghĩa là:
                              𝑝∗ = 𝑎𝑟𝑔𝑚𝑎𝑥 ∈𝒞 𝐻(𝑝)
      Ta có thể chứng minh được là 𝑝∗ luôn xác định và duy nhất.



                                               P                               P


                                                                     C1




                          (a)                                   (b)




                                                P                              P
                                                                          C3
                                        C2                     C1
                         C1



                              (c)                                   (d)
                        Hình 11.1 Minh họa bài toán tối ưu ràng buộc



       11.2.5 Dạng tham số
       Nguyên lý entropy cực đại đưa ta đến một bài toán tối ưu hóa có ràng
buộc: tìm 𝑝∗ ∈ 𝒞 mà làm cực đại 𝐻(𝑝). Trong các trường hợp đơn giản, ta có
thể tìm ra nghiệm bằng giải tích. Chẳng hạn như ở ví dụ ta đã xét ở phần trên,
khi chỉ có hai ràng buộc. Tuy nhiên, lời giải cho bài toán entropy cực đại tổng
quát không đơn giản như vậy.


                                                                                    206
         Ta sẽ gọi bài toán
                            𝑝∗ = 𝑎𝑟𝑔𝑚𝑎𝑥 ∈𝒞 𝐻(𝑝)
      là bài toán nguyên thủy.
      Với mỗi thuộc tính 𝑓 , ta sử dụng một tham số 𝜆 (gọi là nhân tử
Lagrange). Hàm Lagrange được định nghĩa như sau:
                        Λ(𝑝, 𝜆) = 𝐻(𝑝) +              𝜆 (𝑝(𝑓 ) − 𝑝(𝑓 ))

        Giữ 𝜆 cố định, ta cực đại hóa hàm Lagrange theo 𝑝 ∈ 𝒫. Ta gọi 𝑝 là giá
trị p tại đó hàm Lagrange đạt cực đại và Ψ(𝜆) là giá trị cực đại tương ứng. Ta
gọi Ψ(𝜆) là hàm đối ngẫu. Không khó để tính ra giá trị cụ thể của các hàm 𝑝
và Ψ(𝜆) sử dụng giải tích:
                                    1
                       𝑝 (𝑦|𝑥) =        exp   𝜆 𝑓 (𝑥, 𝑦)
                                  𝑍 (𝑥)
                      Ψ(𝜆) = −          𝑝(𝑥) log 𝑍 (𝑥) +            𝜆 𝑝(𝑓 )

         ở đây 𝑍 (𝑥) là hằng số chuẩn hóa để đảm bảo rằng ∑ 𝑝 (𝑦|𝑥) = 1 với
mọi x:

                              𝑍 (𝑥) =      exp            𝜆 𝑓 (𝑥, 𝑦)

       Cuối cùng, ta đặt bài toán tối ưu đối ngẫu không ràng buộc:
                               𝜆∗ = 𝑎𝑟𝑔𝑚𝑎𝑥 Ψ(𝜆)
       Mô hình entropy cực đại với ràng buộc 𝒞 có dạng tham số 𝑝 ∗ (𝑦|𝑥) như
nêu trên, trong đó tham số 𝜆∗ được xác định nhờ giải bài toán đối ngẫu. Tuy
nhiên, việc giải bài toán đối ngẫu không dựa trên giải tích được mà phải sử
dụng phương pháp số và nằm ngoài phạm vi của giáo trình này.

         11.2.6 Quan hệ với likelihood cực đại
         Likelihood logarit
                                              ( , )
                 𝐿 (𝑝) = log         𝑝(𝑦|𝑥)           =        𝑝(𝑥, 𝑦) log 𝑝(𝑦|𝑥)
                                 ,                         ,
       Dễ kiểm tra rằng hàm đối ngẫu đã xét ở trên hóa ra chỉ là likelihood
logarit của mô hình mũ 𝑝 :
                                Ψ(𝜆) = 𝐿 (𝑝 )
       Với cách diễn giải này, kết quả của phần trên có thể được diễn đạt lại
như sau: Mô hình 𝑝∗ ∈ 𝒞 với entropy cực đại là mô hình thuộc họ tham số
𝑝 (𝑦|𝑥) mà cực đại hóa likelihood của mẫu huấn luyện 𝑝.
       Bảng dưới đây tổng kết framework nguyên thủy-đối ngẫu ta vừa xét.

                        Nguyên thủy                             Đối ngẫu
Bài toán                𝑎𝑟𝑔𝑚𝑎𝑥 ∈𝒞 𝐻(𝑝)                          𝑎𝑟𝑔𝑚𝑎𝑥 Ψ(𝜆)
Mô tả                   Entropy cực đại                         Likelihood cực đại
Kiểu tìm kiếm           Tối ưu có ràng buộc                     Tối ưu không ràng buộc

                                                                                         207
Miền tìm kiếm        𝑝∈𝒞                              Các vector thực {𝜆 , 𝜆 , … }
Nghiệm               𝑝∗                               𝜆∗
                                         𝑝∗ = 𝑝   ∗




       BÀI TẬP

      Bài 11.1. Quá trình entropy cực đại
      Tìm quá trình ngẫu nhiên với tỉ lệ entropy cực đại {𝑋 }          thỏa mãn các
ràng buộc:
      a) 𝐸𝑋 = 1, 𝑖 = 1,2, …
      b) 𝐸𝑋 = 1, 𝐸𝑋 𝑋 = , 𝑖 = 1,2, …
       c) Tìm phổ entropy cực đại cho các quá trình trong câu a và câu b.

       Bài 11.2. Entropy cực đại với các phân phối biên duyên
       Tìm phân phối entropy cực đại 𝑝(𝑥, 𝑦) mà có các phân phối biên duyên
sau:




         Bài 11.3. Các quá trình với phân phối biên duyên cố định
         Xét tập tất cả các hàm mật độ với phân phối biên duyên theo cặp cố
định 𝑓 , (𝑥 , 𝑥 ), 𝑓 , (𝑥 , 𝑥 ), …, 𝑓 , (𝑥 , 𝑥 ). Chứng minh rằng quá
trình entropy cực đại có các phân phối biên duyên trên là quá trình Markov
bậc nhất (có thể thay đổi theo thời gian). Nhận diện hàm mật độ
𝑓 ∗ (𝑥 , 𝑥 , … , 𝑥 ) cực đại.

     Bài 11.4. Sai số bình phương trung bình
     Giả sử {𝑋 }     thỏa mãn 𝐸𝑋 𝑋      = 𝑅 , 𝑘 = 0,1, … , 𝑝. Xét các hàm dự báo
𝑋 tuyến tính sau:

                                     𝑋 =      𝑏𝑋

       Giả sử rằng 𝑛 > 𝑝, tìm:
                             max min 𝐸 𝑋 − 𝑋
                                 (   )
       ở đây giá trị nhỏ nhất được tính theo tất cả các hàm dự báo tuyến tính 𝑏
và giá trị lớn nhất được tính theo tất cả các hàm mật độ 𝑓 thỏa mãn 𝑅 , … , 𝑅 .


                                                                                      208
      Bài 11.5. Các quá trình entropy cực đại
      a) Tìm quá trình ngẫu nhiên nhị phân với tỉ lệ entropy cực đại
         {𝑋 } , 𝑋 ∈ {0,1}, thỏa mãn 𝑃(𝑋 = 𝑋 ) = với mọi i.
      b) Tính tỉ lệ entropy của quá trình tìm được ở câu a.

      Bài 11.6. Xích Markov với entropy cực đại
      Giả sử {𝑋 } là xích Markov dừng với 𝑋 ∈ {1,2,3}. Giả sử 𝐼(𝑋 ; 𝑋 ) = 0
với mọi n.
      a) Tìm quá trình có tỉ lệ entropy cực đại thỏa mãn các ràng buộc trên.
      b) Kết quả sẽ thay đổi thế nào nếu 𝐼(𝑋 ; 𝑋 ) = 𝛼 với mọi n, trong đó 𝛼
          là giá trị nào đó thỏa mãn 0 ≤ 𝛼 ≤ log 3.




                                                                               209
Tài liệu tham khảo
A. L. Berger, S. A. D. Pietra, V. J. D. Pietra. A Maximum Entropy Approach to
Natural Language Processing. Computational Linguistics. 1996.

Christopher M. Bishop. Pattern Recognition and Machine Learning. Springer. 2007.

Thomas M. Cover, Joy A. Thomas. Elements of Information Theory, second edition.
A John Wiley & sons, Inc. 2006.

Larry Gonick, Woollcott Smith. The Cartoon Guide to Statistics. HarperPerennial
Publisher. 1993.

Frederick Jelinek. ACL Lifetime Achievement Award: The Dawn of Statistical ASR
and MT. Computational Linguistics. 2009.

David J.C MacKay. Information Theory, Learning, and Inference Algorithms.
Cambridge University Press. 2005.

Chris Manning and Hinrich Schütze, Foundations of Statistical Natural Language
Processing, MIT Press. Cambridge, MA: May 1999.

Kevin P. Murphy. Machine Learning: A Probabilistic Perspective. MIT Press. 2012.

C. E. Shannon, “A mathematical theory of communication,” Bell System Technical
Journal, vol. 27, pp. 379-423 and 623-656, July and October, 1948.

Raymond W. Yeung. Information Theory and Network Coding. Springer. 2008.

Nguyễn Duy Tiến và Vũ Viết Yên. Lý thuyết xác suất. NXB Giáo dục, 2009.




                                                                               210
PHỤ LỤC 1. Thuật ngữ Anh-Việt
analytic solution: nghiệm giải tích (hay nghiệm đúng/chính xác)

aperiodic: phi chu kỳ, không có chu kỳ

asymptotic equipartition property: tính chất tiệm cận phân phối đều

bookie: nhà cái

bound: cận

bounded: bị chặn

capacity: dung lượng

channel coding: mã hóa kênh

classifier: hàm phân lớp

codeword: từ mã

concave function: hàm lõm

conditional probability: xác suất có điều kiện

conjugate: liên hợp

constraint: ràng buộc

convex function: hàm lồi

convolutional code: mã chập

decoder: bộ giải mã

doubling rate: tốc độ gấp đôi

dual problem: bài toán đối ngẫu

empirical: thực nghiệm

encoder: bộ mã hóa

entropy rate: tỉ lệ entropy

exponential family: họ phân phối mũ


                                                                      211
feature: thuộc tính

gamble: cá độ, cá cược

indicator function: hàm chỉ thị

instantaneous code: mã tức thời

irreducible: không khả qui (tối giản?)

joint distribution: phân phối phụ thuộc

jointly typical: điển hình đồng thời

Lagrange multiplier: phương pháp nhân tử Lagrange

likelihood: hợp lý

marginal distribution: phân phối biên duyên

maximum likelihood estimate: ước lượng hợp lý cực đại

median: trung vị

mutual information: thông tin tương hỗ

normal distribution: phân phối chuẩn (hay bình thường?)

normalizing constant: hằng số chuẩn hóa

null space: hạch, nhân (của một phép biến đổi tuyến tính)

odds: tỉ lệ đặt cược

parameter estimate: ước lượng tham số, suy diễn về tham số

parametric: tham số

posterior: hậu nghiệm

prediction: dự báo

prefix code: mã tiền tố

primal problem: bài toán nguyên thủy

prior: tiên nghiệm



                                                             212
proportional gambling: chiến lược đánh cược tỉ lệ

random walk: đường đi ngẫu nhiên, đi bộ ngẫu nhiên

relative entropy: entropy tương đối

sample: mẫu

side information: thông tin bên lề

simplex: đơn hình

singular code: mã kỳ dị

smoothing: làm trơn

source coding: mã nguồn

sparse data problem: vấn đề dữ liệu thưa

stationary distribution: phân phối dừng

stationary process: quá trình dừng

stochastic: ngẫu nhiên

training: huấn luyện

typical set: tập điển hình

uniform distribution: phân phối đều

uniquely decodable code: mã tách được

universal coding: mã hóa phổ dụng

version space: không gian giải thích

wealth relative: tài sản tương đối, hệ số tài sản




                                                     213
PHỤ LỤC 2. Lời giải một số bài tập chọn lọc
      Bài 3.2. Entropy của hàm
      Đặt 𝑦 = 𝑔(𝑥), khi đó
                                 𝑝(𝑦) =                   𝑝(𝑥)
                                          :         ( )


      Với mỗi giá trị có thể có của y xét tập các x sao cho 𝑦 = 𝑔(𝑥)
                    𝑝(𝑥) log 𝑝(𝑥) ≤             𝑝(𝑥) log 𝑝(𝑦) = 𝑝(𝑦) log 𝑝(𝑦)
          :   ( )                     :   ( )


      vì với mọi x thuộc tập đang xét, 𝑝(𝑥) ≤ 𝑝(𝑦), thêm vào đó, 𝑙𝑜𝑔 là hàm
đơn điệu tăng do đó log 𝑝(𝑥) ≤ log 𝑝(𝑦).
      Mở rộng lập luận này trên toàn miền giá trị của X (và Y), ta có:
                              𝐻(𝑋) = −        𝑝(𝑥) log 𝑝(𝑥)

                                  =−                            𝑝(𝑥) log 𝑝(𝑥)
                                                :         ( )

                                  ≥−          𝑝(𝑦) log 𝑝(𝑦)

                                  = 𝐻(𝑌)

      dấu = xảy ra khi và chỉ khi g là ánh xạ 1-1.
      a) 𝑌 = 2 là hàm 1-1 do đó entropy, vốn là một hàm của xác suất
         (không phụ thuộc vào giá trị của biến ngẫu nhiên), không thay đổi.
         Ta có 𝐻(𝑌) = 𝐻(𝑋).
      b) Nếu không giới hạn miền xác định của X thì 𝑌 = cos 𝑋 không phải
         ánh xạ 1-1 do đó 𝐻(𝑌) ≥ 𝐻(𝑋). Nếu giới hạn trên một miền nào đó
         mà cos 𝑋 là ánh xạ 1-1 thì 𝐻(𝑌) = 𝐻(𝑋).

      Bài 3.4. Entropy của một tổng
      a) 𝑍 = 𝑋 + 𝑌. Do đó 𝑝(𝑍 = 𝑧|𝑋 = 𝑥) = 𝑝(𝑌 = 𝑧 − 𝑥|𝑋 = 𝑥)
       𝐻(𝑍|𝑋) =        𝑝(𝑥)𝐻(𝑍|𝑋 = 𝑥)

               =−        𝑝(𝑥)     𝑝(𝑍 = 𝑧|𝑋 = 𝑥) log 𝑝(𝑍 = 𝑧|𝑋 = 𝑥)

               =       𝑝(𝑥)     𝑝(𝑌 = 𝑧 − 𝑥|𝑋 = 𝑥) log 𝑝(𝑌 = 𝑧 − 𝑥|𝑋 = 𝑥)

               =       𝑝(𝑥)𝐻(𝑌|𝑋 = 𝑥)
             = 𝐻(𝑌|𝑋)
     Nếu X và Y là độc lập thì 𝐻(𝑌|𝑋) = 𝐻(𝑌). Vì 𝐼(𝑋; 𝑍) ≥ 0, ta có 𝐻(𝑍) ≥
𝐻(𝑍|𝑋) = 𝐻(𝑌|𝑋) = 𝐻(𝑌). Tương tự ta có thể chỉ ra rằng 𝐻(𝑍) ≥ 𝐻(𝑋).
     b) Xét phân phối sau

                                                                                214
                                   1 𝑣ớ𝑖 𝑥á𝑐 𝑠𝑢ấ𝑡 1/2
                              𝑋 = −𝑌 =
                                   0 𝑣ớ𝑖 𝑥á𝑐 𝑠𝑢ấ𝑡 1/2
       Khi đó 𝐻(𝑋) = 𝐻(𝑌) = 1 nhưng 𝑍 = 0 với xác suất 1 và do đó 𝐻(𝑍) = 0.
       c) Ta có
                         𝐻(𝑍) ≤ 𝐻(𝑋, 𝑌) ≤ 𝐻(𝑋) + 𝐻(𝑌)
       vì Z là một hàm của (𝑋, 𝑌) và 𝐻(𝑋, 𝑌) = 𝐻(𝑋) + 𝐻(𝑌|𝑋) = 𝐻(𝑋) + 𝐻(𝑌).
Dấu = xảy ra nếu và chỉ nếu (𝑋, 𝑌) là một hàm của Z và 𝐻(𝑌) = 𝐻(𝑌|𝑋), có
nghĩa là X và Y là độc lập.

       Bài 3.10. Thông tin tương hỗ của mặt sấp và mặt ngửa
       a) Giả sử X tương ứng với mặt trên Y ứng với mặt dưới. Ta có:
                       𝐼(𝑋; 𝑌) = 𝐻(𝑌) − 𝐻(𝑌|𝑋) = log 2 = 1
vì 𝑌~𝐵𝑒𝑟(1/2) và Y là một hàm của X.
       b) Chú ý rằng khi ta đã quan sát được mặt trước (ký hiệu X) của xúc
          xắc thì mặt trên (ký hiệu Y) có bốn khả năng như nhau. Do đó:
               𝐼(𝑋; 𝑌) = 𝐻(𝑌) − 𝐻(𝑌|𝑋) = log 6 − log 4 = log 3 − 1
vì X có phân phối đều trên tập {1,2, … ,6}.

      Bài 4.2. AEP và thông tin tương hỗ
      Vì các cặp (𝑋 , 𝑌 ) là độc lập, ta có:

       𝑃(𝑋 = 𝑥 , 𝑌 = 𝑦 , … , 𝑋 = 𝑥 , 𝑌 = 𝑦 ) =                       𝑃(𝑋 = 𝑥 , 𝑌 = 𝑦 )


      Tổng theo cả hai vế ta có:
      𝑃(𝑋 = 𝑥 , 𝑋 = 𝑥 , … , 𝑋 = 𝑥 )
                      =                   𝑃(𝑋 = 𝑥 , 𝑌 = 𝑦 , … , 𝑋 = 𝑥 , 𝑌 = 𝑦 )
                          (   ,…,   )∈𝒴


                                              =                        𝑃(𝑋 = 𝑥 , 𝑌 = 𝑦 )
                                                  (   ,…,   )∈𝒴


                                              =                  𝑃(𝑋 = 𝑥 , 𝑌 = 𝑦 )
                                                            ∈𝒴


                                              =         𝑃(𝑋 = 𝑥 )


      Tương tự, ta có:

                                     𝑃(𝑋 ) =          𝑃(𝑋 )


      Do đó ta có:
                     1     𝑝(𝑋 )𝑝(𝑌 ) 1                           𝑝(𝑋 )𝑝(𝑌 )
                       log            =                     log
                     𝑛      𝑝(𝑋 , 𝑌 )   𝑛                          𝑝(𝑋 , 𝑌 )

                                                                                           215
      Áp dụng luật số lớn:
                    1            𝑝(𝑋 )𝑝(𝑌 )         𝑝(𝑋)𝑝(𝑌)
                           log              → 𝐸 log
                    𝑛             𝑝(𝑋 , 𝑌 )          𝑝(𝑋, 𝑌)

      với xác suất 1, do đó:
                          1     𝑝(𝑋 )𝑝(𝑌 )
                            log            → −𝐼(𝑋; 𝑌)
                          𝑛      𝑝(𝑋 , 𝑌 )


      Bài 4.7. Kích thước hộp ngẫu nhiên
      Thể tích 𝑉 = ∏ 𝑋 là một biến ngẫu nhiên. Vì 𝑋 là độc lập và cùng
phân phối đều trên [0, 𝑎], ta có:
                                  1
                      log 𝑉 = log 𝑉
                                  𝑛
                                  1
                               =      log 𝑋 → 𝐸(log (𝑋))
                                  𝑛

      theo luật số lớn, vì 𝑋 và log (𝑋 ) là độc lập và cùng phân phối, và
𝐸(log (𝑋)) < ∞. Ta có:
                               1
                 𝐸(log (𝑋 )) =    log (𝑥) 𝑑𝑥 = log (𝑎) − 1
                               𝑎

      Do đó, vì 𝑒 là một hàm liên tục:
                                                     𝑎 𝑎
                           lim 𝑉 = 𝑒    →        =    <
                           →                         𝑒 2

      Do đó độ dài cạnh “hữu hiệu” của hình khối này là . Chú ý rằng vì 𝑋
là độc lập, 𝐸(𝑉 ) = ∏ 𝐸(𝑋 ) = ( ) .     là trung bình số học của biến ngẫu nhiên,
 là trung bình hình học.

      Bài 5.1. Đường đi ngẫu nhiên trong khối lập phương
      Tỉ lệ entropy của một đường đi ngẫu nhiên trên đồ thị với trọng số bằng
nhau cho bởi:
                                               𝐸      𝐸
                       𝐻(𝒳) = log(2𝐸) − 𝐻         ,…,
                                              2𝐸      2𝐸

      Tổng số cạnh là 𝐸 = 54, do đó:
                                  3       3         4       4
            𝐻(𝒳) = log 108 + 8       log      + 12     log
                                 108     108       108     108
                 5        5        6       6
            +6       log      +1      log
                108      108      108     108
                  = 2.03 𝑏𝑖𝑡


                                                                                    216
      Bài 5.2. Entropy của đồ thị
      Đồ thị như mô tả của bài toán sẽ thuộc một trong ba dạng sau:




      Tỉ lệ entropy cho bởi:
                             ℋ=−        𝜇    𝑃 log 𝑃

                                     𝑊
                                =      log(𝑊 )
                                     𝑊


      Đồ thị thứ nhất:
                                                  2
                        {𝑊 } = {2,2,2} ⇒ ℋ = 3      log 2 = 1
                                                  6

      Đồ thị thứ hai:
                                             3
                       {𝑊 } = {1,1,1,3} ⇒ ℋ = log 3 = 0.79
                                             6

      Đồ thị thứ ba:
                                                 2
                   {𝑊 } = {1,2,2,1} ⇒ ℋ = 2        log 2 = 0.667
                                                 6

      Như vậy đồ thị ba có tỉ lệ entropy nhỏ nhất, đồ thị thứ nhất có tỉ lệ
entropy lớn nhất.

      Bài 5.4. Tỉ lệ entropy của quá trình con chó tìm xương
      a) Theo luật xích

                           𝐻(𝑋 , … , 𝑋 ) =   𝐻 𝑋 𝑋


                   = 𝐻(𝑋 ) + 𝐻(𝑋 |𝑋 ) +          𝐻(𝑋 |𝑋   ,𝑋    )

      vì với 𝑖 > 1, vị trí kế tiếp chỉ phụ thuộc vào hai vị trí trước đó (nghĩa là
nếu coi vị trí của con chó là trạng thái thì đường nó đi sẽ là xích Markov bậc 2).
Vì 𝑋 = 0 một cách tất định, 𝐻(𝑋 ) = 0 và vì bước đầu tiên là tiến hay lùi đều
với khả năng như nhau nên 𝐻(𝑋 |𝑋 ) = 1. Hơn nữa với 𝑖 > 1:
                            𝐻(𝑋 |𝑋 , 𝑋 ) = 𝐻(.1, .9)
      Do đó:
                      𝐻(𝑋 , 𝑋 , … , 𝑋 ) = 1 + (𝑛 − 1)𝐻(.1, .9)



                                                                                     217
b) Từ câu trên ta có
              𝐻(𝑋 , 𝑋 , … , 𝑋 ) 1 + (𝑛 − 1)𝐻(.0, .9)
                               =
                   𝑛+1                   𝑛+1
                             → 𝐻(.1, .9)

c) Đặt S là số bước con chó đi trước khi đổi chiều. Ta có:

                      𝐸(𝑆) =       𝑠(. 9)   (.1)

                              = 10
Bắt đầu từ thời điểm 0, số bước kỳ vọng trước khi đổi chiều là 11.

Bài 5.11. Xích Markov
a) Đặt 𝜇 thể hiện hàm phân phối tại thời điểm n. Vì 𝜇 = ( , , ) và
   𝜇 = 𝜇 𝑃 = 𝜇 , 𝜇 = 𝜇 = ( , , ) với mọi n và {𝑋 } là dừng.
b) Vì {𝑋 } là quá trình Markov dừng
              1
         lim 𝐻(𝑋 , … , 𝑋 ) = 𝐻(𝑋 |𝑋 )
          → 𝑛


                              =     𝑃(𝑋 = 𝑘)𝐻(𝑋 |𝑋 = 𝑘)

                                  1 1 1 1
                              =3× ×𝐻 , ,
                                  3 2 4 4
                                3
                              =
                                2

c) Vì (𝑋 , … , 𝑋 ) và (𝑍 , … , 𝑍 ) là một-một, theo luật xích của entropy và
   tính chất Markov:
               𝐻(𝑍 , … , 𝑍 ) = 𝐻(𝑋 , … , 𝑋 )

                          =       𝐻(𝑋 |𝑋 , … , 𝑋     )


                          = 𝐻(𝑋 ) +         𝐻(𝑋 |𝑋       )

                          = 𝐻(𝑋 ) + (𝑛 − 1)𝐻(𝑋 |𝑋 )
                                   3
                          = log 3 + (𝑛 − 1)
                                   2

d) Vì {𝑋 } là quá trình Markov dừng với 𝜇 = ( , , )
                                  1 1 1
               𝐻(𝑋 ) = 𝐻(𝑋 ) = 𝐻 , , = log 3
                                  3 3 3
Với 𝑛 ≥ 2




                                                                               218
                                            1
                                        ⎧0,
                                        ⎪ 2
                                            1
                                     𝑍 = 1,
                                        ⎨ 4
                                        ⎪ 1
                                         2,
                                        ⎩ 4

      Do đó:
                                         1 1 1  3
                            𝐻(𝑍 ) = 𝐻     , , =
                                         2 4 4  2

      e) Do tính chất đối xứng của P, 𝑃(𝑍 |𝑍         ) = 𝑃(𝑍 ) với 𝑛 ≥ 2. Do đó,
         𝐻(𝑍 |𝑍 ) = 𝐻(𝑍 ) = .
      f) Giả sử 𝑘 ≥ 2. Trước tiên chú ý rằng do tính đối xứng của P, 𝑍        =
         𝑋    − 𝑋 là độc lập với 𝑋 . Vì:
                  𝑃(𝑍 |𝑋 , 𝑋 ) = 𝑃(𝑋       − 𝑋 |𝑋 , 𝑋 )
                                   = 𝑃(𝑋   − 𝑋 |𝑋 )
                                   = 𝑃(𝑋   −𝑋 )
                                   = 𝑃(𝑍 )

       cho nên 𝑍     là độc lập với (𝑋 , 𝑋 ) và do đó độc lập với 𝑍 = 𝑋 −
𝑋   . Khi 𝑘 = 1, tương tự trên, do tính đối xứng của P, 𝑍 độc lập với 𝑍 = 𝑋 .

      Bài 6.4. Entropy tương đối là giá của việc chọn mã không tối ưu
      a)
                𝐻(𝑝) =      −𝑝 log 𝑝

                        1 1 1   1 1   1    1    1
                   = − log − log − log − 2 log
                        2 2 4   4 8   8   16   16
                     15
                   =
                      8
      Tương tự 𝐻(𝑞) = 2

                                 𝑝
          𝐷(𝑝||𝑞) =      𝑝 log
                                 𝑞
                    1   1/2 1    1/4 1    1/8     1   1/16
                 = log     + log    + log     + 2 log
                    2   1/2 4    1/8 8    1/8    16   1/8
                    1
                 =
                    8
      Tương tự 𝐷(𝑞||𝑝) = .
      b) Độ dài trung bình của C là
                      1       1      1           1      15
               𝐸𝐿 = × 1 + × 2 + × 3 + 2 ×           ×4=
                      2       4      8          16       8
      Tương tự, độ dài từ mã trung bình của 𝐶 là 2.
      c)


                                                                                   219
                     1       1       1    1
                𝐸 𝐿 =   ×1+ ×3+ ×3+2×       ×3=2
                     2       4       8   16
      Lớn hơn 𝐻(𝑝) một lượng 𝐷(𝑝||𝑞) = .
      d) Tương tự 𝐸 𝐿 =     , lớn hơn 𝐻(𝑞) một lượng 𝐷(𝑞||𝑝) = .

      Bài 6.10. Rượu hỏng
      a) Giả sử ta thử mỗi lần một chai và bắt đầu từ chai thứ nhất, nếu chai
         này không hỏng thì thử tiếp chai thứ hai, … Theo cách đó số lần thử
         để xác định được chai rượu hỏng sẽ là một biến ngẫu nhiên L có thể
         nhận các giá trị 𝑙 lần lượt là {1,2,3,4,5,5}, 𝑝(𝑙 ) = ( , , , , , ).
         Giống như lập luận trong chứng minh định lý về mã tối ưu, để cực
         tiểu hóa số lần thử kỳ vọng ∑ 𝑝 𝑙 , ta nên chọn thứ tự thử sao cho 𝑙 ≤
         𝑙 nếu 𝑝 > 𝑝 . Do đó, thứ tự thử tốt nhất chính là thứ tự ta đã chọn
         ở trên. Khi đó số lần thử kỳ vọng sẽ là:

                      7      5      4      4      3      3
           𝑝𝑙 =1×       +2×    +3×    +4×    +5×    +5×
                     26     26     26     26     26     26
                  75
               =
                  26
                = 2.88
       b) Chai cần thử đầu tiên là chai thứ nhất với xác suất 7/26.
       c) Ý tưởng là sử dụng mã Huffman
       Bạn tự tìm mã Huffman cho phân phối thể hiện xác suất hỏng của các
chai rượu. Một kết quả đúng là: {01, 11, 000, 001, 100, 101}.

      Khi đó số lần thử kỳ vọng là:
                      7      5      4      4      3      3
           𝑝𝑙 =2×       +2×    +3×    +3×    +3×    +3×
                     26     26     26     26     26     26
                 66
               =
                 26
               = 2.54
      Chú ý rằng giá trị này gần với entropy 𝐻(𝑝) = 2.52 bit.

      d) Hỗn hợp của các chai 1, 3, 4 nên được thử trước (hoặc tương đương
         như vậy là 2, 5, 6).

      Bài 6.18. Mã giá nhỏ nhất
      a) Ta muốn cực tiểu 𝐶 = ∑ 𝑝 𝑐 𝑙 với ràng buộc ∑ 2 ≤ 1. Ta giả sử
         ràng buộc là đẳng thức và đặt 𝑟 = 2 , 𝑄 = ∑ 𝑝 𝑐 , 𝑞 = 𝑝 𝑐 /𝑄. Khi
         đó q cũng là một phân phối và ta có thể viết:




                                                                                  220
                 𝐶=      𝑝𝑐𝑙
                                   1
                   =𝑄      𝑞 log
                                   𝑟
                                     𝑞
                   =𝑄          𝑞 log −      𝑞 log 𝑞
                                     𝑟
                   = 𝑄(𝐷(𝑞||𝑟) + 𝐻(𝑞))
Để C đạt giá trị nhỏ nhất ta chọn 𝑟 = 𝑞 và khi đó:
                                        𝑝𝑐
                           𝑙 ∗ = − log
                                       ∑𝑝 𝑐
Và giá trị C nhỏ nhất là: 𝐶 = 𝑄𝐻(𝑞).

b) Nếu ta tìm mã Huffman cho phân phối q (thay vì p) thì đa sẽ thu
   được mã với giá kỳ vọng cực tiểu.
c) Bây giờ ta xét đến ràng buộc nguyên của độ dài từ mã. Đặt:
                               𝑙 = ⌈− log 𝑞 ⌉
Khi đó
                        − log 𝑞 ≤ 𝑙 ≤ − log 𝑞 + 1
Nhân hai vế với 𝑝 𝑐 và cộng theo i ta có:
                         𝐶∗ ≤ 𝐶         < 𝐶∗ + 𝑄

Bài 7.1. Hậu xử lý đầu ra
a) Theo mô hình của nhà thống kê học, kênh truyền sẽ có thêm một
    bước hậu xử lý bằng hàm 𝑌 = 𝑔(𝑌). Khi đó 𝑋, 𝑌, 𝑌 sẽ tạo thành một
    xích Markov 𝑋 → 𝑌 → 𝑌. Do đó ta có thể áp dụng bất đẳng thức xử lý
    dữ liệu:
                             𝐼(𝑋; 𝑌) ≥ 𝐼(𝑋; 𝑌)
Từ đó có thể suy ra 𝐶 ≥ 𝐶 . Như vậy khẳng định của nhà thống kê học là
sai, việc hậu xử lý đầu ra không làm tăng được dung lượng kênh.

b) Phương pháp của nhà thống kê không làm giảm dung lượng kênh
   trong trường hợp dấu = xảy ra trong bất đẳng thức xử lý thông tin,
   tức là 𝑋 → 𝑌 → 𝑌 hay nói cách khác 𝑌 là một thống kê đủ của Y.

Bài 7.2. Máy chữ nhiễu
a) Trong trường hợp máy chữ hoạt động bình thường, ấn phím nào thì
   chữ cái tương ứng được in ra, dung lượng kênh sẽ là:
               𝐶 = max 𝐼(𝑋; 𝑌) = max 𝐻(𝑋) = log 26
đạt được khi 𝑋 có phân phối đều.
b) Trong trường hợp máy chữ nhiễu, tức là khi gõ phím, hoặc ký tự
   tương ứng hiện ra (xác suất 1/2) hoặc ký tự kế tiếp trong bảng chữ
   cái hiện ra (xác suất 1/2). Khi đó 𝐻(𝑌|𝑋) = log 2, không phụ thuộc
   vào phân phối của 𝑋. Ta có:
     𝐶 = max 𝐼(𝑋; 𝑌) = max 𝐻(𝑌) − log 2 = log 26 − 1 = log 13
đạt được khi 𝑌 có phân phối đều, muốn như vậy phân phối của 𝑋 phải

                                                                         221
là phân phối đều.
      c) Nếu sử dụng một mã đơn giản với độ dài khối 1 và để việc truyền
          thông không bị lỗi thì ta chỉ nên sử dụng một nửa số phím của máy
          chữ, cụ thể là các phím A, C, …, W, Y.
                           log(𝑠ố 𝑡ừ 𝑚ã) log 13
                       𝑅=                =       = log 13
                             độ 𝑑à𝑖 𝑘ℎố𝑖     1

       Bài 7.3. Kênh Z
       Vì bảng chữ cái vào là nhị phân nên phân phối vào ta có thể biểu diễn
bằng một tham số 𝛼 = 𝑃(𝑋 = 1). Sau khi đã tham số hóa phân phối vào, kết
hợp với ma trận xác suất chuyển 𝑝(𝑦|𝑥) đề bài cho, ta có thể xác định được
phân phối phụ thuộc 𝑝(𝑥, 𝑦) và từ đó xác định 𝑝(𝑦). Từ đó ta có:
           𝐻(𝑌|𝑋) = 𝑃(𝑋 = 0) × 𝐻(𝑌|𝑋 = 0) + 𝑃(𝑋 = 1) × 𝐻(𝑌|𝑋 = 1)
                    = (1 − 𝛼) × 0 + 𝛼 × 1 = 𝛼
                         𝛼
              𝐻(𝑌) = 𝐻( )
                         2
                                           𝛼
            𝐼(𝑋; 𝑌) = 𝐻(𝑌) − 𝐻(𝑌|𝑋) = 𝐻       −𝛼
                                           2
       Để tính dung lượng kênh, ta cần cực đại hóa 𝐼(𝑋; 𝑌) theo 𝛼 ∈ (0; 1). Chú
ý 𝐼(𝑋; 𝑌) là một hàm lõm theo 𝛼 nên cực đại đó là tồn tại.
       Lấy đạo hàm theo 𝛼, ta có:
                            𝑑          1     1 − 𝛼/2
                              𝐼(𝑋; 𝑌) = log          −1
                           𝑑𝛼          2       𝛼/2
       Cho đạo hàm bằng 0 ta được 𝛼 = 2/5 (chú ý 𝑃(𝑋 = 1) < là hợp lý vì
𝑋 = 1 là đầu vào nhiễu của kênh). Vì thế dung lượng kênh Z là 𝐻                       − =
0.722 − 0.4 = 0.322 bit.

      Bài 7.4. Kênh có nhớ có dung lượng cao hơn
                                         𝑌 = 𝑋 ⨁𝑍
      trong đó
                                        1 𝑣ớ𝑖 𝑥á𝑐 𝑠𝑢ấ𝑡 𝑝
                                 𝑍 =
                                        0 𝑥á𝑐 𝑠𝑢ấ𝑡 1 − 𝑝
      và các 𝑍 là không độc lập.
      Khi 𝑋 , 𝑋 , … , 𝑋 được chọn độc lập và cùng phân phối 𝐵𝑒𝑟( ),
       𝐼(𝑋 , 𝑋 , … , 𝑋 ; 𝑌 , 𝑌 , … , 𝑌 ) = 𝐻(𝑋 , … , 𝑋 ) − 𝐻(𝑋 , … , 𝑋 |𝑌 , … , 𝑌 )
                                         = 𝐻(𝑋 , … , 𝑋 ) − 𝐻(𝑍 , … , 𝑍 |𝑌 , … , 𝑌 )
                                         ≥ 𝐻(𝑋 , … , 𝑋 ) − 𝐻(𝑍 , … , 𝑍 )
                                         ≥ 𝐻(𝑋 , … , 𝑋 ) −         𝐻(𝑍 )
                                         = 𝑛 − 𝑛𝐻(𝑝)

      Do đó, dung lượng của kênh có nhớ qua 𝑛 lần sử dụng là:
             𝑛𝐶 ( ) = max 𝐼(𝑋 , 𝑋 , … , 𝑋 ; 𝑌 , 𝑌 , … , 𝑌 )
                           (   ,…,   )
                     ≥ 𝐼(𝑋 , 𝑋 , … , 𝑋 ; 𝑌 , 𝑌 , … , 𝑌 )   (   ,   ,…,   )   ( )



                                                                                            222
                   ≥ 𝑛(1 − 𝐻(𝑝))
                   = 𝑛𝐶

       Do đó, kênh có nhớ có dung lượng cao hơn. Ta có thể giải thích kết quả
này là sự tương quan nhiễu đã làm giảm ảnh hưởng nhiễu. Thông tin về nhiễu
được truyền trong quá khứ có thể giúp xử lý nhiễu hiện tại.

      Bài 8.4. Entropy của một cuộc đua công bằng
      a) Tài sản kỳ vọng 𝐸𝑆(𝑋) là

                                𝐸𝑆(𝑋) =      𝑆(𝑥)𝑝(𝑥)


                                      =     𝑏(𝑥)𝑜(𝑥)𝑝(𝑥)


                                       =     𝑏(𝑥)

                                          =1
      Chú ý là ở biến đổi trên ta đã vận dụng giả thiết 𝑜(𝑥) = 1/𝑝(𝑥).
      b) Tỉ lệ tăng tài sản tối ưu 𝑊 ∗ đạt được khi 𝑏(𝑥) = 𝑝(𝑥) với mọi x, khi
         đó:
                             𝑊 ∗ = 𝐸(log 𝑆(𝑋))

                                =     𝑝(𝑥) log 𝑏(𝑥)𝑜(𝑥)


                                =     𝑝(𝑥) log 𝑝(𝑥)/𝑝(𝑥)


                                =     𝑝(𝑥) log(1)

                                =0

      như vậy tài sản hiện có được giữ nguyên.
      c) Nhờ thông tin bên lề, tài sản tăng một lượng 𝐼(𝑋; 𝑌). Đặt 𝑞 =
          𝑃(𝑌 = 1) = 𝑝(1) + 𝑝(2).
                           𝐼(𝑋; 𝑌) = 𝐻(𝑌) − 𝐻(𝑌|𝑋)
                                   = 𝐻(𝑌) = 𝐻(𝑞)
      vì Y là hàm của X.
      d) Đã được tính ở trên.




                                                                                 223
Bài 8.5 Cuộc đua âm
a) Để tìm cực đại có ràng buộc, ta xét hàm Lagrange sau:
                     𝐿(𝜆, 𝑏) =     𝑝 ln(1 − 𝑏 ) + 𝜆      𝑏
Lấy đạo hàm theo 𝑏 và đặt nó bằng không ta có:
                       𝜕𝐿(𝜆, 𝑏)    −𝑝
                                =      +𝜆 =0
                         𝜕𝑏       1−𝑏
Giải để tính 𝑏 , ta có 𝑏 = 1 − 𝑝 /𝜆. Thay vào ràng buộc ta có:
                                       𝑝         1
                   1=     𝑏 =      (1 − ) = 𝑚 −
                                       𝜆         𝜆

Từ đó suy ra 𝜆 =      . Do đó:
                         𝑏∗ = 1 − (𝑚 − 1)𝑝

b) Ta có:
              𝑊∗ =         𝑝 ln((𝑚 − 1)𝑝 ) = ln(𝑚 − 1) − 𝐻(𝑝)


Bài 8.6. Cá cược
a)
                                  1    1 3
                       𝐸𝑋 = 3 ×     +0× =
                                  2    2 2
                                                3
                   𝐸𝑆 = 𝐸        𝑋 =     𝐸𝑋 =
                                                2
b) Ta thấy rằng 𝑆 > 0 nếu và chỉ nếu 𝑋 = 3 với mọi 𝑖 ≤ 𝑛.
                       𝑃{𝑆 ≥ 𝜖} ≤ 𝑃{𝑆 > 0)
                                1
                             =      →0
                                2
c) Tỉ lệ tăng tài sản được cực đại hóa bằng cách cực đại hóa logarit kỳ
   vọng:
                             1                  1
         𝐸 ln(1 − 𝑏 + 𝑏𝑋) = ln(1 − 𝑏 + 3𝑏) + ln(1 − 𝑏)
                             2                  2
                     1              1
                       ln(1 + 2𝑏) + ln(1 − 𝑏)
                     2              2
Lấy đạo hàm theo b
          1              1
       𝑑(2 ln(1 + 2𝑏) + 2 ln(1 − 𝑏))        2       −1
                                      =           +
                     𝑑𝑏                 2(1 + 2𝑏) 2(1 − 𝑏)
Cho đạo hàm bằng không và tính b ta được:
                                    1
                               𝑏∗ =
                                    4

d)
                            1
                      lim     ln 𝑆 = 𝐸 ln (1 − 𝑏) + 𝑏𝑋
                       →    𝑛

                                                                          224
          1           1    1       1
         =   ln 1 + 2     + ln 1 −
          2           4    2       4
           1
         = ln(9/8)
           2
         = 0.0589
Do đó:
                .
         𝑆 =𝑒




                                       225
